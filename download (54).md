<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Java - JDK and Java Classes

<span class="lead"> </span>

<span id="The_Java_Development_Kit"></span>

**At the end of this module, you should be able to:**

- understand what makes Java a programming language worth studying
- explain the basic concept of Object Oriented Programming and how they relate to Java
- create and manipulate the base Java types which include Boolean, byte, char (including Strings), short, int, long, float, and double
- craft multiple Java Classes which include comments, constructors, static and instance variables (fields), accessors, public and private methods and instantiate and use Objects of these classes.
- implement and use the String and Date data types
- understand the reason behind and use of BigDecimals (\*\*\* OPTIONAL \*\*\*)
- craft and use for loops (\*\*\* OPTIONAL \*\*\*)
- craft and use while loops and do while loops (\*\*\* OPTIONAL \*\*\*)
- craft and use recursion (\*\*\* OPTIONAL \*\*\*)
- craft and use Java conditionals, branching, including if-then, if-then-else, and switch statements (\*\*\* OPTIONAL \*\*\*)

#### Pro Tip

Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.

Brian Kernighan

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [Video: JX Java Optional Objectives](https://youtu.be/_FUd49FHk78)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to understand what makes Java a programming language worth studying

<span id="Java_Introduction"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

![Java Logo](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%201%20-%20JX%20Java%20-%20I%20JDK%20and%20Java%20Classes/assets/javalogo.png)

### So What About Java

So why study Java? Well here are several good reasons. Arguably more lines of code are written in Java than any other programming language. It is popular with:

- Internet of Things (IoT) devices
- Desktop, Gaming development (Minecraft is written in Java!)
- Android Development
- Full stack Web development

Java is frequently used in high schools and colleges as the language to introduce programming. Many programmers know the language. Java has been in use for many years so there is a lot of legacy code that needs maintaining.

Java Development can be split into 3 different categories:

- **Core Java:** Every Java programmer needs to know this at some level. System developers, IoT programmers, and desktop coders need to know this area very well.
- **Android Development:** New Android development is done primarily in Kotlin but there is a lot of legacy code in Java.
- **Web development:** This is the area where we will be concentrating.

Java has been around for awhile and has gone through many changes. It was first released in 1996 by Sun Microsystems which became part of Oracle in 2010.

Version numbering has also changed. Versions 1, 2, 3, 4, 5, 6, 7, 8 were actually (1.1, 1.2 … 1.8). Version 1.8, also called version 8, was the last 32-bit version; about 2/3 of the companies using Java are still on this version. With version 9, the numbering system and language went through major changes, including only 64-bit versions and payment required for commercial usage. Version 8 is still free.

As of March 25, 2020, we are on version 11 as the Long Term Support Version. The current version is version 14.

OpenJDK is an alternative to the commercial version by Oracle:

- Free for all uses

- Oracle does support OpenJDK

- OpenJDK does not work well with other Oracle products

- see <https://openjdk.java.net/> for more information

- Comments on the name **_Java_**

  - It is named for either the beverage or the island; I am with the group that says it is named for the beverage!
  - Java is not related to JavaScript other than:
    - Both are programming languages used on the web
    - Both share 4 letters
      - **_Java_** is to **_Java_**Script like **_Lamb_** is to **_Lamb_**da or **_Car_** is to **_Car_**pet

- Java was originally developed to make web content dynamic

  - This was done through Java applets. These proved very insecure and so we moved on
  - Java is cross platform operational but how?
    - It could have forced each web browser to have a Java compiler built into. This was the approach JavaScript took.
    - It could have forced to have the code compiled for each type of machine on which it was run. This is the approach for C languages, C, C++, C#
    - Java choose to compile to an intermediate code that would run on virtual machines.
      - To run any Java program, your machine must be running a Java Virtual Machine (JVM).
        - JVMs are compiled to native machine language for each type of computer.
      - This intermediate code is called **Bytecode**.

- Java Conceptual Diagram
  - To run Java on a machine, you must have the Java Virtual Machine (JVM) installed.
  - On most machines, the JVM makes use of certain modules to aid in operations.
    - These modules plus the JVM make up the Java Run Environment Environment (JRE).
  - Tools and APIs have been developed to help with Java application development.
    - These modules plus the JRE make up the Java Development Kit (JDK).
  - So the JVM is part of the JRE which is part of the JDK.

Java Conceptual Diagram from Oracle <https://docs.oracle.com/javase/8/docs/index.html>

![Java Conceptual Diagram](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%201%20-%20JX%20Java%20-%20I%20JDK%20and%20Java%20Classes/assets/java_conceptual_diagram.png)

- Java has 5 Primary Goals
  - It must be “simple, object-oriented, and familiar”
    - so mimics C++ a popular programming language at the time of Java’s release.
  - It must be “robust and secure”.
  - It must be “architecture-neutral and portable”.
  - It must execute with “high performance”.
  - It must be “interpreted, threaded, and dynamic”.

#### Java’s Organization: Object Oriented

Everything in Java starts with a Class. From this Class you can instantiate, make an instance of, objects. Most work is then done on these objects.

    // A Class, or blueprint, of something
    class Car
    {
        data;
        behaviors();
    }

    // Objects - real things constructed from the Class following its blueprint
    // in the end we will have three objects of type Car - truck, sedan, suv
    // they all know the same things (data) and can do the same things (behaviors)
    Car truck = new Car();
    Car sedan = new Car();
    Car suv = new Car();

#### Java’s Organization: Strongly Typed

Everything in Java has a type, which is a way to say what type of data can be stored in that memory location. Once set, the type cannot change and the value of a variable is unknown until initialized.

    int count = 1;
    boolean stopIt;

Java Arrays are not immune to being strongly typed:

- Arrays have a fixed length predetermined before they can be used.
- Arrays contain a single data element type.

#### Java Development

Java development is primarily done through Integrated Development Environments. These combine a full featured text editor with the JDK to enhance productivity. Two main competitors are:

- [Eclipse](https://www.eclipse.org/): popular open source, free, system
- [JetBrains IntelliJ IDEA](https://www.jetbrains.com/idea/): commercial product with a free alternative and the one we use in class

For the first few days of class we do not use an IDE. To be taken seriously as a Java programmer, you need experience working with the JDK without an IDE. It’s also a good way to experience the language without the crutch of an IDE.

Instead, we will be using a text editor and the command line interface (CLI) for the JVM. The choice of text editor is up to you. The instructor will be using [Sublime](https://www.sublimetext.com/).

##### Follow Along

### Let’s code some Java

We are going to program a standard Hello World Program. Such a program is a good way to get started as it familiarizes you with the language and development environment, walking us through all the steps in generating a Java application

- Input: Entering the source code
- Processing: Compiling, Interpreting, Building
- Output: Run, Execute Program and Find the output!

Let’s get started. So follow along. The naming of things and the case, upper or lower, that is used makes a huge difference in Java programming. So, follow the directions!

**Create a directory / folder**

- Create some directory where can you can store your Java code, for example `jxwork`. I will call this `<work dir>`
- Now create a directory where you can store this application. `<work dir>/helloapp`
- Under `helloapp` create a directory `src` and under `src` a directory `hello`. So in the end you are sitting in the directory
  - `<work dir>/helloapp/src/hello`
    - `<work dir>` - is just a directory for us to store all of our Java work
    - `helloapp` - the name of our application
    - `src` - where we put our source code. The JDK requires this to be called src
    - `hello` - the name of our package. All Java code is organized into packages. We will learn more about these through out the course.
- Now create a text file in that directory called `HelloWorld.java` and enter the following Java code:
- Some comments on this code first
  - We will be explaining this code in detail in future lessons
  - By habit, I put my opening curly braces `{` on a new line. This is common among older Java programmers.
    - You are welcome to put the `{` at the end of the previously line
    - Both positioning will be acceptable in class; just be consistent. Follow their programming style standards for the company you work for.
    - The class name must match the file name. In this code the class name is `HelloWord` and the file name is `HelloWorld` with a `.java` extension.

<!-- -->

    package hello;

    public class HelloWorld
    {
        public static void main(String[] args)
        {
            Greeter greeter = new Greeter();
            System.out.println(greeter.sayHello());
        }
    }

Create another text file called `Greeter.java` and enter the following code

    package hello;

    public class Greeter
    {
        public String sayHello ()
        {
            return "Hello World!";
        }
    }

Now that we have our source code in place, we need to convert that source code to **bytecode** so we can execute it using the Java Virtual Machine (JVM)

- Go to a command / terminal prompt and change directories to the `src` directory you created above. Run the following commands from the `<work dir>/helloapp/src/` directory:

<!-- -->

    javac hello/*.java

This created a series of `*.class` files in the `hello` directory; one `*.class` file for each `*.java` file. These `*.class` files contain the bytecode the will be run on the JVM.

If all works, you should get nothing for an output - just a return to the prompt. If something does not work, the normal mistake is to have a typo in the source code. If this is the case, you will see output similar to:

    hello/Greeter.java:7: error: ';' expected
            return "Hello World!"
                                 ^
    1 error

The error message tells you

- the file where the compiler found the error, in our case `hello/Greeter.java`
- the line number where the compiler thinks the error is located, in our case `:7:`
- a comment on what the compiler thinks the error is, in our case

<!-- -->

    ';' expected
            return "Hello World!"

If this happens, go back and review the source code, fix the error, and redo the compiling statement `javac hello/*.java`. Keep cycling through until you have no more errors.

Next: Distributing a directory of `*.class` files is clunky. Normally we archive the class files into a `*.jar` file and then distribute that `*.jar` file. Again issue the following command from the `<work dir>/helloapp/src/` directory.

    jar cvfe hellothere.jar hello.HelloWorld hello/*.class

where cvfe are options meaning

- **c** - create a new archive file with a given name
- **v** - generate verbose output
- **f** - specific the jar output file to be created, in our case _hellothere.jar_
- **e** - sets the main class also called the Entry point, in our case _hello.HelloWord_

You should get output similar to

    added manifest
    adding: hello/Greeter.class(in = 287) (out= 220)(deflated 23%)
    adding: hello/HelloWorld.class(in = 496) (out= 327)(deflated 34%)

And finally - Now we are ready to execute the program. Again issue the following command from the `<work dir>/helloapp/src/` directory.

    java -jar hellothere.jar

- `java` launches the JVM
- `-jar` says we are using a `*.jar` file, the most common type of Java archived file
- `hellothere.jar` is the name of application

You should get the following output

    Hello World!

If you do not, go back and fix your original code. Each time you change something in the source code, you will have to redo all three steps to see the effects of your change:

    javac hello/*.java
    jar cvfe hellothere.jar hello.HelloWorld hello/*.class
    java -jar hellothere.jar

Congratulations. You just wrote a Java application!!!

##### Dig Deeper

- [Oracle Java Documentation](https://docs.oracle.com/en/java/javase/11/)  
  Official Oracle Java 11 Documentation
- [Open JDK](https://openjdk.java.net/)  
  Open JDK - Alternative to Oracle's Java
- [Free](https://medium.com/@javachampions/java-is-still-free-2-0-0-6b9aa8d6d244)  
  Java is Still Free
- [State of Java](https://www.baeldung.com/java-in-2019)  
  Baeldung - The State of Java in 2019

---

#### Learn to explain the basic concept of Object Oriented Programming and how they relate to Java

<span id="Object_Oriented_Programming"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

Java is an Object Oriented Programming (OOP) Language. For comparison, JavaScript is considered an object based (OBP) or prototype based language.

### OOP is a Programming Style

A programming style is a way of organizing programs based on some conceptual model of programming. The style should include an appropriate language to make programs written in that style clear and readable. OOP specifically supports objects that are data abstractions with an interface of named operations (methods) and a hidden local state (fields or attributes). Objects have an associated type (Class) and classes may inherit attributes from superclasses.

To do work in Java, you must first create a Class, sometimes called a factory or a blueprint. From that Class, you create, or instantiate, an object. You can create as many of the same objects as you wish, just like a factory can mass produce a product. Work in Java is done on these Objects.

#### Classes

- Collections of objects
- Blueprint to create individual objects
- Static Fields and Methods - class level attributes and behaviors shared by all objects of the class

#### Objects

- An entity with state (fields) and behaviors (methods)
- Chair, person, dog - examples of a physical or logical entity upon which the program performs work
- Considered an “instance” of a class; to make an object, you instantiate it
- This is where the work in Java happens!

Two popular frameworks organize the principles behind OOP. Interviewers like to ask questions like “What are the 4 Pillars of OOP?” and “Explain SOLID and its relationship to Java”. So, let’s take a look at these two questions!

#### Four Pillars of Object Oriented Programming

- **Abstraction**
  - Hiding internal details and showing functionality
  - We can access our smartphone but may not know how the internals work
- **Encapsulation**
  - Wrapping, binding all code and data together
  - State of the object and behavior all in one
  - Fields are kept private and accessed through methods (getters and setters)
- **Polymorphism**
  - Poly = many, morph = form
  - Use the same word with different meanings
  - Method overloading: same method with different parameters resulting in different behaviors
  - Method overriding: a child can implement a method differently than the parent. The parent or the child method can be invoked (called) based on context
- **Inheritance**
  - A new class can adopt (inherit) the properties (fields and/or methods) from another class
  - The original class is called a parent or superclass
  - The new class is called a child or subclass

**S.O.L.I.D.**

- **S**ingle-responsibility principle

  - A class should only do one thing, have a single responsibility, a single job - manage configuration for Swagger, interface with the employee’s table, print a HelloWorld message.

- **O**pen-closed principle

  - Objects are open for extension but closed for modification.
  - Open says you can add fields (behaviors) by inheriting from the class
  - Closed says other entities can rely on the object’s structure (fields and methods) through implementation of a standard interface

- **L**iskov substitution principle

  - Objects can be replaced with subtypes without alternating the correctness of the program. Subtypes should do at least what their parents do.

- **I**nterface segregation principle

  - Just implement what you need; many interfaces are better than a huge general one

- **D**ependency Inversion Principle

  - Abstract as much as possible. “Entities must depend on abstractions not on concretions”. Higher level classes must not depend on lower classes. Modules are all separate entities that can be tied together using some abstract layer.

So how do these principles work in Java and Spring? You will want to revisit this section as you learn more about Java and the Spring Framework

Wait a minute. What is the Spring Framework? This is a Java Framework we will introduce later in the course that will aid us in developing Web based application. It is a huge library of Java code that we will make extensive use of.

#### Four Pillars of Object Oriented Programming: Examples with Spring

- **Abstraction:** Creating a class
- **Encapsulation:** Creating pieces of code that do one thing well and then calling is over and over again. For example a routine to access the database can be used regardless of the database
  - Grouping our fields and methods into classes for a single entity. Everything related to employees, data and behaviors, goes with employees, everything related to the company goes with the companies.
- **Polymorphism:** We can create a `sum` function that takes various parameters
  - sum(1, 2) = 3
  - sum(‘a’, ‘b’, ‘c’) = abc
  - sum(5) = 5
  - We can create a variety of ways to create an object depending on how much information we can give to the method. The method then implements the objects based on available information
- **Inheritance:** Abstract classes and interfaces
  - Child classes can then inherit their parents characteristics and expand upon those.

#### S.O.L.I.D.: Examples with Spring

- **S**ingle-responsibility principle
  - Manage configuration for Swagger, interface with the employee’s table, print a `HelloWorld` message.
- **O**pen-closed principle
  - The Spring Framework is a great example. The core logic is fixed; we cannot change it. The framework does have interfaces where we can inject own our code.
- **L**iskov substitution principle
  - Our abstract classes will fit this description.
- **I**nterface segregation principle
  - Different interfaces for different functions.
- **D**ependency Inversion Principle
  - In Spring all modules are separate entities but can be used together as Beans.

##### Dig Deeper

- [OOPs Concepts](https://www.javatpoint.com/java-oops-concepts)  
  Java OOPs Concepts
- [SOLID](https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)  
  S.O.L.I.D: The First 5 Principles of Object Oriented Design
- [4 Pillars](https://howtodoinjava.com/oops/object-oriented-principles/)  
  4 Pillars of OOP with Java Examples

---

#### Learn to create and manipulate the base Java types which include Boolean, byte, char (including Strings), short, int, long, float, and double

<span id="Base_Type_in_Java"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

### Strongly Typed Language

Java is considered a strongly typed language. This means that when we create a variable, we have to tell Java what type of data that variable will contain. We call this declaring a variable. Once that type is set, it cannot be changed. The value can change but not its type. We also have to specifically initialize a variable before we use it; that is we have to give the variable a value. Thus Java requires more upfront planning regarding variables than some other languages such as JavaScript.

So for example, if we need a variable to count something, we declare the variable:

    int count;

This sets up a memory location called `count` that can store integers. Thus the memory location can store `7` but not `7.25`, `7.0`, `"seven"`.

Then we initialize the variable:

    count = 0;

This is read as “count is assigned 0”. Do not confuse this with comparing count and 0. That is `count == 0` and is read “count equals 0”. Before the variable is initialized, integers have a default value of 0. However, it is considered poor programming practice to use these default values, so in general initialize your variables!

Declaring and initializing a variable can be done all in one step; this is quite common:

    int count = 0;

Some other examples include:

- Declaring a **double** variable. Notice the use of the `.0` In Java a `3` is an integer. A `3.0` is a double. I know in math we say they have the same value and are the same. In programming, they still have the same value but are NOT the same and are not interchangeable!

<!-- -->

    double money = 3.0;

- Declaring a **boolean** variable. These values have valued of `true` or `false` (yes lowercase!):

<!-- -->

    boolean hasIt = true;

Java has 8 different primitive data types or types that are built into the language. These are:

<table><thead><tr class="header"><th>Type</th><th>Description</th><th>Default</th><th>Size</th><th>Example Literals</th></tr></thead><tbody><tr class="odd"><td>boolean</td><td>true or false</td><td>false</td><td>1 bit</td><td>true, false</td></tr><tr class="even"><td>byte</td><td>twos complement integer</td><td>0</td><td>8 bits</td><td>(none)</td></tr><tr class="odd"><td>char</td><td>Unicode character</td><td>\u0000</td><td>16 bits</td><td>‘a’, ‘\u0041’, ‘\n’, ‘≠’</td></tr><tr class="even"><td>short</td><td>twos complement integer</td><td>0</td><td>16 bits</td><td>(none)</td></tr><tr class="odd"><td>int</td><td>twos complement integer</td><td>0</td><td>32 bits</td><td>-2, -1, 0, 1, 2</td></tr><tr class="even"><td>long</td><td>twos complement integer</td><td>0</td><td>64 bits</td><td>-2l, -1l, 0l, 1l, 2l</td></tr><tr class="odd"><td>float</td><td>IEEE 754 floating point</td><td>0.0</td><td>32 bits</td><td>1.23e100f, -1.23e-100f, .3f, 3.14f</td></tr><tr class="even"><td>double</td><td>IEEE 754 floating point</td><td>0.0</td><td>64 bits</td><td>1.23e100, -1.23e-100 .3, 3.14</td></tr></tbody></table>

In practice, the types we generally just use

- **int** for example `3`
- **long** for example `3l` (notice the `l` to say it is long as opposed to an integer)
- **double** for example `3.0`
- **boolean** for example `true`
- **char** for example `'a'`

In addition to the primitive data types, we can create our own data types using Java classes. By convention, a class starts with an uppercase letter. This is not enforced in Java syntax but is the choice of programmers. The language forces primitive data types to start with a lowercase letter. Sometimes we call these primitive data types **base** data types; they are the same thing.

- Declaring a **String** variable. A String is not a primitive type. It is actually a Class derived using the primitive type char. That is why String is capitalized!

<!-- -->

    String school = "Lambda School";

Another programming tip: Notice that all these commands have ended with a semicolon `;` A `;` is **required** at the end of all Java statements.

### Scope

**Scope** is defined as the space in the program where variables are available for use. Scope tells us in which blocks of code which variables are available. Java is very strict about the way it handles scope.

- Fields are in scope throughout the class
- Local variable are in scope from their declaration to the end of the block
- You can reuse names in different scopes, blocks
- You can even hide names within a scope

### Random Number Generator

A popular programming process is to randomly generate numbers, rolls of dice, playing cards, and test data, among many many other examples. Each programming language has a different twist on how to implement these random events. Here is an example with Java:

But first a note on `import`: `Random` is not part of the core Java language. You will find that many constructs we use are not part of the core language. To make use of these other statements, we need to import libraries. Here we are importing from a very popular library `java.util` and we importing the class `Random`.

How do you know when and what to import? Soon we will be using the Integrated Development Environment (IDE) JetBrains IntelliJ Idea. This IDE will manage the imports for us, adding them when needed. Until then, what normally happens in practice is:

- You use a construct
- You try to compile and get a syntax error
- You remember you need an import: You remember the import you need and add it to your source code or you search the web for what you need

Not the most scientific way of approaching the situation but it is what is often done in practice!

    package randoms;

    import java.util.Random;

    public class Main
    {
        public static void main(String args[])
        {
            Random rand = new Random();


            // generate a random integer from min int through max int
            int iresult = rand.nextInt();

            // Pick a number from 0, 1, 2, 3, 4
            // the 5 as the parameter below says to pick from the 5 numbers, starting with 0
            // here we are reusing the variable iresult. It has already been
            // declared so we can just use it.
            iresult = rand.nextInt(5);

            // Now let's pick a number from 5 to 10 by
            // picking from the 6 numbers starting with 0
            // 0, 1, 2, 3, 4, 5
            // now add 5 to that number. So possible choices are
            // 5, 6, 7, 9, 9, 10
            iresult = rand.nextInt(6) + 5;

            // pick a random double between 0.0 and 1.0
            // now we are working with a different data type, double,
            // so we need a new result variable.
            double dresult = rand.nextDouble();
        }
    }

### Typecasting

Sometimes you have one data type but need to convert it to be another type. For example:

- You need a double but you are working with an integer
- You have a double but need an integer
- You want to display a double

Changing data types is called **type casting**. When you go from a smaller data type to a larger one, you are **widening casting**. This is done automatically in Java. If a data type completely contains a different data type you are trying to assign it, conversion happens automatically. `double` contains all values of integers, so assigning an integer to a double is handled automatically by Java.

- `double myValue = 3;`

When you go from a larger data type to a smaller one, you are **narrowing (manual) casting**. You must manually tell Java to do this type of casting. Going from a `double` to an `integer` causes the decimal part of the `double` to be truncated. Java requires this to be done manually so you don’t accidentally lose value in data type casting. You have to specifically say, yes I know I will lose some data and I am okay with that. You do this by including the new data type in parenthesis.

- `int myValue = (int) 3.14;`

When you go from some data type to a string, this is called **String conversion**. Normally this happens automatically. For example, you try to print an integer, it is converted to a String and then displayed.

- `System.out.println(3)`

##### Follow Along

### Data Manipulations

So what do we mean by all of the above? Let’s run through some example code that uses and manipulates different data types.

Let’s create a folder where we can store our code. I am using `jxwork` as my work directory. For this example, I am going to call the application `basetypes`. I need to create the following directory structure:

    <home dir><work dir>/basetypes/src/basetypes

Remember that the first `basetypes` in the name of our application. JDK requires the `src` directory. Our package will be called `basetypes`.

Now, in the the `basetypes` directory, use your text editor to create the following code in a file called `Main.java`:

- As you enter the code, pay attention to the lines marked with //. These are comments that are ignored by the compiler but explain what each line does. You have a choice on entering the comments but DO READ THEM! I have explained the code using the comment sections.
- Note that `System.out.println()` displays to the console whatever is inside the parenthesis—more on this later.

<!-- -->

    package basetypes;

    public class Main
    {
        public static void main(String args[])
        {
            // create some numbers to work with
            int a = 2;
            int b = 1;
            double ba = 11.5;

            // manipulate those numbers and output results
            // arithmetic includes +, -, *, /
            // the result of arithmetic on a double and an integer results in a double
            double result = ba / a;
            System.out.println(result); // displays 5.75

            // the results of arithmetic on an integer and an integer results in an integer
            System.out.println(b + a); // displays 3

            // integer (/) integer results in an integer - the whole number part of the answer, truncating the decimal part
            System.out.println(b / a); // displays 0

            // The %, modular, mod operation - returns the remainder of doing division
            // normally the % is just used on positive integers
            System.out.println(b % a); // displays 1

            // Strings
            String sa = "Lambda";
            String sb = "School";

            // yes you can add Strings!
            String ans = sa + sb;
            System.out.println(ans); // displays LambdaSchool

            // Java also handles compound and increment operators
            a += b; // same as a = a + b
            System.out.println(a); // displays 3

            b++; // same as b = b + 1
            System.out.println(b); // displays 2
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac basetypes/*.java
    jar cvfe basetypes.jar basetypes.Main basetypes/*.class
    java -jar basetypes.jar

Fix any errors you encounter. The output you should get is:

    5.75
    3
    0
    1
    LambdaSchool
    3
    2

### Scope

Let’s experiment with **scope**. Create another package (folder) where we can store our code. I am going to call this new package `scopes`

    <home dir><work dir>/basetypes/src/scopes

Now in the the `scopes` directory, use your text editor to create the following code in a file called `Main.java` and as before, I am going to use comments to explain what is going on:

    package scopes;

    public class Main
    {
        // a field so will have scope throughout the class
        static int car = 5;

        public static void main(String[] args)
        {
            // a local variable. It will have scope from the method's opening { to the method's closing }
            int count = 0;

            // we are starting a new block within the method
            // the curly brackets {..} signify a block
            {
            // coffee is a local variable defined only inside this block
                int coffee = 5;
                // we create a variable called car - this is local to this block and successfully hides the field car
                // any work done in this block is done on the local car - the field car is never used
                int car = 15;
                System.out.println(car); // displays 15
                // count is still in scope so let's increment by 1
                System.out.println(count++); // diplays 0 and then increment counts by 1
                System.out.println(++count); // increments count by 1 and then displays it. displays 2
            }

            // note that since the block ended, the integer coffee is no longer defined. So, such as
            // System.out.println(coffee);
            // here would not compile

            // count has remained in scope and visible throughout so it did get incremented
            System.out.println(count); // displays 2

            // we are starting a new block
            {
                // we are creating a variable called coffee. This is completely unrelated to the coffee defined earlier.
                int coffee = 10;
                System.out.println(coffee); // displays 10
            }

            System.out.println(car); // displays 5
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac scopes/*.java
    jar cvfe scopes.jar scopes.Main scopes/*.class
    java -jar scopes.jar

Fix any errors you encounter. The output you should get is:

    15
    0
    2
    2
    10
    5

### Random Number Generator

Let’s experiment with random numbers. Create another package, folder, where we can store our code. I am going to call this new package `randoms`

    <home dir><work dir>/basetypes/src/randoms

In the `randoms` directory, use your text editor to create the following code in a file called `Main.java` and as before, I am going to use comments to explain what is going on.

    package randoms;

    import java.util.Random;

    public class Main
    {
        public static void main(String args[])
        {
            // create an object called rand which is of class type Random()
            // this object could be named anything but rand is commonly used
            // this object contains a variety of methods to generate random
            // numbers of all types
            Random rand = new Random();

            // display the values for minimum and maximum integer
            // each primitive data type has an associated class type
            // that contains various constants and methods.
            // Use the constants in the Integer class type to find
            // the min and max numbers!
            System.out.println("min int " + Integer.MIN_VALUE);
            System.out.println("max int " + Integer.MAX_VALUE);

            // generate a random integer from min int through max int
            int iresult = rand.nextInt();
            System.out.println(iresult);

            // Pick a number from 0, 1, 2, 3, 4
            // the 5 as the parameter below says to pick from the 5 numbers, starting with 0
            // here we are reusing the variable iresult. It has already been
            // declared so we can just use it.
            iresult = rand.nextInt(5);
            System.out.println(iresult);

            // Now let's pick a number from 5 to 10 by
            // picking from the 6 numbers starting with 0
            // 0, 1, 2, 3, 4, 5
            // now add 5 to that number. So possible choices are
            // 5, 6, 7, 9, 9, 10
            iresult = rand.nextInt(6) + 5;
            System.out.println(iresult);

            // pick a random double between 0.0 and 1.0
            // now we are working with a different data type, double,
            // so we need a new result variable.
            double dresult = rand.nextDouble();
            System.out.println(dresult);
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac randoms/*.java
    jar cvfe randoms.jar randoms.Main randoms/*.class
    java -jar randoms.jar

Fix any errors you encounter. The output you should get will resemble this but not match it. Remember the output is randomized:

    min int -2147483648
    max int 2147483647
    -450840738
    1
    8
    0.6999055626167598

### Typecasting

Let’s create another package, folder, where we can store our code. I am going to call this new package `castings`

    <home dir><work dir>/basetypes/src/castings

Now in the the `castings` directory, use your text editor to create the following code in a file called `Main.java` and as before I am going to use comments to explain what is going:

    package castings;

    public class Main
    {
        public static void main(String args[])
        {
            int myInt = 9;
            // Widening casting happens automatically.
            // An integer is automatically casted, converted, to a double
            double myDouble = myInt;

            // String conversion happens automatically allowing us
            // to print values of integers, doubles, among others
            System.out.println("myInt = " + myInt);
            System.out.println("myDouble = " + myDouble);

            // this just displays a blank line
            System.out.println();

            double my2double = 9.78;
            // Narrowing casting must be done manually
            // notice the addition of (int) in this expression
            // that says to manually convert the double after it
            // to an int.
            int my2int = (int) my2double;

            System.out.println("my2double = " + my2double);
            System.out.println("my2int = " + my2int);
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac castings/*.java
    jar cvfe castings.jar castings.Main castings/*.class
    java -jar castings.jar

Fix any errors you encounter. The output you should get is:

    myInt = 9
    myDouble = 9.0

    my2double = 9.78
    my2int = 9

##### Dig Deeper

- [Modulus Operator](http://www.cs.ukzn.ac.za/~hughm/java/intro/week2/21.html)  
  The Remainder or Modulus Operator in Java
- [Random Class](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html)  
  Oracle's Documentation on the Random Class
- [Typecasting](https://www.edureka.co/blog/type-casting-in-java/)  
  What is Typecasting in Java and how does it work

---

#### Learn to craft multiple Java Classes which include comments, constructors, static and instance variables (fields), accessors, public and private methods and instantiate and use Objects of these classes.

<span id="Constructs_in_Java"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

Java is an Object Oriented Language. That means we are doing Object Oriented Programming. So we will be living in the world of classes, objects, fields, and methods.

- **Classes** are blueprints, prototypes from which objects are created. Some like to think of classes as factories that can produce objects.
  - To be used in a program, an object of the class must be created. Exceptions to this rule exits in forms of _Static Methods_ and _Static Fields_. These can be used directly from a class. All objects that derive from a class share the same static methods and static fields.
- **Objects** are derived from classes. Objects are the entities were most of the work is done. They represent real world entities and contain
  - **Fields**, pieces of data that the object knows. Taken all together, the values of the fields at any given time is the _state_ of the object
  - **Methods** are the actions that the object can perform. They are the behaviors of the object. They get invoked, causing the object to do the action outlined by the method
  - **Pointers** the name of the object or the identity of the object. Pointers are memory locations where the object can be found
  - Objects are created using a _constructor_. This is a special method inside a class that allows one to create or instantiate an object. Often multiple constructors exist for a single class. Each constructor sets up the object’s initial state differently. The initial state of an object is the object’s state right after instantiation.

Let’s take a look at the following Java Code. Soon we will enter and execute this code but, first, let’s dissect it!

    package dogs;

    public class Dog
    {
        // class field
        public static String bark = "Woof";

        // fields
        private String breed;
        private int age;
        private String color;

        // default constructor
        public Dog()
        {
        }

        // constructor with a limited initial state
        public Dog(String color)
        {
            this.breed = "mutt";
            this.age = 1;
            this.color = color;
        }

        // constructor with initial state
        public Dog(String breed, int age, String color)
        {
            this.breed = breed;
            this.age = age;
            this.color = color;
        }

        // Reads State. Accessors (getters)
        public String getBreed()
        {
            return breed;
        }

        public int getAge()
        {
            return age;
        }

        public String getColor()
        {
            return color;
        }

        // Change State. Mutators (setters)
        public void setBreed (String breed)
        {
            this.breed = breed;
        }

        public void setAge (int age)
        {
            this.age = age;
        }

        public void setColor (String color)
        {
            this.color = color;
        }

        // Other methods
        public void sleep (int minutes)
        {
            System.out.println("ZZZ " + minutes);
        }
    } // ends the class

    package dogs;

    public class Main
    {
        public static void main(String[] args)
        {
            System.out.println(Dog.bark); // displays Woof

            Dog dottie;
            dottie = new Dog ("Springer", 10, "Black and White");
            Dog ginger = new Dog ("Troller", 6, "Ginger");
            dottie.bark = "Bark";
            System.out.println(dottie.bark); // displays Bark


            System.out.println(dottie); // displays [email protected]
            System.out.println(dottie.getAge()); // displays 10

            ginger.setBreed("mutt");
            System.out.println(ginger.getBreed()); // displays mutt

            Dog limited = new Dog("Black");
            System.out.println(limited.getAge()); // displays 1

            Dog aDog = new Dog();
            System.out.println(aDog.getBreed()); // displays null
            aDog.setBreed("Beagles");
            System.out.println(aDog.getBreed()); // displays Beagles
        }
    }

### Overview of the code

Let’s look at `Dog` first. This is a class and must be saved in a file `Dog.java`. The class name and the name of the file MUST match, case and all!

    package dogs;

Note that

- All Java statements end with a semi colon `;` . The `;` is NOT optional!
- The first line of a file is usually the package where the class belongs.
  - A package is a grouping of similar classes.
  - Files in Java are joined together by being in the same package, having the files start with the same package statement.

To use Java classes from other packages, those packages have to be imported (using`import`) into the current package. More on that later. For now, we only have 1 package. Soon we will be adding more. The name of the package can be anything but it must match the folder name where it is located.

    public class Dog
    {
        ...
    }

This sets up the class name to be `Dog`. The name of the class and the name of the file must match. The file name must have a `.java` extension. Hence this class is saved in the `Dog.java` file. Typically we put one class per file.

This class is marked as public. That means that any other classes in the application can access this class. Dog is known to all. You have four choices when it comes to these **access modifiers**. These access modifiers can go on classes, fields, or methods.

- **Public** - Anyone can access. You might have to use the package.class.object dot notation to access it, but you can still access it.
- **Private** - Can only be accessed within the class and objects instantiated from the class.
- **Protected** - Accessible within the same package and with the class and subclasses in other packages.
- **Default** - Accessible only with in the same package. For this you just leave the access modifier blank.

After the class **header** `public class Dog` is the class **body**. This is what is enclosed in the curly brackets `{ }`.

        // class field

This a comment in Java. This is a notation made by the developer to aid in reading the code. In Java, you have a few options for entering comments:

- `//` says that the rest of the text on this line is a comment. This is good to make single line comments or to put comments at the end of a line. The compiler will ignore anything after the `//` so make sure that all of your executable code, including the ending `;` is before the `//`! Often called line style.
- `/*..*/` Placing at `/*` at the beginning of a body of text and `*/` at the end of the body of text says that what is in the middle is a comment and is to be ignored by the compiler. Often called block style.
- `/**..*/` This is a special case of the block style called **Javadocs**. This syntax allows some useful HTML to be generated from our comments. You will see this syntax in most of the Guided Project and Module Project examples. We do not, however, cover Javadocs directly in class.

<!-- -->

        public static String bark = "Woof";

This is a class variable. You can tell that by the use of the keyword `static`. It is publicly accessible, is of type `String` and is named `bark`. Its initial value is “Woof”. Since this is a class variable, it is shared by all the objects. When an object accesses this variable it is accessing the same memory location all other objects are accessing. If an object changes the value of this field, it is changed for all objects derived from this class. Note that often we access class variable publicly.

        private String breed;
        private int age;
        private String color;

These three are fields. They are private to the object. Each object derived from this class gets its own set of these variables. Taken together, the value of these variables form the state of the object. Note that these are private meaning that only the object has access to them. This is common for fields. Fields are normally accessed through Getters and modified through Setters. In this way, the object has complete over how the outside world gets to see or change its value.

Some common tasks of Getters and Setters are

- Restricting access to only those objects who are allowed to have access. Remember with public anyone can access them.
- Checking or Modifying the data prior to releasing or changing. Some data validation might be done here. Perhaps all string values should be capitalized. Perhaps negative numbers are not allowed.
- Preventing access completely. Perhaps the value is only needed within the object and the outside world should not read or modify the field.

Fields should always be written in all lowercase. No camel case! This naming convention becomes very important as the course progresses.

        // default constructor
        public Dog()
        {
        }

Now we start a series of three constructors, three different ways to send the initial state to the class to create the object. Notice each one has the same name but has different parameters. The headers for the constructor methods all start with `public Dog`.

- Constructors are always public
- Unlike other methods, constructors have no type. They are always of type `void` meaning that they cannot return a value.
- They are named the same name as the class
- They differ by the parameter list. You can have as many different constructors as you can construct combinations of parameters.

Now this one is called the default constructor. If no constructor is specified, the JDK will automatically create this default constructor. This constructor creates an object using no parameters. In this case, all of our fields are created with uninitialized values.

        // constructor with a limited initial state
        public Dog(String color)
        {
            this.breed = "mutt";
            this.age = 1;
            this.color = color;
        }

Now we have a constructor that takes one parameter, a String. This string is used to initialize the value of the field `color`. Notice that the parameter is named `color` and the field name is `color`. This is a common construct. To indicate which `color` we mean, we use the word `this` in front of the field. The keyword `this` refers to the current object. Thus `this.color` is saying “from the current object, use the field color”. We also initialize the other two fields with constants. Again we use the keyword this to indicate we mean the object’s fields. Since there is no confusion as to which `breed` we mean (there is only one in scope), the keyword `this` is not needed. It is not wrong to use it and it is used frequently in constructors even when not needed.

Note that due to scope, the parameter color disappears (is unallocated) at the end of the constructor. Thus we must save its value somewhere first, normally inside a field:

        // constructor with initial state
        public Dog(String breed, int age, String color)
        {
            this.breed = breed;
            this.age = age;
            this.color = color;
        }

This constructor takes three parameters used to set the object’s initial state. In this case, we must use the `this` keyword to refer to the object’s fields.

        // Reads State. Accessors (getters)
        public String getBreed()
        {
            return breed;
        }

        public int getAge()
        {
            return age;
        }

        public String getColor()
        {
            return color;
        }

Now we have a series of Getters or methods that allow us to read the value of a field. Again, these methods can be used to restrict access, modify the field before releasing it to the world, or some other business rule. Of course, these are public so that the rest of the application can get the information. So the Getter for breed:

- `public String` (the same type as the field) `getBreed()` (the word get followed by the field name starting with a capital letter; the naming convention of these become very important as the course progresses.)
- Inside the body of the Getter method, we would do whatever work needs to be done, ultimately returning a value the same type as the field. `return breed;` (Quite often a Getter simply returns the field value itself)

<!-- -->

        // Change State. Mutators (setters)
        public void setBreed (String breed)
        {
            this.breed = breed;
        }

        public void setAge (int age)
        {
            this.age = age;
        }

        public void setColor (String color)
        {
            this.color = color;
        }

And here we have our series of Setters or methods that allow us to modify the value of a field. Again, these methods are used to provide data validation and various business rules before changing the value of a field. Of course, these are public so that rest of the application can modify the field. Remember when a field is modified, the state of the object changes. So the Setter for breed:

- `public void` (public method that does not return a value, hence the return type is void)
- `setBreed` (the word set followed by the field name starting with a capital letter)
- `(String breed)` (the parameter list. Normally the same type as the field and by convention we call the parameter the same name as the field. This will be used to create the new value for the field)

Inside the body of the Setter method, we would do whatever work needs to be done to validate and update the incoming value ultimately storing that value in the field itself. `this.breed = breed;`

Often you will see Getters and Setters mixed together in this order:

- Getter for breed
- Setter for breed
- Getter for age
- Setter for age
- Getter for color
- Setter for color

<!-- -->

        // Other methods
        public void sleep (int minutes)
        {
            System.out.println("ZZZ " + minutes);
        }

Our classes can have methods other than Getters and Setters. It just depends on what we want to accomplish.

And we now have our Dog class. To start, Java programs need a starting point. Let’s take a look at the starting point for this application.

    package dogs;

    public class Main
    { ... }

Again we are in the same package as the `Dog` class, `dogs`. We have a class name `Main` saved in a file named `Main.java`. Commonly we call the class starting point for a Java `Main` although as we will see as the class progresses, this is not the norm when using the Spring Framework.

        public static void main(String[] args)

The method of the starting point MUST use the above code! This construct is required by the JDK and this is the method the JDK looks for to start the Java program.

We have a series of statements in the body of this method. Let’s look at these statements.

            System.out.println(Dog.bark); // displays Woof

To print something to the console, you use the `System.out.println()`;

- `System` is the class where the needed method is found
- `out` is a static field of type PrintStream class
- `println()` is a method in the PrintStream class. `print` says to display to the console, `ln` says to add a return after printing. That way the next thing that prints will start on a new line.

`Dog.bark` where bark is a class field so can be used without instantiating an object. We call it directly from the class:

            Dog dottie;

This declares a variable named `dottie` of type `Dog` class. It does not create the object, it just declares that the variable dottie will point to an object in memory of type Dog.

            dottie = new Dog ("Springer", 10, "Black and White");

`new` says to instantiate an object of type `Dog` by calling the constructor with three parameters of type String, integer, String. One line declares the variable, the next line instantiated the object. Quite often we do this all on one line as shown below.

            Dog ginger = new Dog ("Troller", 6, "Ginger");

            dottie.bark = "Bark";
            System.out.println(dottie.bark); // displays Bark

Since `dottie` is of type `Dog`, it has access to the class field `bark`. It can change the class field and display the value of the class field.

            System.out.println(dottie); // displays [email protected]

This says to print the value of the variable `dottie` which is of class type `Dog`. When you print such a variable, a method called `toString()` is invoked, called. This method is inherited by `Dog` from the parent class `Object`. All classes inherit from the parent class `Object`. By default, `toString()` prints the memory location where the object `dottie` is stored. We will show later how to override the `toString()` method and print something more useful than just a memory location.

            System.out.println(dottie.getAge()); // displays 10

Now we call the Getter for `age` to display the age field from the object body.

- `dottie` is the variable name of the object
- `.` says to use the field or method from the object
- `getAge()` is the method from the object we want to use. We know it is a method because of the inclusion of parenthesis. These parentheses are required for all methods, whether or not the method has parameters. It is the `()` that distinguished methods from fields.
- This is called dot notation.

<!-- -->

            ginger.setBreed("mutt");
            System.out.println(ginger.getBreed()); // displays mutt

Here we are using the setter for the field breed to change the breed of ginger to “mutt”. We then use the getter for breed to display its value to the console.

            Dog limited = new Dog("Black");
            System.out.println(limited.getAge()); // displays 1

Here we create a new Dog object called `limited`. We use the constructor that takes a single String parameter. The rest of the fields default to values inside the constructor. We see that default behavior when we use the method `getAge()` and display the age of `limited` which has been set to `1`.

            Dog aDog = new Dog();
            System.out.println(aDog.getBreed()); // displays null
            aDog.setBreed("Beagles");
            System.out.println(aDog.getBreed()); // displays Beagles

Here we use the default constructor to create an object of type Dog with an uninitialized initial state. So when we try to display the breed of this object, we get an answer of `null`. Breed has not yet been set to a value. We then set breed to a value and display it to show that all is still working as it should.

##### Follow Along

Let’s create some classes and initiate some objects. We need a directory to store our code, so let’s create `<work dir>/dogs/src/dogs`. Now under that directory create the following. The code is explained after the code blocks.

In a file called `Dog.java` enter:

    package dogs;

    public class Dog
    {
        // class field
        public static String bark = "Woof";

        // fields
        private String breed;
        private int age;
        private String color;

        // default constructor
        public Dog()
        {
        }

        // constructor with a limited initial state
        public Dog(String color)
        {
            this.breed = "mutt";
            this.age = 1;
            this.color = color;
        }

        // constructor with initial state
        public Dog(String breed, int age, String color)
        {
            this.breed = breed;
            this.age = age;
            this.color = color;
        }

        // Reads State. Accessors (getters)
        public String getBreed()
        {
            return breed;
        }

        public int getAge()
        {
            return age;
        }

        public String getColor()
        {
            return color;
        }

        // Change State. Mutators (setters)
        public void setBreed (String breed)
        {
            this.breed = breed;
        }

        public void setAge (int age)
        {
            this.age = age;
        }

        public void setColor (String color)
        {
            this.color = color;
        }

        // Other methods
        public void sleep (int minutes)
        {
            System.out.println("ZZZ " + minutes);
        }
    } // ends the class

In a file called `Main.java` enter:

    package dogs;

    public class Main
    {
        public static void main(String[] args)
        {
            System.out.println(Dog.bark); // displays Woof

            Dog dottie;
            dottie = new Dog ("Springer", 10, "Black and White");
            Dog ginger = new Dog ("Troller", 6, "Ginger");
            dottie.bark = "Bark";
            System.out.println(dottie.bark); // displays Bark


            System.out.println(dottie); // displays [email protected]
            System.out.println(dottie.getAge()); // displays 10

            ginger.setBreed("mutt");
            System.out.println(ginger.getBreed()); // displays mutt

            Dog limited = new Dog("Black");
            System.out.println(limited.getAge()); // displays 1

            Dog aDog = new Dog();
            System.out.println(aDog.getBreed()); // displays null
            aDog.setBreed("Beagles");
            System.out.println(aDog.getBreed()); // displays Beagles
        }
    }

Now let’s execute the code and see what happens. From the `<work dir>/dogs/src` directory, enter the following commands:

    javac dogs/*.java
    jar cvfe dogs.jar dogs.Main dogs/*.class
    java -jar dogs.jar

You should get out similar to:

    Woof
    Bark
    [email protected]
    10
    mutt
    1
    null
    Beagles

If you don’t get that output, go back and review your code. Fix any problems and keep trying it until it works!

And that is a complete Java application!

##### Dig Deeper

- [Code Review](https://dev.to/smartyansh/code-review-checklist-for-java-beginners-181f)  
  Code Review Checklist for Java Beginners
- [Streams](https://stackify.com/streams-guide-java-8/)  
  A Guide to Streams in Java 8: In-Depth Tutorial with Examples
- [Javadocs](https://www.oracle.com/technetwork/java/javase/documentation/index-137868.html)  
  How to Write Doc Comments for the Javadoc Tool

---

#### Learn to implement and use the String and Date data types

<span id="Dates_and_Strings_in_Java"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

Besides primitive data types, Java makes extensive use of Class data types. Two popular class data types are Strings and Dates. Let’s look at each one individually. Do note that these are classes so the data type begins with a capital letter.

### Strings Overview

String is a class that implements a series of char primitive types that put together form a string. Most string functions return a value and do not affect the original string. Several methods exit to help us with Strings (there are many more than listed here):

- `charAt(int)` returns the character for the particular 0 based index
- `substring(beginning, ending)` returns the characters found starting from the index beginning inclusive to the index ending exclusive
  - Character at beginning index is included
  - Character at ending index is excluded
- `length()` returns how many characters are in the string
- String `+` String concatenates two strings together
- `toLowerCase()`, `toUpperCase()` returns the string all in lowercase, uppercase

Methods also exist that allow us to format doubles to something more readable. There are many different ways to format doubles. One popular method is to use the import java.text.DecimalFormat as soon in the following code snippet:

    // import is needed for converting doubles into something readable
    import java.text.DecimalFormat;

    public class Main
    {
        // create a private class variable to control the display format for doubles
        // $#,##0.00 means
        // > display at least one number before the decimal and only two numbers, but always two numbers, after the decimal
        // > when displayed the number is rounded to two decimal points. The underlaying number is not changed
        // > display a comma after each group of 3 numbers
        // > display a dollar sign at the beginning of each number
        private static DecimalFormat df = new DecimalFormat("$#,##0.00");

        public static void main(String arg[])
        {
            myDouble = .3;
            strResult = df.format(myDouble);
            System.out.println(strResult); // displays $0.30
        }
    }

### Dates Overview

Dates are another popular class type that has many helpful methods. Dates are so popular that many different libraries exist to help with dates. Each library approaches issues using dates a little differently. For now, we will be using a standard (core) date library. In that library we will look at how to initialize a date, display a date, get the current time, and perform date arithmetic.

Other good libraries to investigate are:

- [Oracle’s Date Time Library](https://docs.oracle.com/javase/tutorial/datetime/index.html)
- [Apache’s DateUtils](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/time/DateUtils.html)
- [Joda’s Time Libraries](https://www.joda.org/joda-time/)

We will need to set up formats to help us convert from Strings to Dates and back. We will be setting up class variables to control our date format. This allows us to use a consistent date time format throughout the application. A format of the following means:

    "MMM dd yyyy hh:mm:ss a z Z"

- `MMM` is the 3 character month abbreviation
- `dd` is the two digit day
- `yyyy` is the four digit year
- `hh` is the hour
- `mm` is the minutes
- `ss` is the seconds
- `a` says to print in AM / PM 12 hour format
- `z` says to print the local time zone in 3 character abbreviation
- `Z` says to print the hours the local time zone differs from Greenwich Mean Time (GMT). Z for being at the Zero Meridian, also called Zulu time.
- any combination can be used to format the date and time you want

How a general data format gets set up in Java is:

        private static SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd yyyy hh:mm:ss a z Z");

And, yes, when we say date, we usually mean date and time.

### Wild card imports

The `java.util` library is used extensively in Java to work with a variety of different data types including Dates. The `*` says to include all classes, methods, fields associated with the `java.util` library. So we have coding like

    import java.util.*;

You will see the above approach often. We now have access to everything in `java.util` without the need to individually list each class, method, and field we want to use. The downside is we include many items from `java.util` that we do not use, unnecessarily adding to the size of our project.

Thus we have a trade-off between easy to use versus size of deliverable. The general consensus is that if you are going to use 5 or more items from a library, use the `*` construct. Although different companies will vary on their approach so look to your company’s style guide for what to.

##### Follow Along

Let’s take a look at each of these points in action. Let’s create an application and package where we can store our code. I am going to call this new application `stringworks` and the new package `workingstrings`:

    <home dir><work dir>/stringworks/src/workingstrings

Now in the the `workingstrings` directory, use your text editor to create the following code in a file called `Main.java`. I am going to use comments to explain what is going. Entering the comments is optional, reading them is not:

    package workingstrings;

    // import is needed for converting doubles into something readable
    import java.text.DecimalFormat;

    public class Main
    {
        private static DecimalFormat df = new DecimalFormat("$#,##0.00");

        public static void main(String arg[])
        {
            // Let's setup a string for work with
            // Our index then is
            //                        111
            //              0123456789012
            String myStr = "Lambda School";

            // return the first character in the string myStr
            myStr.charAt(0);

            // notice that myStr has not changed!
            System.out.println(myStr); // displays Lambda School

            // now display the first character in the string myStr
            System.out.println(myStr.charAt(0)); // displays L
            // display the 5 character in myStr
            System.out.println(myStr.charAt(5)); // displays a
            // display the 100 character in myStr
            // System.out.println(myStr.charAt(100)); // we get a run time error saying index is out of bounds!

            // find the substring in myStr beginning at index 5 and ending at index 8
            String strResult = myStr.substring(5, 8);
            System.out.println(strResult); // displays a S

            // display the length of myStr
            System.out.println(myStr.length()); // displays 13

            // add your instructor's name to myStr
            strResult = myStr + "John";
            System.out.println(strResult); // displays Lambda SchoolJohn

            // return myStr in lowercase
            strResult = myStr.toLowerCase();
            System.out.println(strResult); // displays lambda school

            // return myStr in uppercase
            strResult = myStr.toUpperCase();
            System.out.println(strResult); // displays LAMBDA SCHOOL

            // When displaying, convert the given double to the format specified earlier when df was created.
            // the use of DecimalFormat in this way always us to display doubles the same way each time!
            double myDouble = 123134556.7890;
            strResult = df.format(myDouble);
            System.out.println(strResult); // displays $123,134,556.79

            myDouble = .3;
            strResult = df.format(myDouble);
            System.out.println(strResult); // displays $0.30
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac workingstrings/*.java
    jar cvfe workingstrings.jar workingstrings.Main workingstrings/*.class
    java -jar workingstrings.jar

Fix any errors you encounter. The output you should get is:

    Lambda School
    L
    a
    a S
    13
    Lambda SchoolJohn
    lambda school
    LAMBDA SCHOOL
    $123,134,556.79
    $0.30

### Dates

Let’s create an application and package where we can store our code. I am going to call this new application `dateworks` and the new package `workingdates`

    <home dir><work dir>/dateworks/src/workingdates

Now in the the `workingdates` directory, use your text editor to create the following code in a file called `Main.java`. I am going to use comments to explain what is going on:

    package workingdates;

    // we need to import two libraries
    // java.util.* - to work with dates
    // java.text.* - to format date output
    import java.util.*;
    import java.text.*;

    public class Main
    {
        // We create a format to use when displaying dates
        private static SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd yyyy hh:mm:ss a z Z");
        // We create a simplier format to use when creating dates from strings.
        private static SimpleDateFormat date2Format = new SimpleDateFormat("MMM dd yyyy hh:mm:ss");

        // We have added throws Exception to our normal method header
        // We are telling Java that a method inside our main method, in this case the parse method,
        // can "throw" an exception, can disrupt the normal flow of our code.
        // We are telling Java we know that can happen and that is okay with us!
        // The program does not compile without this addition
        // We often have to tell Java that we know something might happen and we are okay with it!
        public static void main(String args[]) throws Exception
        {
            // let's create a an object of type Date.
            // The default constructor for Date initializes the object to the current date and time.
            Date myDate = new Date();
            System.out.println(dateFormat.format(myDate));

            // let's set a date to a certain date. Notice we use the parse method to say how to parse, convert, a given string into a date.
            // If the parsing of the string fails, Java "throws" an exception. We tell Java we know this in the method's header.
            Date thisDate = date2Format.parse("MAR 14 3141 03:14:15");
            System.out.println(dateFormat.format(thisDate));

            // Now let's add to the date.
            // First create a Calendar object. The constructors for Calendar are protected in the library so we cannot use them directly.
            // Instead we invoke the method getInstance to create a Calendar.
            Calendar c = Calendar.getInstance();
            // set the date of that calendar object to the date we are starting with
            c.setTime(thisDate);
            // now add 1 day to the calendar object
            c.add(Calendar.DATE, 1);
            // now convert that calendar object back to a date object
            thisDate = c.getTime();
            System.out.println(dateFormat.format(thisDate));
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac workingdates/*.java
    jar cvfe workingdates.jar workingdates.Main workingdates/*.class
    java -jar workingdates.jar

Fix any errors you encounter. The output you should be similar to although your current date and time will vary:

    Mar 31 2020 02:24:18 PM PDT -0700
    Mar 14 3141 03:14:15 AM PDT -0700
    Mar 15 3141 03:14:15 AM PDT -0700

##### Dig Deeper

- [Strings](https://www.javatpoint.com/java-string)  
  Java Strings
- [2 Decimal Display](https://mkyong.com/java/java-display-double-in-2-decimal-points/)  
  Display Doubles with 2 decimals
- [Currency Format](https://kodejava.org/how-do-i-format-a-number-as-currency-string/)  
  How do I format a number as currency string?
- [Format Specifiers](https://www.geeksforgeeks.org/format-specifiers-in-java/)  
  GeeksForGeeks - Format Specifiers in Java
- [java.time](https://docs.oracle.com/javase/tutorial/datetime/index.html)  
  Oracle's documentation for java.time
- [java-util-date](https://examples.javacodegeeks.com/java-util-date/)  
  Java Code Geeks - java-util-date

---

#### Learn to understand the reason behind and use of BigDecimals (\*\*\* OPTIONAL \*\*\*)

<span id="Big_Decimals_in_Java"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

#### The Problem

Java does all of its arithmetic using base 2. Most programming languages do this, that is, represent numbers using a series of 0 and 1. Base 10 arithmetic, what we normally use, does not always fit neatly into base 2 representation. Not only do we have the issue of performing arithmetic in base 2, we have the issue of trying to force an infinite number into a finite space. 1/3 is 0.333333 with no end. We cannot accurately represent this number in a computer’s finite memory. The following are results of Java arithmetic:

    3.36 * 3 = 10.08
    3.36 / 3 = 1.1199999999999999
    3.36 + 3 = 6.359999999999999
    3.36 - 3 = 0.3599999999999999

UGH! What is Java doing to us? Well, Java is calculating the output the best it can in base 2 and leaving it up to the programmer to fix any issues. We have a couple of different ways to handle the issues: rounding or using a different data type BigDecimals. Which one you pick is a personal preference although most programmers lean towards using BigDecimals.

#### Round Solution

One option we have to fix the problem is to round our number every time we do arithmetic. This gets us the results we want but can make the code unreadable with all the rounding going on. Let’s see how this works in practice.

We are going to use the static method `Math.round()`. By default Math.round() rounds the number to the nearest unit, the ones place. To round to the nearest hundredth’s place, two decimal points, we use this Java code.

    double answerRound = Math.round(3.1415 * 100.0) / 100.0;

- multiple the number by 100.0 so for example 3.1415 becomes 314.15
- then round to the new ones place so 314.15 becomes 314
- then divide by 100.0 to put the decimals back in the number so 314 becomes 3.14
- an advantage is that binary, decimal arithmetic works out correctly for multiples of 10. Nice side effect!
- Note that if we had wanted to round to the thousandth’s place, three decimal points, we would have used 1000.0 instead of 100.0

#### BigDecimal Solution

Because there is this known problem with doing double on double arithmetic, Java has a unique solution to the problem. Basically Java allows you to perform double on double arithmetic with all of its issues or use a different data type, a BigDecimal. BigDecimal is a class found in the java.math library. BigDecimal implements its own methods for the basic arithmetic operations, allowing for operations to be perform in base 10 giving us the answers we expect. Using BigDecimal takes a little more planning as you cannot use the standard arithmetic functions (+, -, \*, /). In the end though, BigDecimal allows you to work accurate with large real numbers. The advantages of using BigDecimal outweighs its disadvantages.

BigDecimal does require an import so add the import statement to your code in the `workingdecimal.Main` class between the line of the package statement and the line for the class header:

    package workingdecimals;

    import java.math.BigDecimal;

    public class Main

To initialize a BigDecimal, we use the `valueOf()` method

    BigDecimal bigNumber = BigDecimal.valueOf(3.14);
    BigDecimal anotherBigNumber = BegDecimal.valueOf(2.71);

BigDecimal has its own arithmetic methods:

    BigDecimal bigAnswerMutl = bigARealNumber.multiply(anotherBigNumber);
    BigDecimal bigAnswerDiv = bigARealNumber.divide(anotherBigNumber);
    BigDecimal bigAnswerPlus = bigARealNumber.add(anotherBigNumber);
    BigDecimal bigAnswerSub = bigARealNumber.subtract(anotherBigNumber);

##### Follow Along

### The problem

Let’s run through some arithmetic using doubles and see the output. Let’s create an application and package where we can store our code. I am going to call this new application `decimalworks` and the new package `workingdecimals`:

    <home dir><work dir>/decimalworks/src/workingdecimals

Now in the `workingdecimals` directory, use your text editor to create the following code in a file called `Main.java`. I am going to use comments to explain what is going on:

    package workingdecimals;

    public class Main
    {
        // creating two doubles where we can do some arithmetic
        static double aWholeNumber = 3;
        static double aRealNumber = 3.36;

        public static void main(String[] args)
        {
            // run through the 4 basic arithmetic operations and display the results
            double answerMult = aRealNumber * aWholeNumber;
            double answerDiv = aRealNumber / aWholeNumber;
            double answerPlus = aRealNumber + aWholeNumber;
            double answerSub = aRealNumber - aWholeNumber;

            System.out.println("*** The Problem ***");
            System.out.println(aRealNumber + " * " + aWholeNumber + " = " + answerMult);
            System.out.println(aRealNumber + " / " + aWholeNumber + " = " + answerDiv);
            System.out.println(aRealNumber + " + " + aWholeNumber + " = " + answerPlus);
            System.out.println(aRealNumber + " - " + aWholeNumber + " = " + answerSub);
        }
    }

    javac workingdecimals/*.java
    jar cvfe workingdecimals.jar workingdecimals.Main workingdecimals/*.class
    java -jar workingdecimals.jar

To run our code, we go through the following steps, running these commands from the `src` directory.

Fix any errors you encounter and try again. The output you get should be similar to:

    *** The Problem ***
    3.36 * 3.0 = 10.08
    3.36 / 3.0 = 1.1199999999999999
    3.36 + 3.0 = 6.359999999999999
    3.36 - 3.0 = 0.3599999999999999

However, doing the arithmetic by hand, we should get this output:

    3.36 * 3.0 = 10.08
    3.36 / 3.0 = 1.12
    3.36 + 3.0 = 6.36
    3.36 - 3.0 = 0.36

### Rounding

This is how we fix the problem using rounding. Let’s just add the following code to the bottom of our main method in the `workingdecimal.Main` class:

            // now let's run through the arithmetic operations again but this time let's round our answers.
            System.out.println(); // this gives us a blank line
            System.out.println("*** Solution with Rounding ***"); // some headers to help read the output
            System.out.println("*** Must round each answer before using");

            double answerDivRound = Math.round(answerDiv * 100.0) / 100.0;
            double answerMultRound = Math.round(answerMult * 100.0) / 100.0;
            double answerPlusRound = Math.round(answerPlus * 100.0) / 100.0;
            double answerSubRound = Math.round(answerSub * 100.0) / 100.0;

            System.out.println(aRealNumber + " * " + aWholeNumber + " = Round to cents " + answerMultRound);
            System.out.println(aRealNumber + " / " + aWholeNumber + " = Round to cents " + answerDivRound);
            System.out.println(aRealNumber + " + " + aWholeNumber + " = Round to cents " + answerPlusRound);
            System.out.println(aRealNumber + " - " + aWholeNumber + " = Round to cents " + answerSubRound);

Now re-run the these steps from the `src` directory:

    javac workingdecimals/*.java
    jar cvfe workingdecimals.jar workingdecimals.Main workingdecimals/*.class
    java -jar workingdecimals.jar

Fix any errors you encounter and try again. Notice the answers under solution with rounding are correct:

    *** The Problem ***
    3.36 * 3.0 = 10.08
    3.36 / 3.0 = 1.1199999999999999
    3.36 + 3.0 = 6.359999999999999
    3.36 - 3.0 = 0.3599999999999999

    *** Solution with Rounding ***
    *** Must round each answer before using
    3.36 * 3.0 = Round to cents 10.08
    3.36 / 3.0 = Round to cents 1.12
    3.36 + 3.0 = Round to cents 6.36
    3.36 - 3.0 = Round to cents 0.36

### BigDecimal

This is how we fix the problem using BigDecimals. Let’s add the following code to the bottom of our main method in the `workingdecimal.Main` class:

            // now let's run through the arithmetic operations again but this time use BigDecimals
            System.out.println();
            System.out.println("*** Solution with Big Decimals ***");

            // convert to BigDigDecimals
            BigDecimal bigARealNumber = BigDecimal.valueOf(aRealNumber);
            BigDecimal bigAWholeNumber = BigDecimal.valueOf(aWholeNumber);

            // now we call the appropriate methods to perform operations on BigDecimals
            BigDecimal bigAnswerMutl = bigARealNumber.multiply(bigAWholeNumber);
            BigDecimal bigAnswerDiv = bigARealNumber.divide(bigAWholeNumber);
            BigDecimal bigAnswerPlus = bigARealNumber.add(bigAWholeNumber);
            BigDecimal bigAnswerSub = bigARealNumber.subtract(bigAWholeNumber);

            System.out.println(bigARealNumber + " * " + bigAWholeNumber + " = " + bigAnswerMutl);
            System.out.println(bigARealNumber + " / " + bigAWholeNumber + " = " + bigAnswerDiv);
            System.out.println(bigARealNumber + " + " + bigAWholeNumber + " = " + bigAnswerPlus);
            System.out.println(bigARealNumber + " - " + bigAWholeNumber + " = " + bigAnswerSub);
        }

Now re-run the these steps from the `src` directory:

    javac workingdecimals/*.java
    jar cvfe workingdecimals.jar workingdecimals.Main workingdecimals/*.class
    java -jar workingdecimals.jar

Fix any errors you encounter and try again. Notice the answers under the solution of using BigDecimal are correct and the code is easier to read:

    *** The Problem ***
    3.36 * 3.0 = 10.08
    3.36 / 3.0 = 1.1199999999999999
    3.36 + 3.0 = 6.359999999999999
    3.36 - 3.0 = 0.3599999999999999

    *** Solution with Rounding ***
    *** Must round each answer before using
    3.36 * 3.0 = Round to cents 10.08
    3.36 / 3.0 = Round to cents 1.12
    3.36 + 3.0 = Round to cents 6.36
    3.36 - 3.0 = Round to cents 0.36

    *** Solution with Big Decimals ***
    3.36 * 3.0 = 10.080
    3.36 / 3.0 = 1.12
    3.36 + 3.0 = 6.36
    3.36 - 3.0 = 0.36

If you wish to see a complete the `workingdecimal.Main` class, expand the following:

the workingdecimal.Main class

    package workingdecimals;

    import java.math.BigDecimal;

    public class Main
    {
        // creating two doubles where we can do some arithmetic
        static double aWholeNumber = 3;
        static double aRealNumber = 3.36;

        public static void main(String[] args)
        {
            // run through the 4 basic arithmetic operations and display the results
            double answerMult = aRealNumber * aWholeNumber;
            double answerDiv = aRealNumber / aWholeNumber;
            double answerPlus = aRealNumber + aWholeNumber;
            double answerSub = aRealNumber - aWholeNumber;

            System.out.println("*** The Problem ***");
            System.out.println(aRealNumber + " * " + aWholeNumber + " = " + answerMult);
            System.out.println(aRealNumber + " / " + aWholeNumber + " = " + answerDiv);
            System.out.println(aRealNumber + " + " + aWholeNumber + " = " + answerPlus);
            System.out.println(aRealNumber + " - " + aWholeNumber + " = " + answerSub);

            // now let's run through the arithmetic operations again but this time let's round our answers.
            System.out.println(); // this gives us a blank line
            System.out.println("*** Solution with Rounding ***"); // some headers to help read the output
            System.out.println("*** Must round each answer before using");

            double answerDivRound = Math.round(answerDiv * 100.0) / 100.0;
            double answerMultRound = Math.round(answerMult * 100.0) / 100.0;
            double answerPlusRound = Math.round(answerPlus * 100.0) / 100.0;
            double answerSubRound = Math.round(answerSub * 100.0) / 100.0;

            System.out.println(aRealNumber + " * " + aWholeNumber + " = Round to cents " + answerMultRound);
            System.out.println(aRealNumber + " / " + aWholeNumber + " = Round to cents " + answerDivRound);
            System.out.println(aRealNumber + " + " + aWholeNumber + " = Round to cents " + answerPlusRound);
            System.out.println(aRealNumber + " - " + aWholeNumber + " = Round to cents " + answerSubRound);

            // now let's run through the arithmetic operations again but this time use BigDecimals
            System.out.println();
            System.out.println("*** Solution with Big Decimals ***");

            // convert to BigDigDecimals
            BigDecimal bigARealNumber = BigDecimal.valueOf(aRealNumber);
            BigDecimal bigAWholeNumber = BigDecimal.valueOf(aWholeNumber);

            // now we call the appropriate methods to perform operations on BigDecimals
            BigDecimal bigAnswerMutl = bigARealNumber.multiply(bigAWholeNumber);
            BigDecimal bigAnswerDiv = bigARealNumber.divide(bigAWholeNumber);
            BigDecimal bigAnswerPlus = bigARealNumber.add(bigAWholeNumber);
            BigDecimal bigAnswerSub = bigARealNumber.subtract(bigAWholeNumber);

            System.out.println(bigARealNumber + " * " + bigAWholeNumber + " = " + bigAnswerMutl);
            System.out.println(bigARealNumber + " / " + bigAWholeNumber + " = " + bigAnswerDiv);
            System.out.println(bigARealNumber + " + " + bigAWholeNumber + " = " + bigAnswerPlus);
            System.out.println(bigARealNumber + " - " + bigAWholeNumber + " = " + bigAnswerSub);
        }
    }

##### Dig Deeper

- [Java Math](https://www.dummies.com/programming/java/weird-things-java-math/)  
  Weird Java Math Things

---

#### Learn to craft and use for loops (\*\*\* OPTIONAL \*\*\*)

<span id="FOR_Loops"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

### FOR LOOP

To demonstrate how execution flows in a Java program, I am using [The Java Visualizer](https://cscircles.cemc.uwaterloo.ca/java_visualize/#) which is based on a visualizer from the [Online Python Tutor](http://www.pythontutor.com/). Do take a look at the code for The Java Visualizer. Much of it is done in Java! For some demonstrations, I use a plugin for IntelliJ [Java Visualizer](https://plugins.jetbrains.com/plugin/11512-java-visualizer) which is based on The Java Visualizer

- [Frontend GitHub Repo](https://github.com/daveagp/java_visualize)
- [Backend GitHub Repo](https://github.com/daveagp/java_jail/tree/master/cp/traceprinter)

So what about **for loops**. Like most languages, For Loops are a part of Java. For Loops execute a “chunk” of code a set number of times. Remember that for loops have three components:

- **counter** - an index variable that has a data type and is initialized
- **range** - repeat over the range until the statement is false
- **step** - how much to change the index variable each time, each loop

This is how a loop is done in Java. The following code executes its body 10 times, count 0, 1, 2, 3, 4, 5, 6, 7, 8, 9!

![FOR Loop Explained](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-01.png)

##### Follow Along

### Basic FOR LOOP

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `forloops`. You will end up with the directory structure:

    <home dir><work dir>/samplecollectionswithloops/src/forloops

Now in the the `forloops` directory, use your text editor to create the following code in a file called `Main.java`:

    package forloops;

    public class Main
    {
        public static void main(String[] args)
        {
            System.out.println("*** normal loop - Count 0 to 9 ***");
            for (int i = 0; i < 10; i++)
            {
                System.out.println(i);
            }
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac forloops/*.java
    jar cvfe forloops.jar forloops.Main forloops/*.class
    java -jar forloops.jar

Fix any errors you might encounter and try again.

In the above example, we have a for loop where:

- counter = int i starting at 0
- range = as long as i is less than 10
- step = add 1 to i each time through the loop

So we get the following output:

    *** normal loop - Count 0 to 9 ***
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9

The following shows the execution or flow of this loop.

![FOR Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-02.gif)

### Changing index variable

In this section, we show the effects of changing your counter, or index variable, in the body of the loop. Although this works, it’s generally considered poor programming practice and if possible should be avoided.

Add the following to the end of your main method:

            System.out.println();
            System.out.println("*** change the index - Even Numbers Between 1 and 10 n***");
            for (int i = 1; i <= 10; i++)
            {
                i++;
                System.out.println(i);
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac forloops/*.java
    jar cvfe forloops.jar forloops.Main forloops/*.class
    java -jar forloops.jar

Fix any errors you might encounter and try again.

In the above example, we have a for loop where:

- counter = int i starting at 1
- range = as long as i is less than or equal to 10
- step = add 1 to i each time through the loop. However we add 1 to i in the body of the loop

So the above code produces the following output, minus output from previous sections

    *** change the index - even Numbers Between 1 and 10 n***
    2
    4
    6
    8
    10

The following shows the execution or flow of this loop.

![FOR Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-03.gif)

### Follow Along - A Different Step

In this section, we show the effects of having a step other than + 1.

Add the following to the end of your main method:

            System.out.println();
            System.out.println("*** change the step - odd numbers");
            for (int i = 1; i <= 10; i = i + 2)
            {
                System.out.println(i);
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac forloops/*.java
    jar cvfe forloops.jar forloops.Main forloops/*.class
    java -jar forloops.jar

Fix any errors you might encounter and try again.

We have a for loop where:

- counter = int i starting at 1
- range = as long as i is less than or equal to 10
- step = add 2 to i each time through the loop.

So the above code produces the following output, minus output from previous sections

    *** change the step - odd numbers
    1
    3
    5
    7
    9

The following shows the execution or flow of this loop.

![FOR Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-04.gif)

### Continue Statement

In this section, we show the effects of the **continue** statement. When in the body of a loop, the **continue** statement is encountered, everything stops and the loop goes to its next iteration, which is the next counter.

Add the following to the end of your main method:

            System.out.println();
            System.out.println("*** continue - Ending does not print even numbers ***");
            for (int i = 1; i <= 10; i++)
            {
                System.out.println("Beginning " + i);
                if ((i % 2) == 0)
                {
                    continue;
                }
                System.out.println("Ending " + i);
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac forloops/*.java
    jar cvfe forloops.jar forloops.Main forloops/*.class
    java -jar forloops.jar

Fix any errors you might encounter and try again.

We have a for loop where:

- counter = int i starting at 1
- range = as long as i is less than or equal to 10
- step = add 1 to i each time through the loop.
- continue statement = if i is evenly divided by 2, just continue the loop. Do not do the println() with Ending

So the above code produces the following output, minus output from previous sections:

    *** continue - Ending does not print even numbers ***
    Beginning 1
    Ending 1
    Beginning 2
    Beginning 3
    Ending 3
    Beginning 4
    Beginning 5
    Ending 5
    Beginning 6
    Beginning 7
    Ending 7
    Beginning 8
    Beginning 9
    Ending 9
    Beginning 10

The following shows the execution or flow of this loop. Note the range changed to 5 for demonstration purposes:

![FOR Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-05.gif)

### Break Statement

In this section, we show the effects of the **break** statement. When in the body of a loop and a **break** statement is encountered, everything stops; the loop ends without doing any more iterations.

Add the following to the end of your main method:

            System.out.println();
            System.out.println("*** break - Stops printing at 5 ***");
            for (int i = 1; i <= 10; i++)
            {
                System.out.println("Beginning " + i);
                if (i >= 5)
                {
                    break;
                }
                System.out.println("Ending " + i);
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac forloops/*.java
    jar cvfe forloops.jar forloops.Main forloops/*.class
    java -jar forloops.jar

Fix any errors you might encounter and try again.

We have a for loop where:

- counter = int i starting at 1
- range = as long as i is less than or equal to 10
- step = add 1 to i each time through the loop.
- break statement = if i greater than or equal to 5, just stop the loop

So the above code produces the following output, minus output from previous sections:

    *** break - Stops printing at 5 ***
    Beginning 1
    Ending 1
    Beginning 2
    Ending 2
    Beginning 3
    Ending 3
    Beginning 4
    Ending 4
    Beginning 5

The following shows the execution or flow of this loop.

![FOR Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-06.gif)

Expand to see the final forloops.main program

    package forloops;

    public class Main
    {
        public static void main(String[] args)
        {
            System.out.println("*** normal loop - Count 0 to 9 ***");
            for (int i = 0; i < 10; i++)
            {
                System.out.println(i);
            }

            System.out.println();
            System.out.println("*** change the index - even Numbers Between 1 and 10 n***");
            for (int i = 1; i <= 10; i++)
            {
                i++;
                System.out.println(i);
            }

            System.out.println();
            System.out.println("*** change the step - odd numbers");
            for (int i = 1; i <= 10; i = i + 2)
            {
                System.out.println(i);
            }

            System.out.println();
            System.out.println("*** continue - Ending does not print even numbers ***");
            for (int i = 1; i <= 10; i++)
            {
                System.out.println("Beginning " + i);
                if ((i % 2) == 0)
                {
                    continue;
                }
                System.out.println("Ending " + i);
            }

            System.out.println();
            System.out.println("*** break - Stops printing at 5 ***");
            for (int i = 1; i <= 10; i++)
            {
                System.out.println("Beginning " + i);
                if (i >= 5)
                {
                    break;
                }
                System.out.println("Ending " + i);
            }
        }
    }

##### Dig Deeper

- [Java Visualizer](https://cscircles.cemc.uwaterloo.ca/java_visualize/#)  
  Java Visualizer Website
- [Java Visualizer](https://plugins.jetbrains.com/plugin/11512-java-visualizer)  
  Java Visualizer IntelliJ Plugin
- [W3 Schools Java](https://www.w3schools.com/java/java_for_loop.asp)  
  W3 Schools Java For Loops
- [W3 Schools Java](https://www.w3schools.com/java/java_break.asp)  
  W3 Schools Java Break and Continue

---

#### Learn to craft and use while loops and do while loops (\*\*\* OPTIONAL \*\*\*)

<span id="WHILE_Loops"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

### The While Loop

So what about **while loops**? Like most languages, While Loops are a part of Java. While Loops execute a body (block of code) a until a certain condition is no longer true. A While Loop completes a pre-test on the condition where the condition is checked before the statement is run. If the condition is false, the body does **not** get run; if the condition is true, the body is executed. Thus, it is possible for the body to never be executed; the condition is false when the while loop is first executed.

- The body is what is enclosed in curly brackets `{ }`
- The condition that must be true for the body to execute is listed right after the `while` keyword
- Somewhere inside the body, the condition must change to where it eventually becomes `false`. Otherwise you have an infinite loop.

This is how a while loop is executed in Java. The following code executes its body 5 times (count 0, 1, 2, 3, 4):

![While Loop Explained](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-10.png)

### The Do While Loops

“Do while” loops have the same functionality as while loops with one major exception. The body of the do while loop is always executed at least once. The condition is at the end of the loop: the body executes and then the condition is checked:

- if `true` execute the body again
- if `false`, stop the loop and keep going with the application.

### Overview - While loops with continue and break

The commands `continue` and `break` work with while loops as they did with for loops:

- `continue` - says to start the loop again and do not execute any more of the body
- `break` - says to stop the loop immediately and continue with the application.

I would not recommend using continue and break. Usually, you can write your code in a more readable manner using proper branching statements. However, you should know that continue and break exist.

##### Follow Along

### While loop

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `whileloops`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/whileloops

Now in the the `whileloops` directory, use your text editor to create the following code in a file called `Main.java`:

    package whileloops;

    public class Main
    {
        public static void main(String[] args)
        {
            System.out.println("*** While Loop ***");
            int i = 1;
            while ((i % 5) != 0)
            {
                System.out.println(i);
                i++;
            }
        }
    }

Yes, I know that will generate an infinite loop. Stick with me through the example please!

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac whileloops/*.java
    jar cvfe whileloops.jar whileloops.Main whileloops/*.class
    java -jar whileloops.jar

Fix any errors you might encounter and try again.

So we get the following output:

    1
    1
    1
    1
    1
    1
    1
    1
    1
    ...

In other words, we have an infinite loop. We never change the condition in the body of the loop so the loop runs forever. To stop the loop, use the keyboard `Control-X`. Note that this is a huge advantage of running Java on a Java Virtual Machine. You can stop the Java Virtual Machine without affecting the rest of the computer operations. Virtual Machines are “the cat’s meow!”

Let’s fix our infinite while loop. Add the following line to the bottom of the while loop body:

                i++;

Now follow the steps to run the program. To run our code, we go through the following steps, running these commands from the `src` directory.

    javac whileloops/*.java
    jar cvfe whileloops.jar whileloops.Main whileloops/*.class
    java -jar whileloops.jar

Fix any errors you might encounter and try again.

So we get the following output:

    *** While Loop ***
    1
    2
    3
    4

The following shows the execution or flow of this loop.

![While Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-07.gif)

### Do While Loops

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/whileloops`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** Do While Loop ***");
            int j = 0;
            do
            {
                System.out.println(j);
                j++;
            }
            while (j < 5);

Now follow the steps to run the program. To run our code, we go through the following steps, running these commands from the `src` directory.

    javac whileloops/*.java
    jar cvfe whileloops.jar whileloops.Main whileloops/*.class
    java -jar whileloops.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    *** Do While Loop ***
    0
    1
    2
    3
    4

The following shows the execution or flow of this loop.

![While Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-08.gif)

### While loops with continue and break

The following code prints the odd numbers 1, 3, 5.

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/whileloops`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** While Loop With Continue and Break ***");
            int k = 0;
            while (k < 100)
            {
                k++;
                if ((k % 2) != 0)
                {
                    System.out.println(k);
                    continue;
                }
                System.out.println("We skipped one");
                if (k >= 5)
                {
                    break;
                }
            }

Now follow the steps to run the program. To run our code, we go through the following steps, running these commands from the `src` directory:

    javac whileloops/*.java
    jar cvfe whileloops.jar whileloops.Main whileloops/*.class
    java -jar whileloops.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    *** While Loop With Continue and Break ***
    1
    We skipped one
    3
    We skipped one
    5
    We skipped one

The following shows the execution or flow of this loop.

![While Loop execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-09.gif)

##### Dig Deeper

- [While Loops](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html)  
  Oracle's Java Nuts and Bolts While loops
- [Break](https://www.programiz.com/java-programming/break-statement)  
  The Break Statement
- [Continue](https://www.programiz.com/java-programming/continue-statement)  
  The Continue Statement

---

#### Learn to craft and use recursion (\*\*\* OPTIONAL \*\*\*)

<span id="Recursion"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

### Recursion

![Recursion](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/recursion.jpg)

Recursion is defined as something that is defined in terms of itself. For recursive functions to be successful, they require two main parts:

- a **general (recursive) case** - This is a function that is described and can be expressed in terms of smaller units of itself.
- a **base case** - A case where the recursive function can stop or is non-recursive. A solid simple solution to stop the recursive process.

For example, let’s look at the factorial or the product of an integer and all the integers below it:

- 7! = 7 \* 6 \* 5 \* 4 \* 3 \* 2 \* 1
- 7! = 7 \* 6!
  - 6! = 6 \* 5!
    - 5! = 5 \* 4!
      - 4! = 4 \* 3!
        - 3! = 3 \* 2!
          - 2! = 2 \* 1!
            - 1! = 1

### Recursion Use

Normally we do not use recursion and instead opt for an iterative solution to the problem. Iterative solutions are generally more efficient. However, recursion does have its place and is good to know.

For example, We can write the factorial function above using an iterative solution:

    package recursions;

    public class Main
    {
        public static int fact(int n)
        {
            int result = 1;
            for (int i = 2; i <= n; i++)
            {
                result = result * i;
            }
            return result;
        }
        public static void main(String[] args)
        {
            System.out.println("Factorial " + fact(5));
        }
    }

Especially for this section, take a look at the dig deeper additional resources. We will not be addressing recursion much in this class but is something a Java programmer should know.

##### Follow Along

### Recursion

Let’s write the factorial function using recursion!

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `recursions`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/recursions

Now in the the `recursions` directory, use your text editor to create the following code in a file called `Main.java`:

    package recursions;

    public class Main
    {
        public static int fact(int n)
        {
            if (n == 1)
            {
                return 1;
            }
            else
            {
                System.out.println(n + " * " + (n -1) + "!");
                return n * fact(n -1);
            }
        }
        public static void main(String[] args)
        {
            System.out.println("Factorial " + fact(5));
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac recursions/*.java
    jar cvfe recursions.jar recursions.Main recursions/*.class
    java -jar recursions.jar

Fix any errors you might encounter and try again.

The above code produces the following output:

    5 * 4!
    4 * 3!
    3 * 2!
    2 * 1!
    Factorial 120

- Our general case is the factorial of a number (that number \* the factorial of that (number - 1))
- The base case is that the factorial of 1 is 1. When the recursive code reaches this statement, the recursive calling of the function stops

The following shows the execution or flow of this recursive code.

![Recursion execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-11.gif)

##### Dig Deeper

- [Recursion](https://youtu.be/ozmE8G6YKww)  
  How Recursion Works Video
- [Recursion in Java](https://www.geeksforgeeks.org/recursion-in-java/)  
  Recusion in Java

---

#### Learn to craft and use Java conditionals, branching, including if-then, if-then-else, and switch statements (\*\*\* OPTIONAL \*\*\*)

<span id="Branching"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- Text Editor

We can control which statements are executed by using branching, conditionals. These allow us to say:

- if this is true
  - execute a body of statements
- if this is false
  - execute a different body of statements

In Java these are primarily done through:

- if..then..else statements
- ternary operations
- switch statements

### if..then..else statement

The following if..then..else statement is a very common construct.

    String result;
    if (conditional)
    {
        result = "Yes";
    } else
    {
        result = "No";
    }

A side note: notice how the String variable `result` is declared outside of the if..then..else statement? That way, `result` will be in scope and available to the rest of the method. If we had declared result inside the if..then..else statement, result would only be available inside those blocks: the then statement or the else statement!s

The characteristics of the above if..then..else are:

- A simple, straightforward comparison statement
- A single statement to run if the statement is true
- A single statement to run if the statement is false

An if..then..else statement that has a single condition followed by a single then statement and a single else statement is so common, there is a special construct just for that type of if..then..else statement. It is called the **ternary operator**.

### The ternary operation

    String result = (conditional) ? "Yes" : "No";

The ternary operator above includes:

- the conditional statement in parenthesis `( )`
- a `?`
- the statement to execute if the conditional is true
- a `:`
- the statement to execute if the conditional is false
- and of course the required `;`

### Switch Statement

Many nested if..then..else statements can be hard to read. Take for example printing the days of the week from an integer variable.

We set an integer to a value between 1 and 7. We then run it through a series of if..then..else statements to display the day of the week represented as: 1 is Monday, 2 is Tuesday and so on, until 7 is Sunday.

            if (day == 1)
            {
                System.out.println("Monday");
            }
            else if (day == 2)
            {
                System.out.println("Tuesday");
            }
            else if (day == 3)
            {
                System.out.println("Wednesday");
            }
            else if (day == 4)
            {
                System.out.println("Thursday");
            }
            else if (day == 5)
            {
                System.out.println("Friday");
            }
            else if (day == 6)
            {
                System.out.println("Saturday");
            }
            else if (day == 7)
            {
                System.out.println("Sunday");
            }
            else
            {
                System.out.println("Not a day");
            }

There is nothing wrong with this statement except it is hard to read. Java provides a more straightforward method to represent such nested if..then..else..statements: a switch statement. The syntax of the switch statement is as below:

    switch (ordinal_type) {
        case a constant :
            System.out.println("found it");
        case another_constant :
            System.out.println("found another one");
        default:
            System.out.println("default");
    }

The important characteristics of the switch statement are:

- `switch` is the keyword for this statement
- the ordinal type can be any data type that can be counted: byte, short, int, char, String (specifically NOT long, double)
- switch searches until it find the first ordinal type that matches the variable and performs the associated statement(s). The order of the ordinal type constants do not matter!
- if no match is made, the default action is performed

### Conditions Combination

In Java, you can combine statements and use basic comparison operators. Let’s say you want to check if `salary` is greater than 50000 and current is true. `Salary` is an integer; `current` is a boolean. You get the following code for an if..then..else statement.

Notice that since `current` is a boolean it can stand alone. It already evaluates to true or false so

    if ((salary > 50000) && current)
    {
        <statements if true>
    } else
    {
        <statements if false>
    }

is the same as

    if ((salary > 50000) && (current == true))
    {
        <statements if true>
    } else
    {
        <statements if false>
    }

The first option is preferred!

Java allows for the following comparisons.

- Less than: a `<` b
- Less than or equal to: a `<=` b
- Greater than: a `>` b
- Greater than or equal to: a `>=` b
- Equal: to a `==` b
- Not Equal to: a `!=` b
- And: true `&&` true
- Or: true `||` true

### Comparing Strings

Of course, Strings, being a class, have to be difficult, I mean different!

You should not compare strings using the `==` operator. This compares the objects, or the pointers, of the string, not the value. Although in practice the `==` operator MIGHT work, the use of it can be easily exploited when doing string comparisons for security purposes. Instead we use the method `.equals()` or `.equalsIgnoreCase()`.

To use the .equals() or .equalsIgnoreCase() statement, any string object can call these methods. These methods take as a single parameter another string object. Using these statements, we can safely compare string object to string object. Let’s take a look!

##### Follow Along

Let’s look at each type of branching statement

### if..then statement

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `branching`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/branching

Now in the the `branching` directory, use your text editor to create the following code in a file called `Main.java`:

    package branching;

    public class Main
    {
        public static void main(String[] args)
        {
            int time = 22;

            if (time > 11)
            {
                System.out.println("Good Morning.");
            }
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

The above code produces the following output:

    Good Morning.

So what happened? We initialize an integer variable `time` to 22. If time is greater than 11 (and yes the parentheses are required), do the statements in the curly brackets `{ }`. Otherwise do nothing.

### if..then..else statement

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/branching`.

Add the following to the end of your Main class:

            time = 22;

            if (time < 11)
            {
                System.out.println("Good Morning.");
            } else if (time < 20)
            {
                System.out.println("Good Day.");
            } else
            {
                System.out.println("Good Evening.");
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    Good Evening.

So what happened?

- Set the `time` integer variable to 22
- See if `time` is less than 11
  - if so display Good Morning.
  - if not, see if `time` is less than 20
    - if so display Good Day.
    - otherwise display Good Evening.

### Ternary Operator

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/branching`.

Add the following to the end of your Main class:

            time = 22;

            String result = (time < 18) ? "Good Day." : "Good Evening.";
            System.out.println(result);

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    Good Evening.

The ternary statement above is the same as the following if..then..else statement:

            String result;
            if (time < 18)
            {
                result = "Good Day.";
            } else
            {
                result = "Good Evening.";
            }

### Switch without break statement

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/branching`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** Switch Without Break Statement ***");
            int day = 4;
            switch (day) {
                case 1:
                    System.out.println("Monday");
                case 2:
                    System.out.println("Tuesday");
                case 3:
                    System.out.println("Wednesday");
                case 4:
                    System.out.println("Thursday");
                case 5:
                    System.out.println("Friday");
                case 6:
                    System.out.println("Saturday");
                case 7:
                    System.out.println("Sunday");
                default:
                    System.out.println("Not a day");
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    *** Switch Without Break Statement ***
    Thursday
    Friday
    Saturday
    Sunday
    Not a day

Since the `day` variable is `4`, switch found the `4` and displayed `Thursday`. But wait a minute, what about the other days? Switch is considered a fall through statement: after the correct constant is found, all statements following the correct constant are executed as well. That is the way we get `Thursday` for being a `4`, the value of the day variable. But then the rest of the statements are executed as well, which are those statements that appear in code below the 4.

That might be what you want. If not, let’s fix it!

### Switch with break statement

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/branching`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** Switch With Break Statement ***");
            switch (day) {
                case 1:
                    System.out.println("Monday");
                    break;
                case 2:
                    System.out.println("Tuesday");
                    break;
                case 3:
                    System.out.println("Wednesday");
                    break;
                case 4:
                    System.out.println("Thursday");
                    break;
                case 5:
                    System.out.println("Friday");
                    break;
                case 6:
                    System.out.println("Saturday");
                    break;
                case 7:
                    System.out.println("Sunday");
                    break;
                default:
                    System.out.println("Not a day");
            }

Remember that day is still `4`.

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

So this section produces the following output, minus output from previous sections:

    Thursday

The addition of the `break` statement stops the fall through action of the switch statement!

### Comparing Strings

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/branching`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** String Comparison ***");
            String firstone = "Turtle";
            String secondone = "Turtle";

            System.out.println("== MIGHT work");
            if (firstone == secondone)
            {
                System.out.println("EQUAL");
            } else
            {
                System.out.println("NOT EQUAL");
            }

            System.out.println("the equals() method is better");
            if (firstone.equals(secondone))
            {
                System.out.println("EQUAL");
            } else
            {
                System.out.println("NOT EQUAL");
            }

            System.out.println("to ignore case use the equalsIgnoreCase() method");
            secondone = "TURTLE";
            if (firstone.equalsIgnoreCase(secondone))
            {
                System.out.println("EQUAL");
            } else
            {
                System.out.println("NOT EQUAL");
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac branching/*.java
    jar cvfe branching.jar branching.Main branching/*.class
    java -jar branching.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    *** String Comparison ***
    == MIGHT work
    EQUAL
    the equals() method is better
    EQUAL
    to ignore case use the equalsIgnoreCase() method
    EQUAL

##### Dig Deeper

- [if..then..else](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html)  
  Oracle Java Nuts and Bolts if..then..else
- [Switch](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html)  
  Oracle Java Nuts and Bolts Switch
- [Comparing Strings](https://www.geeksforgeeks.org/compare-two-strings-in-java/)  
  Comparing Two Strings

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### java-EmployeeAPP

We will be learning our way around the Java Development Kit using the standard Hello World application. We then address the basics of the Java Langauge and data types.

[GitHub Repo](https://github.com/LambdaSchool/java-EmployeeApp.git)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Snack Bar](https://github.com/LambdaSchool/java-SnackBar.git)

  In this project, you will practice using the JDK, working with multiple Java classes and objects, and using base data types.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Java JDK and Classes for WEB33 with John Mitchell](https://youtu.be/ZRQPnRpa7dA)**
- [All previous recordings](/archive/WEB4Java/module/recAGVTYNZyJbEFpu)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Guided Project: java-EmployeeAPP
- Project: Snack Bar
