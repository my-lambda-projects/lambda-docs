Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# A First-Pass Solution

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- effectively ask for help by giving the expected vs. experienced behavior, explaining what specific actions they've taken so far, and providing all relevant information and code
- interpret a problem, specification, or diagram and construct a plan for implementing a solution in code
- implement a first-pass solution after selecting from a naïve, brute-force, or greedy approach

#### Pro Tip

Testing will happen. The choice you make is who does the testing and when it happens. Internal people testing earlier is generally preferable to external customers testing ‘live’, but either way, the testing will happen.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [Video: Algorithms Overview](https://youtu.be/RP5PVTY3rRQ)

  Quick overview video introducing why algorithms are important and laying out how we’re going to be talking about solving algorithmic problems.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=vtoYShxbPQw), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to effectively ask for help by giving the expected vs. experienced behavior, explaining what specific actions they've taken so far, and providing all relevant information and code

##### Overview

The essential action when asking a question is to imagine that you are trying to answer your question. Because you are deep in the weeds of your problem, it’s easy to forget that the person who answers your question does not have all the context that you have￼. We should keep this general rule in mind, and it is the overarching rule for all the details we go into next.

### Search and Research

Before you do anything else, search for a solution to your problem on your own. One thing you should start doing is keeping track of all your research when solving a problem. One easy way to do this is to have a browser window represent a specific search for a solution, and for each open tab to represent an attempt at solving it. Keeping track of your research is vital because it’s helpful to give examples of similar questions or similar problems, but to explain why those didn’t answer your specific problem or question. It also helps the person answering your question avoid pointing you towards resources you’ve already explored, and lets them know that you’ve already put in the work you can to solve the problem.

### Introduce the Problem

The first thing you do when you ask a question￼￼￼￼ is to introduce the problem. The first paragraph of your written question should serve as an executive summary of the problem. All the following paragraphs should fill in the details of the problem.

An important thing to include in your problem introduction is to explain precisely how you encountered the problem. Write about the difficulties that have kept you from solving it. Describe what you have already tried and include the results of the research you’ve already done.

You should also provide as much detail about the context as possible. For instance, include the language version, the platform version, the operating system, the database type, specific IDE, and any web server information if relevant. You should also include your specific constraints. For example, you may not be allowed to use feature A or B that would provide an obvious solution. If you have a strange or weird constraint, it’s also helpful to give specific reasons for why you have that constraint.

### Help Others Reproduce the Problem

One thing to remember is that not all questions benefit from including code. However, if you include code, definitely do not just copy in your entire program! By including irrelevant details, you make your question much harder to answer and decrease your chances of anyone helping you out.

Here are some guidelines for when you include code in your question.

#### Minimal

Include just enough code to allow others to reproduce your specific problem.￼￼ One way to do this is to restart from scratch. Do not include snippets of your entire program. Instead, create a new program but only add what is necessary to recreate the problem.

If you aren’t exactly sure what code is the source of your problem, one way to identify it is by removing code one chunk at a time until the problem disappears. Then add back the last part. From that, you can tell the last part you added back is likely the source of your problem.

One thing to remember is not to remove too much code. By attempting to be brief in your question, you might accidentally sacrifice the overall clarity of your question.

#### Complete

Make sure you include all the portions of the code needed to reproduce the problem. You should assume that the person who is answering your question will not write any code to reproduce your problem. Again, remember, do not use images of code. Those that are trying to help you need to read and use the code you include in your question quickly.

#### Reproducible

When you include your code, it’s also important to tell the reader exactly what you expect the behavior to be. Also tell the reader the exact wording of the error message that may come up for you. It’s also crucial to double-check that your included example reproduces the problem.

One other thing you can do is create a live example on a site like sqlfiddle.com or jsbin.com. If you do, make sure you also include your copies of your code in your question. Not everyone will utilize the link to the live example.

And to reiterate, do not post images of any code, data, or error messages. You should reserve images only for things such as rendering bugs–things that are impossible to describe accurately with just text.

### ￼￼￼￼￼￼Proofread

You mustn’t make those you are asking for help also proofread your question. When you post your question, you should have already read and reread your question, making sure you’re following all the best practices and that your question makes sense. You should imagine that you’re coming to your question fresh with no other context but the question itself. Basically, you want to make it so that your question is a pleasure for someone to answer. Remember, the reader is likely choosing from amongst many questions they could answer. You want your question to stand out and be as easy as possible to answer. You must also correct spelling, grammar, and formatting. That being said, you don’t want to go overboard; you’re not writing a novel. But, easily corrected spelling, grammar, or formatting errors should not distract the reader.

### Respond to Feedback

As feedback and responses come into your question, you want to respond as quickly as possible. You’ll likely receive clarifying questions, and your readers need an answer to those clarifying questions to help you.￼￼￼￼

##### Follow Along

Let’s now look at an example of a question posted to Stack Overflow and analyze the question to see if it follows the best practices outlined above.

[The question](https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops) we are analyzing appears in a screenshot below:

![Stack Overflow Question](https://tk-assets.lambdaschool.com/d801960f-be0f-4f36-864a-5dbffad50f1c_ScreenShot2020-03-30at3.15.30PM.png)

The first thing to notice is that the post has a short but descriptive title that adequately summarizes the question.

> Accessing the index in ‘for’ loops?

Next, let’s look at if the questioner provided any necessary context or proof of the searching/researching they’ve done so far. It does not appear that they did. They could improve the question by including what they tried and the resources they explored.

The questioner did do an excellent job of introducing the question and including code that shows what they are trying to do. In this case, they did not need to include experience vs. expected behavior. They just needed to include the expected behavior. By clearly stating what the desired result was, it helped the person answering to respond appropriately.

Also, the code they included is a minimal and complete example and allows someone to reproduce the problem quickly. The questioner left out irrelevant details and code that would’ve distracted from the primary question. They also included an example of what the desired output would be, which is helpful.

It does appear that the person asking proofread their question because it does not contain any glaring spelling, grammar, or formatting problems. However, we could critique this example for including a redundant sentence at the end. Instead of including that sentence, they might have rephrased the first sentence of the question to be more precise.

##### Challenge

1.  Choose a real-world example from a recent problem/challenge. Use the guidelines and process outlined above to ask for help in your cohort-specific help channel.
2.  Identify an unanswered question in your cohort-specific help channel. Do your best to provide a helpful response to that question.
3.  Find an example of a **bad** question on Stack Overflow. Analyze the question using the guidelines above and write a short response as to _why_ you believe it is a **bad** question.
4.  Find an example of a **good** question on Stack Overflow. Analyze the question using the guidelines above and write a short response as to _why_ you believe it is a **good** question.

##### Dig Deeper

- [Stack Overflow: How Do I Ask a Good Question?](https://stackoverflow.com/help/how-to-ask)
- [Writing the Perfect Question](https://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/)
- [How to Ask Questions the Smart Way](http://catb.org/esr/faqs/smart-questions.html)
- [How to Debug Small Programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/)

---

#### Learn to interpret a problem, specification, or diagram and construct a plan for implementing a solution in code

##### Overview

In this objective, we talk specifically about the **P** in our U**P**ER Problem-Solving Framework.

![UPER Graphic](https://tk-assets.lambdaschool.com/af39294f-e7f8-4d32-8799-0cfe87f5e887_u_P_er.svg)

When solving a problem, you must always have a plan. You should not count on the strategy of aimlessly wandering and hoping you solve the problem. Without a plan, you are relying on getting lucky as you poke around in the dark. Even the most brilliant and talented engineers and scientists rely on thorough and detailed planning when they approach problems they are trying to solve. Trying to solve a problem without proper planning is not a strategy; it’s counting on luck to save you from your lack of planning.

It is always possible to create a plan. Therefore, never skip this step of the UPER process. The plan cannot be the actual implementation— if you had the implementation, you would have already solved the problem. The plan is for **_how_** you are going to arrive at the solution. What specific process will you follow that will cause you to arrive at the solution? You need to break down the big problem into a series of smaller, measurable, and actionable steps that you can take. By successfully solving all the smaller problems, you solve the more significant problem.

When you develop your plan, expect that your plan will change as you move forward. By setting the expectation that your plan will change, it relieves you of any pressure to develop the “perfect” plan at the outset.

> “I have always found that plans are useless, but planning is indispensable.” _– General Dwight D. Eisenhower_

The quote above is getting at the fact that the act of planning itself is useful, even if things end up not going according to plan.

Planning also allows you to set and achieve smaller goals. Without a detailed plan, you won’t feel any sense of accomplishment until you solve the entire problem. By creating a plan with a series of smaller goals, you allow yourself to receive positive reinforcement and motivation as you complete each small step. You wouldn’t sit down at your computer with a goal of “cloning Instagram”. Before beginning any actual work, you would have to create a plan that included a series of smaller objectives. This way, each time you work on the project, you could mark off something from your list of goals, and you would know that you were that much closer to achieving your overall goal. Your confidence in your ability to solve the more significant problem would also grow each time you completed one of your smaller goals.

##### Follow Along

Now we look at a specific problem called “Climbing Stairs”. You can find one version of the problem on [leetcode.com](https://leetcode.com/problems/climbing-stairs/).

The problem description is:

> You are climbing a staircase. It takes `n` steps to reach the top.
>
> Each time, you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
>
> **Note:** Given `n` will be a positive integer.
>
> **Example 1:**
>
>     Input: 2
>     Output: 2
>     Explanation: There are two ways to climb to the top.
>     1. 1 step + 1 step
>     2. 2 steps
>
> **Example 2:**
>
>     Input: 3
>     Output: 3
>     Explanation: There are three ways to climb to the top.
>     1. 1 step + 1 step + 1 step
>     2. 1 step + 2 steps
>     3. 2 steps + 1 step

We are not solving the problem now— we are crafting a plan for solving it.

First, let’s break the problem into smaller objectives that we can then tackle one at a time:

1.  Decide if we should use recursion to solve the problem by looking for clues in the problem description.
2.  Find similar problems that we’ve already solved and analyze those problems to see if they help us solve this problem.
3.  Draw a diagram for a small input and study the diagram to help understand any potential solutions.
4.  If we use recursion, discover the base case or base cases.
5.  If we use recursion, discover the recursive case.
6.  Write out our algorithm as pseudocode.
7.  Change each line of pseudocode into actual code.
8.  Test out our code and see if it is returning the outputs that we would expect.

The list above is an excellent start of sub-objectives that we can begin working on right away. Remember, as we solve the sub-objectives, we should be prepared to change our original plan. We should allow every new piece of information or understanding to mold and inform our original plan as we move forward.

##### Challenge

1.  Refer to this [leetcode.com problem](https://leetcode.com/problems/fibonacci-number/) called “Fibonacci Number”. Write out a detailed plan of **_how_** you would solve the problem. Remember, we aren’t solving the problem now, we are just practicing the **P** part of the U**P**ER process.

---

#### Learn to implement a first-pass solution after selecting from a naïve, brute-force, or greedy approach

##### Overview

In this objective, we focus specifically on the **E**xecute step in our UP**E**R Problem-Solving Framework.

![UPER Graphic with the E emphasized](https://tk-assets.lambdaschool.com/232fdf58-0b43-4bf9-b564-98a6a9e1781c_up_E_r.svg)

The primary thing we need to have during this phase is patience. You should be proud that you’ve gotten this far. The **P**lan phase is much harder than this phase. If you can avoid getting overly frustrated and maintain a patient approach, you will go far.

The good thing is that the work we did to understand the problem and the work we did to craft a plan will come in handy. I’ve included the plan we created in the previous objective, and that will serve as an outline we can execute step by step. I’ve also included the problem description.

### Problem Description

> You are climbing a staircase. It takes `n` steps to reach the top.
>
> Each time, you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
>
> **Note:** Given `n` will be a positive integer.
>
> **Example 1:**
>
>     Input: 2
>     Output: 2
>     Explanation: There are two ways to climb to the top.
>     1. 1 step + 1 step
>     2. 2 steps
>
> **Example 2:**
>
>     Input: 3
>     Output: 3
>     Explanation: There are three ways to climb to the top.
>     1. 1 step + 1 step + 1 step
>     2. 1 step + 2 steps
>     3. 2 steps + 1 step

### Plan

1.  Decide if we should use recursion to solve the problem by looking for clues in the problem description.
2.  Find similar problems that we’ve already solved and analyze those problems to see if they help us solve this problem.
3.  Draw a diagram for a small input and study the diagram to help understand any potential solutions.
4.  If we use recursion, discover the base case or base cases.
5.  If we use recursion, discover the recursive case.
6.  Write out our algorithm as pseudocode.
7.  Change each line of pseudocode into actual code.
8.  Test out our code and see if it is returning the outputs that we would expect.

##### Follow Along

Let’s execute our plan.

**1. Decide if we should use recursion to solve the problem by looking for clues in the problem description.**

What clues in the description are there that might lead us to use recursion in our solution? The important wording that jumps out immediately is:

> In _how many ways_ can you climb to the top?

Any time we are looking at combinations or permutations (ways of combining or ordering things), it’s an excellent opportunity to use recursion.

So, we’ve completed item number one from our plan and move forward using recursion for this problem.

**2. Find similar problems that we’ve already solved and analyze those problems to see if they help us solve this problem.**

The connection may not be immediately obvious to you, but this problem is similar to the [Fibonnaci problem](https://leetcode.com/problems/fibonacci-number/) that you’ve likely encountered in your initial exploration of recursion. How so? Well, to reach the `n`<sup>th</sup> step, we are trying to find what the unique possibilities for the previous steps are. We base each current calculation on a combination of previous calculations. In Fibonacci, similarly, we had to compute the `n`<sup>th</sup> value by computing `n - 1` + `n - 2`. Making this connection now should help as we move forward in our execution.

**3. Draw a diagram for a small input and study the diagram to help understand any potential solutions.**

Diagrams and drawings can often help lead us to a solution. Let’s try to diagram the solution with an input of 5.

![Diagram of Climbing Stairs Problem](https://tk-assets.lambdaschool.com/f96b4414-45c0-4dfc-8142-9cf037fa1322_S2-M2-03-Diagramming-Example.001.jpeg)

So, for each step, we have two options–we can take one or two steps. By drawing a diagram like this, we can reason about what we are trying to count. For the diagram above, each unique path from step zero to step five represents the thing we are trying to count.

![Animation of Climbing Stairs Problem Diagram](https://tk-assets.lambdaschool.com/febaed2a-68ba-4d36-8017-ac4bb3be04c0_S2-M2-O3-Diagram-Climbing-Stairs-Animation.gif)

**4. If we use recursion, discover the base case or base cases.**

Examine the diagram we drew. What would be the base case? The base case would be if the current step we are on is higher than the desired final step (`n`) or is equal to the desired final step (`n`). What do we need to return when we hit one of the base cases? Well, remember we are counting paths to get to `n`. So, if the current step equals `n`, then we should return `1` to represent one valid path to the desired step. If the current step is higher than `n`, we went too far, and we should not count that path by returning `0`.

So our base cases are:

- If the current step is equal to `n`, return `1`.
- If the current step is greater than `n`, return `0`.

**5. If we use recursion, discover the recursive case.**

If we aren’t at a base case, what is the recursive case? Again, looking at the diagram, we have two options: take two steps or take one step. We represent this by a recursive call to our function, but with the current step incremented by one or two.

**6. Write out our algorithm as pseudocode.**

It’s time to collect all of our current understanding into a pseudocode algorithm.

    input to function is current_step and desired_step (both integers):
        if current_step is greater than desired_step:
            return 0
        if current_step is equal to desired_step:
            return 1

These are our base cases in pseudocode. Now let’s add our recursive case.

    input to function is current_step and desired_step (both integers):
        if current_step is greater than desired_step:
            return 0
        if current_step is equal to desired_step:
            return 1
        return climb_stairs(current_step+1, desired_step) + climb_stairs(current_step+2, desired_step)

Now, we have an algorithm represented in pseudocode. Calling back to one of our first steps, you can see how similar this is to the algorithm for finding the nth item in the Fibonacci sequence.

**7. Change each line of pseudocode into actual code.**

One of the beautiful things about Python is that Python code reads almost like pseudocode. In our case, we have very little to do to convert from pseudocode into actual Python code.

    def climb_stairs(current, desired):
        if current > desired:
            return 0
        if current == desired:
            return 1
        return climb_stairs(current+1, desired) + climb_stairs(current+2, desired)

**8. Test out our code and see if it is returning the outputs we would expect.**

Now that we have an actual algorithm to test out, we can test it out to see if it returns the expected output given a specific input. Since we were using an input of `5` for our diagram, we also use that here.

![Code Visualization of the Climbing Stairs Problem](https://tk-assets.lambdaschool.com/45f9e57f-7542-4ab0-aa6e-a07ceec46a9a_S2-M2-O3-Climbing-Stairs-Visualized-Code.gif)

##### Challenge

Complete the entire UPER process to solve the following problem. You can also find the problem on Leetcode as [Problem #1137](https://leetcode.com/problems/n-th-tribonacci-number/).

**Problem Statement:**

> The Tribonacci sequence T<sub>n</sub> is defined as follows: T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n &gt;= 0. Given `n`, return the value of T<sub>n</sub>.
>
> **Example 1:**
>
>     Input: n = 4
>     Output: 4
>     Explanation:
>     T_3 = 0 + 1 + 1 = 2
>     T_4 = 1 + 1 + 2 = 4
>
> **Example 2:**
>
>     Input: n = 25
>     Output: 1389537
>
> **Constraints:**
>
> - `0 <= n <= 37`
> - The answer is guaranteed to fit within a 32-bit integer.

Remember, don’t just jump right into your code. Spending time thinking deeply about **Understanding** the problem and **Planning** your approach is invaluable.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Algorithms](https://github.com/LambdaSchool/cs-module-project-algorithms)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[A First Pass Solution for CSPT12 w/Beej Hall](https://youtu.be/Tj3BtIlpGSI)**

  How to solve algorithmic problems

- [All previous recordings](/archive/CS/module/recrCuZQMVI6LvxhD)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  1.  Choose a real-world example from a recent problem/challenge. Use the guidelines and process outlined above to ask for help in your cohort-specific help channel.
  2.  Identify an unanswered question in your cohort-specific help channel. Do your best to provide a helpful response to that question.
  3.  Find an example of a **bad** question on Stack Overflow. Analyze the question using the guidelines above and write a short response as to _why_ you believe it is a **bad** question.
  4.  Find an example of a **good** question on Stack Overflow. Analyze the question using the guidelines above and write a short response as to _why_ you believe it is a **good** question.

- Objective challenge:

  1.  Refer to this [leetcode.com problem](https://leetcode.com/problems/fibonacci-number/) called “Fibonacci Number”. Write out a detailed plan of **_how_** you would solve the problem. Remember, we aren’t solving the problem now, we are just practicing the **P** part of the U**P**ER process.

- Objective challenge:

  Complete the entire UPER process to solve the following problem. You can also find the problem on Leetcode as [Problem #1137](https://leetcode.com/problems/n-th-tribonacci-number/).

  **Problem Statement:**

  > The Tribonacci sequence T<sub>n</sub> is defined as follows: T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n >= 0. Given `n`, return the value of T<sub>n</sub>.
  >
  > **Example 1:**
  >
  >     Input: n = 4
  >     Output: 4
  >     Explanation:
  >     T_3 = 0 + 1 + 1 = 2
  >     T_4 = 1 + 1 + 2 = 4
  >
  > **Example 2:**
  >
  >     Input: n = 25
  >     Output: 1389537
  >
  > **Constraints:**
  >
  > - `0 <= n <= 37`
  > - The answer is guaranteed to fit within a 32-bit integer.

  Remember, don’t just jump right into your code. Spending time thinking deeply about **Understanding** the problem and **Planning** your approach is invaluable.

- Project: Algorithms
