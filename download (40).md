<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

- [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
- [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
- [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
- [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

- [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
- [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
- [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
- [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

- [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
- [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
- [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
- [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

- [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
- [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
- [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
- [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

- [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
- [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
- [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
- [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

- [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
- [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
- [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
- [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Introduction to Node.js and Express

<span class="lead"> </span>

On this lecture we will:

- introduce `node.js` and `Express`.
  - what is `node.js`, what can it do? what can’t it do?
  - what is `Express`? why use it?
  - relationship between `Express` and `node.js`.
- see a high level overview of the main features of `Express`.
- learn how to manually test our Web API using a tool called `Postman`.
- create our first CRUD Web API.

**At the end of this module, you should be able to:**

- explain what Node.js is and its core features
- explain what Express is and its core features
- create an API that can respond to GET requests
- use postman to manually test Web APIs

#### Pro Tip

Never put anything out there on social media that you wouldn’t want to come up in an interview. People check.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Ez75BevKbi4), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=pxRHZ2WI8tc), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=iNtm78tLjuo), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=kk1PcjtEPZE), or enable JavaScript if it is disabled in your browser.

- [Node.js Website](https://nodejs.org/en/)

- [Express Website](https://expressjs.com/)

- [What is an API? In English, please](https://medium.freecodecamp.org/what-is-an-api-in-english-please-b880a3214a82)

  Simple introduction what an API is

- [Hello World Example on Express Docs](https://expressjs.com/en/starter/hello-world.html)

  The hello world example provided by Expressjs.com

- [Postman Download](https://www.getpostman.com/apps)

  Postman app download link.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what Node.js is and its core features

`Node.js` is a _runtime environment_ (a program that runs other programs), a platform used to execute JavaScript applications outside the browser.

This opens up a new world of possibilities for JavaScript developers. We can now use JavaScript to write command line utilities, native programs that run on different operating systems, networking software, web services, web applications and more.

##### Overview

Traditionally, the JavaScript language was only used in web browsers, but in 2009, `Node.js` was unveiled, and with it, the developer tool kit expanded greatly. Node.js gave developers the chance to use JavaScript to write software that, up to that point, could only be written using C, C++, Java, Python, Ruby, C# and the like.

We will use Node to write server code, specifically `web services` that can communicate with clients using the `JSON` (**J**ava**S**cript **O**bject **N**otation) format for data interchange.

Some of the advantages of using `Node.js` for writing server side code are:

- JavaScript on the server: use the same programming language and paradigm for both client and server. This minimizes context switching and makes it easy to share code between the client and the server.
- Single-threaded: removes the complexity involved in handling multiple threads.
- Asynchronous: can take full advantage of the processor it’s running on. This matters because the node process will be running on a single CPU.
- Npm repository: access the largest ecosystem of useful libraries (most of them free to use) in the form of `npm modules`.

Some of the disadvantages of using `Node.js` for writing server-side code are:

- JavaScript on the server: we lose the ability to use the right tool (language) for the job.
- single-threaded: can’t take advantage of servers with multiple cores/processors.
- asynchronous: it is harder to learn for developers that have only worked with languages that default to synchronous operations that block the execution thread.
- npm repository: too many packages that do the same thing makes it harder to choose one and, in some cases, may introduce vulnerabilities into our code.

To write a simple web server with `Node.js`:

1.  Use Node’s `HTTP` module to abstract away complex network-related operations.
2.  Write the single **_request handler_** function that will handle all requests to the server.

The request handler is a function that takes the `request` coming from the client and produces the `response`. The function takes two arguments: 1) an object representing the `request` and 2) an object representing the `response`.

This process works, but the resulting code is verbose even for the simplest of servers. Also, note that when using only Node.js to build a server, we use a single request handler function for all requests.

##### Follow Along

Let’s write a simple web server that returns a message using only `Node.js`. Create a folder for and add an `index.js` file inside.

Add the following code to `index.js`:

    const http = require('http'); // built in node.js module to handle http traffic

    const hostname = '127.0.0.1'; // the local computer where the server is running
    const port = 3000; // a port we'll use to watch for traffic

    const server = http.createServer((req, res) => {
      // creates our server
      res.statusCode = 200; // http status code returned to the client
      res.setHeader('Content-Type', 'text/plain'); // inform the client that we'll be returning text
      res.end('Hello World from Node\n'); // end the request and send a response with the specified message
    });

    server.listen(port, hostname, () => {
      // start watching for connections on the port specified
      console.log(`Server running at http://${hostname}:${port}/`);
    });

Now navigate to the folder in a terminal/console window and type: `node index.js` to execute your file. A message that reads “_Server running at http://127.0.0.1:3000_” should be displayed, and the server is now waiting for connections.

Open a browser and visit: `http://localhost:3000`; `localhost` and the ip address `127.0.0.1` point to the same thing: your local computer. The browser should show the message: “_Hello World from Node_”. There you have it, your first web server, built from scratch using nothing but `Node.js`.

##### Challenge

Write a paragraph about what `Node.js` is and explain at least 3 of its core features.

Submit the paragraph to your TL.

##### Dig Deeper

- [NodeJS Runtime environment for JS](https://www.infoworld.com/article/3210589/node-js/what-is-nodejs-javascript-runtime-explained.html)

---

#### Learn to explain what Express is and its core features

Express is a web application framework that sits on top of the Node.js web server (http server module). It’s like React, for your backend.

Express sits on top of the raw `http` server module provided by `Node.js` and adds extra functionality, like routing and middleware support, and a simpler API.

##### Overview

Node’s built-in `HTTP` module provides a powerful way to build web applications and services, but it requires a lot of code for common tasks like sending an `HTML` page to the browser.

Introducing `Express`, a light and unopinionated framework that **sits on top of Node.js** and makes it easier to create web applications and services. Sending an `HTML` file or image is now a one-line task with the `sendFile` helper method in `Express`.

Ultimately, `Express` is **just a Node.js module** like any other module.

What can we do with Express? So many things! For example:

- build web applications.
- serve _Single Page Applications_ (SPAs).
- build RESTful web services that work with JSON.
- serve static content, like HTML files, images, audio files, PDFs, and more.
- power real-time applications using technologies like `Web Sockets` or `WebRTC`.

Some of the benefits of using Express are that it is:

- Simple
- Unopinionated
- Extensible
- Light-weight
- Compatible with [connect middleware](https://www.npmjs.com/package/connect). (This means we can tap into an extensive collection of modules written for `connect`.)
- All packaged into a clean, intuitive, and easy to use API.
- Abstracts away common tasks (writing web applications can be verbose, hence the need for a library like this)

Some of the drawbacks of Express are:

- It’s not a one-stop solution. Because of its simplicity, it does very little out of the box compared to frameworks like `Rails` and `django`.
- We are forced to make more decisions due to the flexibility and control it provides.

### Main Features of Express

#### Middleware

Middleware functions can get the request and response objects, operate on them, and (when specified) trigger some action. Examples are logging or security.

Express’ middleware stack is basically an array of functions.

Middleware CAN change the request or response but it doesn’t have to.

#### Routing

Routing is a way to select which request handler function is executed. It does so based on the URL visited and the HTTP method used. Routing provides a way to break an application into smaller parts.

#### Routers for Application Modularity

Applications can be broken up into `routers`. We could have a router to serve our SPA and another router for our API. Each router can have its own middleware and routing. This combination provides improved functionality.

#### Convenience Helpers

`Express` has many helpers that provide out of the box functionality to make writing web applications and API servers easier.

A lot of those helpers are extension methods added to the request and response objects.

Examples [from the Api Reference](https://expressjs.com/en/4x/api.html) include: `response.redirect()`, `response.status()`, `response.send()`, and `request.ip`.

#### Views

Views provide a way to dynamically render HTML on the server and even generate it using other languages.

##### Follow Along

Let’s write our first server using `Express`.

create a new file called `server.js` to host our server code. type `npm init -y` to generate a `package.json`. install the `express` npm module using: `npm install express`. inside `server.js` add the following code:

    const express = require('express'); // import the express package

    const server = express(); // creates the server

    // handle requests to the root of the api, the / route
    server.get('/', (req, res) => {
      res.send('Hello from Express');
    });

    // watch for connections on port 5000
    server.listen(5000, () =>
      console.log('Server running on http://localhost:5000')
    );

Run the server by typing: `node server.js` and visit `http://localhost:5000` in the browser.

To stop the server type `ctrl + c` at the terminal window.

##### Challenge

On your own: Write a paragraph about what Express is and explain how it is used in modern web application development.

Submit your paragraph to your TL.

---

#### Learn to create an API that can respond to GET requests

Now that most of the basic theory is out of the way, we’ll move into building our first API (**A**pplication **P**rogramming **I**nterface).

What is an API you ask? [This article defines it and plain english](https://medium.freecodecamp.org/what-is-an-api-in-english-please-b880a3214a82), but in this context an API is \*server software that publishes a set of **endpoints** that clients can use to manage **resources\***.

##### Overview

In this overview we’re walking through the steps necessary to build a simple Web API that returns the string “Hello World” on every incoming `GET` request. The program should return the string every time a request comes into the root route (“/”). For now, you don’t need to code along, just read through the steps.

To make things easier, we’ll use an existing repository as the base for our API. Later in the week, as we learn more about `Node.js` and `Express`, we’ll create an API from scratch.

To build our first API we will:

1.  clone the [node-express-mini repository](https://github.com/LambdaSchool/node-express-mini) to a folder in our computer.
2.  Navigate into the folder using `cd`.
3.  Use `npm install` to download all dependencies.
4.  Add a file called `index.js` at the root of the folder, next to the `package.json` file.
5.  Open the `index.js` file using our favorite code editor.
6.  Add the following code.

    // require the express npm module, needs to be added to the project using "npm install express"
    const express = require('express');

    // creates an express application using the express module
    const server = express();

    // configures our server to execute a function for every GET request to "/"
    // the second argument passed to the .get() method is the "Route Handler Function"
    // the route handler function will run on every GET request to "/"
    server.get('/', (req, res) => {
    // express will pass the request and response objects to this function
    // the .send() on the response object can be used to send a response to the client
    res.send('Hello World');
    });

    // once the server is fully configured we can have it "listen" for connections on a particular "port"
    // the callback function passed as the second argument will run once when the server starts
    server.listen(8000, () => console.log('API running on port 8000'));

**make sure to save your changes to `index.js`.**

We are using the `express` npm module in our code, so we need to add it as a dependency to our project. To do this:

open a terminal/console/command prompt window and navigate to the root of our project. Add express to our `package.json` file by typing `npm install express`.

Now we’re ready to test our API!

In the terminal, still at the root of our project:

type: `npm run server` to run our API. The message _“Api running on port 8000”_ should appear on the terminal. open a web browser and navigate to http://localhost:8000.

There we have it, our first API!

A lot is going on in those few lines of code (only 6 lines if we remove the comments and white space). We will cover every piece of it in detail over the following days, but here is a quick rundown of the most important concepts.

First, we used `require()` to **import** the `express module` and make it available to our application. This is similar to the `import` keyword we have used before. The line `const express = require('express');` is equivalent to `import express from 'express';` if we were using ES2015 syntax.

The following line creates our `Express` application. The return of calling `express()` is an instance of an Express application that we can use to configure our **server** and, eventually, start listening for and responding to requests. Notice we use the word server, not API. An `Express` application is generic, meaning it can be used to serve static content (html, css, audio, video, pdfs and more), dynamically generated web pages, build real-time communications servers, and more. We will use it statically to accept requests from clients and respond with data in JSON format.

An `Express` application publishes a set of methods we can use to configure functions. We are using the `.get()` method to set up a **route handler** function that will run on every `GET` request. As a part of this handler function we specify the URL which will trigger the request. In this case, the URL is the root of the site (represented by a `/`). There are also methods to handle the `POST`, `PUT` and `DELETE` HTTP verbs.

The first two arguments passed by `express` to a route handler function are: 1) an object that represents the `request` and 2) an object that represents the `response`. Express expands those objects with a set of useful properties and methods. Our example uses the `.send()` method of the response object to specify the data sent to the client as the response body. You can call the first two arguments anything you want, but it is very common to see them called `req` and `res`, we at Lambda call them `the homies` as they always hang out together.

That’s all the configuring we need to do for this first example, we’ll see other ways of configuring our server as we go forward.

After configuring the server, it’s time to turn it on. We use the `.listen()` method to monitor a port on the computer for any incoming connections and respond to those we have configured. Our server will only send a response to `GET` requests made to the `/` route on port `8000`.

That’s it for our first Web API, and now it’s time for you to follow along as we add a new **endpoint** to our server that returns `JSON` data!

##### Follow Along

Let’s try returning JSON instead of just a simple string.

Please follow the steps outlined on the overview, but, to save time, copy and paste the content of `index.js` instead of typing it. Then run your API through a browser to make sure it works.

Now follow along as we code a new _endpoint_ that returns an array of movie characters in JSON format.

The first step is to define a new _route handler_ to respond to `GET` requests at the `/hobbits` endpoint.

    server.get('/hobbits', (req, res) => {
      // route handler code here
    });

Next, we define the return data that our endpoint will send back to the client. We do this inside the newly defined route handler function.

    const hobbits = [
      {
        id: 1,
        name: 'Samwise Gamgee',
      },
      {
        id: 2,
        name: 'Frodo Baggins',
      },
    ];

Now we can return the `hobbits` array. We could use `.send(hobbits)` like we did for the string on the `/` endpoint, but this time we’ll learn about two other useful methods we find in the response object.

    res.status(200).json(hobbits);

We should provide as much useful information as possible to the clients using our API. One such piece of information is the `HTTP status code` that reflects the outcome of the operation the client is trying to perform. In this case the client is trying to get a list of a particular `resource`, a list of `hobbits`. Sending back a `200 OK` status code communicates to the client that the operation was successful.

We will see other status codes as we continue to build new endpoints during this week. Still, you can see a list by following [this link to the documentation about HTTP Response Codes on the Mozilla Developer Network site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

The `.status()` method of the response object can be used to send any valid `HTTP status code`.

We are also chaining the `.json()` method of the response object to clearly communicate to both the client making the request and to the next developer working with this code, that we intend to send the data in `JSON format`.

The complete code for `index.js` should now look like so:

    const express = require('express');

    const server = express();

    server.get('/', (req, res) => {
      res.send('Hello World');
    });

    server.get('/hobbits', (req, res) => {
      const hobbits = [
        {
          id: 1,
          name: 'Samwise Gamgee',
        },
        {
          id: 2,
          name: 'Frodo Baggins',
        },
      ];

      res.status(200).json(hobbits);
    });

    server.listen(8000, () => console.log('API running on port 8000'));

Now we can visit `http://localhost:8000/hobbits` in our browser, and we should get back our JSON array.

If you are using the Google Chrome browser, [this extension](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) can format the JSON data in a more readable fashion.

Congratulations! You just built an API that can return data in JSON format.

##### Challenge

Write an endpoint that returns a list of users stored in a database. Return data in `JSON` format.

Production APIs return data coming from a data store or external source, not from an in-memory array like we have done so far.

Your job is to create a new `/users` endpoint that returns the list of users contained in the provided database. To get the list of users, **require** the `/data/db.js` file into `index.js` and use it’s `.find()` method to get the data. The `.find()` method returns a promise, so make sure to send the response after that promise has resolved and, in case of failure, return a status code of 500 and an error message back to the client.

Good luck!

##### Dig Deeper

- [Express Routing Guide](https://expressjs.com/en/guide/routing.html)  
  Routing Guide on Expressjs.com
- [Express Request Object API](https://expressjs.com/en/4x/api.html#req)  
  Express Request Object API Documentation
- [Express Response Object API](https://expressjs.com/en/4x/api.html#res)  
  Express Response Object API Documentation

---

#### Learn to use postman to manually test Web APIs

[Postman](https://www.getpostman.com/) is a very popular tool used to manually test APIs. It comes loaded with a lot of useful features that make testing APIs very easy and painless.

##### Overview

Testing APIs is different from testing websites or web applications. To test the latter, a web browser is sufficient, but for APIs, we need to be able to make POST/PUT/PATCH/DELETE requests and even modify the request headers.

For testing, we will use a tool called `Postman`. Postman, and other tools allow full control when making requests. We can easily change the HTTP Method used, add JSON data to the body, add form data, add headers, examine the response, and more.

In the case of `Postman` you can do a lot more, but we’ll limit our discussion the basics needed to test APIs by passing test data and examining we’re getting the expected response.

We recommend installing the native application for your Operating System.

##### Follow Along

Please follow along as the instructor uses Postman to test an API.

##### Challenge

Use Postman to test the endpoints you have built so far.

##### Dig Deeper

- [Postman Documentation](https://www.getpostman.com/docs/v6/)  
  Postman Documentation Site.

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node API 1 Guided Project Starter Code

Starter Code for Node API 1 Guided Project

[GitHub Repo](https://github.com/LambdaSchool/node-api1-guided)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Node API 1 Project](https://github.com/LambdaSchool/node-api1-project)

  Starter Code for Node API 1 Project

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Intro to Node.js & Express for WebPT18 w/Jason Maurer](https://youtu.be/lu0UMm89Xbg)**

  learn how to manually test our Web API using a tool called Postman.

- [All previous recordings](/archive/FSW/module/recZiPP8Oyg1WlHxT)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Write a paragraph about what `Node.js` is and explain at least 3 of its core features.

  Submit the paragraph to your TL.

- Objective challenge:

  On your own: Write a paragraph about what Express is and explain how it is used in modern web application development.

  Submit your paragraph to your TL.

- Objective challenge:

  Write an endpoint that returns a list of users stored in a database. Return data in `JSON` format.

  Production APIs return data coming from a data store or external source, not from an in-memory array like we have done so far.

  Your job is to create a new `/users` endpoint that returns the list of users contained in the provided database. To get the list of users, **require** the `/data/db.js` file into `index.js` and use it’s `.find()` method to get the data. The `.find()` method returns a promise, so make sure to send the response after that promise has resolved and, in case of failure, return a status code of 500 and an error message back to the client.

  Good luck!

- Objective challenge:

  Use Postman to test the endpoints you have built so far.

- Guided Project: Node API 1 Guided Project Starter Code

- Project: Node API 1 Project

- Code Challenge: ArmstrongNumbers

- Code Challenge: RouteBetweenNodes
