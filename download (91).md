Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

-   [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
-   [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
-   [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
-   [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

-   [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
-   [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
-   [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
-   [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

-   [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
-   [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
-   [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
-   [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

-   [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
-   [React Router II](/webannex/module/recYkF1FDilIedmwX/)
-   [Form Management](/webannex/module/rect081xiYT2cfxGF/)
-   [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

-   [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
-   [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
-   [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
-   [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

-   [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
-   [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
-   [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
-   [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

-   [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
-   [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
-   [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
-   [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

-   [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
-   [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
-   [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
-   [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

-   [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
-   [React Router II](/webannex/module/recYkF1FDilIedmwX/)
-   [Form Management](/webannex/module/rect081xiYT2cfxGF/)
-   [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

-   [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
-   [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
-   [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
-   [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# JavaScript II

<span class="lead"> </span>

Throughout JavaScript II we’re going to be getting more practice with Callbacks as well as dive into a couple of new concepts. By the end of the day you should be familiar with and have the ability to use the following:

-   closure
-   callback functions
-   advanced array methods

**At the end of this module, you should be able to:**

-   describe what closure is, how closure is created in a program and why it is important to understand closures in JavaScript
-   demonstrate the proper use a of a callback function by passing a function to another function as a parameter
-   demonstrate ability to use \`.map\` \`.reduce\` \`.filter\` and describe their use cases

#### Pro Tip

Remember that you and your work are different. A criticism of your work is not a criticism of you as a person. That said, approach criticism or feedback constructively with others.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=AgBoMqDO-08), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=zIRN-Gn8phU), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=YNubYbAhtys), or enable JavaScript if it is disabled in your browser.

-   [MPJ - Closures](https://youtu.be/CQqwU2Ixu-U)

    THE simplest definition of a closure I have ever seen

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe what closure is, how closure is created in a program and why it is important to understand closures in JavaScript

Closure is a big part of the JavaScript language and needs to be discussed through the lens of this statement “What data do I currently have access to in my program”. JS Developers need to know how to access data from within a narrower scope. `Scope` is something that we will touch on later. But for now what you need to know is that `functions create their own scope`

##### Overview

Let’s look at the Window/Console in a browser/node environment. Type `window` to your chrome console. JavaScript is executed in this context, also known as the `global scope`.

There are two types of scope in javascript, `Global Vs. Local` and that this is important to understand in terms of a computer program written in JavaScript.

When a function is declared and created, a new `scope` is also created. Any variables declared within that function’s scope will be `enclosed` in a lexical/private scope that belongs to that function. Also, it is important to remember that functions look `outward` for context. If some variable isn’t defined in a function’s scope, the function will look outside the scope chain and search for a variable being referenced in the outer scope. This is what closure is all about.

In it’s most simplest of forms this is a closure:

    const foo = 'bar';
    function returnFoo () {
      return foo;
    }
    returnFoo();
    // -> reaches outside its scope to find foo because it doesn't exist inside of return Foo's scope when foo is referenced. 

The function body (code inside returnFoo) has access to the outside scope (code outside of returnFoo) and can access that ‘foo’ variable.

Let’s look at another example:

    const lastName = 'Bob';
    function greet() { 
      const firstName = 'Jim';
      alert(`The name's ${lastName}, ${firstName} ${lastName}`);
    }
    console.log(lastName);

Not much different than the idea presented above, but the thought remains the same. When ‘greet’ is called, it has no context in its local scope of finding `lastName` so, it looks outside its scope to find it and use the `lastName` that is found there.

Let’s take this a step further. In the given examples, we’ve seen that we have created two environments for our code. The first would be the global environment where `lastName` and `greet` exist. The second would be the local environment where the alert function is called. Let’s represent those two environments like this:

    { // Global
      lastName String: 'Bob',
      greet Function: { // Local to greet
        firstName String: 'Jim'
      },
      // alert Function: Lives on the global scope, but gets called from with inside greet.
    }

##### Follow Along

Let’s work through one of your problems from your Homework together.

    const counter = () => {
      // Return a function that when invoked increments and returns a counter variable.
      // Example: const newCounter = counter();
      // newCounter(); // 1
      // newCounter(); // 2
    };

##### Challenge

For this challenge you will create your own closure:

-   Create a function that houses 2 nested functions inside of it
-   Create a unique variable for each function you created
-   Test out where you can log the unique variables for each function.

Why can you access variable values in nested functions?

##### Dig Deeper

-   [Deep Dive on Closures](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)  
    Step by step deep dive on closures
-   [Coding Train Closures walkthrough](https://youtu.be/-jysK0nlz7A)  
    Awesome stuff on closures
-   [Simple Closures](http://javascriptissexy.com/understand-javascript-closures-with-ease/)  
    This is an older article, but it is still very good.
-   [Closures](https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44)  
    A great article that explains in depth what closures are

------------------------------------------------------------------------

#### Learn to demonstrate the proper use a of a callback function by passing a function to another function as a parameter

Callback functions come from a programming paradigm known as functional programming (FP). Is not a new paradigm nor is it unique to JavaScript. In fact, many have wondered (due to its dynamic nature) whether JavaScript is an Object Oriented language or a Functional Programming language. The answer to that is simply, both. We get the ability to choose the patterns to use in order to accomplish tasks.

That really is all we’re trying to do here: provide the computer a set of instructions to achieve a task. And the make up of many many tasks simply becomes… software.

At the end of the day, the language isn’t written for the computer, that would be binary. The language we use as developers was written for us, so we as developers get to choose the paradigm we are to use to achieve the task.

So, callback functions are just functions that are passed into other functions as arguments. And the concept is so commonly used throughout the JavaScript language that one day you’ll look back and barely remember a time when you didn’t know how to use them.

##### Overview

You’ll hear these words everywhere: “Functions in JavaScript are first-class citizens.” And if you’re like me, you’ll get puzzled, trying to dissect meaning from those words.

Simply put, this means that functions in JavaScript are a Type like any other Type (Boolean, String, Number), and they can be passed around as arguments to other functions.

Take the following example into consideration:

    const functionFeeder = function(callback) {
      callback('Hello from the inside of Function Feeder');
    };

What we have done here is define a function called `functionFeeder` and passed it a `parameter` called `callback`. So when `functionFeeder` is invoked, we can feed it a function as an argument. That function, in turn, will run the string `Hello from the inside of Function Feeder` back to the callback function it receives. And thus, when we call `functionFeeder` we can handle that string that comes back to us like so:

    functionFeeder((string) => { // invoking the function
      alert(string); // alert a function that pops up a box in the browser.
    });

`functionFeeder` respectively becomes what is known as a `higher-order function` or a `callBack function`, allowing it to take in a function as a parameter and executes a function when called with a function as the argument.

Let’s take a look at a few more examples.

      function sayHello(name) {
        console.log(`Hello, ${name}`);
      }

`sayHello` is a function with one purpose, to say hello to the name that is passed into it. Because we’ve built a function with such a straightforward goal, we can use it over and over again. Once we set up a function that will define the name we want passed to `sayHello`, all we’ll have to do is pass it to our function and let it perform is routine / action.

     function callSayHelloWithLars(callback) {
        const innerName = 'Lars';
        callback(innerName);
      }

The `callback` in the above function will become `sayHello` when we invoke it like this:

     callSayHelloWithLars(sayHello);

And `callSayHelloWithLars` executes `sayHello` as it’s callback.

I could re-use `sayHello` in another context now. Check it out.

    function callSayHelloWithRyan(callback) {
      const newName = 'Ryan';
      callback(newName);
    }

Now let’s combine a few of the things we’ve learned today. I mentioned that callbacks are used everywhere. They’re even used in our Array methods… ALL OF THE TIME! EVERYWHERE! In the case of `.forEach()`, an iterator function, we use a callback to access the items in the array that come back with each pass.

    const items = ['feather', 'coupon', 'cup', 'drill'];

We could use a `native for loop` to loop over this list and log out every item.

    for(let i = 0; i < items.length; i ++) {
      alert(items[i]);
    }

This works for sure! But we have `.forEach` built into the language to allow us not to have to write that every time. So, we could do something like this to clean it up a bit.

    items.forEach(item =>  alert(item) );

**NOTICE** this part is the callback `item => alert(item)`

This is some fancy syntax that we will continue to go over as the week progresses.

##### Follow Along

So now lets practice some things together. First, let’s create a list of elements we want to play around with as our data — literally, elements.

    const elements = ['earth', 'wind', 'fire', 'water'];

Remember that with functions we can pass as many parameters as we want to them. So let’s create a couple of functions that we can use to consume this list of elements.

Create a function called show first that passes back the first item in the given array.

    function showFirst(array, callback) {
      callback(array[0]);
    }
    showFirst(elements, (firstItem) => {
      alert(firstItem);
    });

Create a function like ‘shoFirst’, but this time, show the length of the array passed.

    function showLength(array, callback) {
      callback(array.length);
    }
    showLength(elements, (length) => {
      alert(length);
    });

Now, let’s use `forEach` again to loop over our array and alert each item in the array.

    elements.forEach(element => alert(element));

Remember map? The most significant difference between `.forEach` and `.map` is that `map` returns a new array of elements while in turn passing each element back to the callback.

    const newArray = elements.map(item => 'Element: ' + item);

##### Challenge

Complete the following exercises included here in this JSBin [Callbacks](http://jsbin.com/sadikid/edit?js,console).

##### Dig Deeper

-   [What the heck is a callback?](https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced)  
    Further instruction on callbacks

------------------------------------------------------------------------

#### Learn to demonstrate ability to use \`.map\` \`.reduce\` \`.filter\` and describe their use cases

Earlier on we covered what callbacks are and gave you ample practice to get familiar with their use. Today we’re going to dive deeper and cover some more crucial examples of callback functions as well as get you the reps you need.

The callback is such a fundamental piece of the JavaScript language that you need to have a good grasp of if you want to be able to push your skills further.

##### Overview

In this lesson, we’re going to get a lot of practice playing around with data and transforming it with more loop-like functions. Data transformation, after all, is one of the main goals in our jobs as web engineers since we ultimately display data in some way that makes sense to the end user.

Functional programming is a very fun programming paradigm because it lends itself to this idea of `immutability`. Which is basically creating objects (variables, functions, etc) that can’t be changed by other code later on in a codebase. When we get to Redux, you’ll learn all about immutability, and you’ll have a better grasp of what that concept means by going through some of these exercises today.

First, let’s talk about what functions we have at our disposal to make variables and functions immutable. The `.map` `.filter` and `.reduce` functions are commonly used to achieve immutability and take a set of data and transform it in some way.

Let’s consider the following data set, an array of object literals. You will often see this data type stored in imported `.JSON` files, including in guided practice today. Here though, our data is written inline, which is also fine.

    const data = [
      {"city":"seattle", "state":"WA", "population":652405, "land_area":83.9},
      {"city":"new york", "state":"NY", "population":8405837, "land_area":302.6},
      {"city":"boston", "state":"MA", "population":645966, "land_area":48.3},
      {"city":"kansas city", "state":"MO", "population":467007, "land_area":315}
    ];

Let’s say we want to represent this data in some way that is useful to our users.

### `.map`

`.map` asks us to create an array with just city and state names. We could do this by copying just city and state data into a new array in a `for` loop like so.

    const cityStates = [];
    for(let i = 0; i < data.length; i++) {
      let mappedObj = {};
      mappedObj.city = data[i].city;
      mappedObj.state = data[i].state;
      cityStates.push(mappedObj);
      mappedObj = {};
    }

That works! It’s a simple solution, and simplicity is the gold standard for programming. That said, it’s a bit hard to read, so is there a better way? absolutely!

`.map` is a higher-level function that takes 2 arguments, a callback and a context. The callback is a function to be called “for” each item in the array, the context is the object value(s) to be used. You’ll often people say they are going to “map” some data. That means they are going to apply a set of rules to a data set. For example “mapping” the array `[1,2,3]` times two would result in `[2,4,6]`.

![.map annotated code](https://i.imgur.com/YxcSyFZ.png)

The map function can also take in a callback that passes back a couple of things to us. The three things you’d get back from a callback passed to Map would be:

-   The current item of the array `state`
-   The current index of the current item `index`
-   The entire array `data`

In the example below, the value given in the callback is `state` since task 1 asks us to look at state data.

    const mappedCityStates = data.map((state) => {
      return {'city': state.city, 'state': state.state};
    });

### `.filter`

What if we only want to see states who’s `population is greater than` 650,000? With your prior JavaScript knowledge it might make sense to create something like this:

    const largeStates = [];
    for(let i = 0; i < data.length; i++) {
      if(data[i].population >= 650000) {
        largeStates.push(data[i]);
      }
    }

Now, we can use `.filter` to iterate over all items in the array and return only what we want. This is useful anytime we need a subset of a larger group of data.

*Filter takes exactly the same arguments as .map, namely: value, index, and array.*

    const filterLargeStates = data.filter((state) => {
      return state.population >= 650000;
    });

Same results and cleaner code. The line `return state.population >= 650000;` tells JavaScript to return an object whose population is higher than 650,000, and in turn, pass that object to a new array. The other objects (states with a population lower than 650,000) will be ignored since they don’t pass this logic test. Think of that line reading like this: `IF state.population is greater than or equal to 650000 THEN push it into a new array ELSE do nothing`.

### `.reduce`

Reduce is slightly tricker than `.map` and `.filter` because it requires use of different arguments. Its powers though, are endless. Essentially, reduce works to algorithmically simplify an array down to a single value.

Let’s say we want a single number of all of the state’s populations added together. With the most basic JavaScript we might do something like this.

    let statePopulations = 0;
    for(let i = 0; i < data.length; i++) {
      statePopulations += data[i].population;
    }

This is a relatively simple algorithm, but let’s look at it in terms of the reduce function now. `.reduce` allows us to reduce all data to a single value. It is a perfect use here because we can aggregate that data and use `.reduce` to do so for us.

    const reduceStatePopulations = data.reduce((total, state) => {
      return total += state.population;
    }, 0);

This is more succinct, but a lot is going on here. Importantly, we pass `0` as a second argument to our reduce function. This argument will become the starting value of our `total` and, if not provided, would default to the first item in the array. In this case, that would be disastrous because the first item of our array is an object, and we’re trying to reduce our total to a single numerical value. Instead, we can provide a starting value for `total` and thus set what our data type will reduce to. Remember that total also gets `memorized` or remembered by our function each pass.

![Screen Shot 2019-12-03 at 11.34.39 AM](https://i.imgur.com/ju1Ooqu.png)

*Note, the function will run without the `0` pictured above, but will default to starting accumulation at the first number in the array, which often doesn’t make sense*

The four items that get passed back from our callback function when using `.reduce` are:

-   The current value of the total aggregated value.
-   We set the initial value at the end of the function. In this case, we set it to 0.
    -   This could be any value, though.
-   The current item in the array.
-   The index again.
-   The full array.

To sum up. These functions are fantastic and allow us to write clean, reusable code in a functional programming style. They give us the power to represent our data in an enjoyable way. As you get more and more used to using these functions, you’ll get the ability to use them in very complex situations that will eventually save your bacon. For now, let’s go practice. Check out the challenge on JSBin. Go play around and see if you can create some new data sets out of the provided data.

##### Follow Along

Let’s take our same Data Set from earlier and play around with it some more.

    const data = [
      {"city":"seattle", "state":"WA", "population":652405, "land_area":83.9},
      {"city":"new york", "state":"NY", "population":8405837, "land_area":302.6},
      {"city":"boston", "state":"MA", "population":645966, "land_area":48.3},
      {"city":"kansas city", "state":"MO", "population":467007, "land_area":315}
    ];

1.  Use `.map` to create an array of integers that represent all the states names and populations.

The callback function here is what’s enclosed in the `return` function. `state` is the value, or element(s) that will be processed.

    const mappedCityStates = data.map((state) => {
      return {'state': state.state, 'population': state.population};
    });

1.  Use `.filter` to create an array of states who’s land\_area is larger than 50 units. Just like with map, we use arrow function syntax to dictate a `return`. Similarly, `state` is the value, or element(s) that will be processed.

    const filterLandArea = data.filter((state) => {
      return state.land_area >= 50;
    });

1.  Use `.reduce` to create an array of the states land\_area reduced to the `mean average` of all the state’s combined.This example uses similar parameters, only adds the counter `total` to accumulate the sum.

    const landAreaAverage = data.reduce((total, state) => {
      let sum = total + state.land_area;
      console.log(sum, total, state);
      return sum;
    }, 0);
    const average = landAreaAverage / data.length;

##### Challenge

Complete the following exercises using `.map`, `.filter`, `.reduce`.

[Code found here](http://jsbin.com/wolayeb/edit?js,console)

##### Dig Deeper

-   [Functional Programming in JavaScript](https://opensource.com/article/17/6/functional-javascript)  
    An in depth guide covering the functional programming paradigm in JavaScript.
-   [.map() .reduce() .filter()](https://hackernoon.com/understanding-map-filter-and-reduce-in-javascript-5df1c7eee464)  
    A beautiful description of these methods and their uses

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [JavaScript-II](https://github.com/LambdaSchool/JS-Exercise-Closures-Callbacks-ArrayMethods)

    With some basic JavaScript principles we can now expand our skills out even further by exploring array methods like: `.forEach()`, `.map()`, `.reduce()`, and `.filter()`. We can also look at how closures have a large impact on how we write JavaScript.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[JavaScript II for WEBPT17 w/ Pace Ellsworth](https://youtu.be/Ix8Uk0JlRUk)**

    Lesson on closures, callbacks, and array methods

-   [All previous recordings](/archive/FSW/module/rec1oaBmEoSilO2yf)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    For this challenge you will create your own closure:

    -   Create a function that houses 2 nested functions inside of it
    -   Create a unique variable for each function you created
    -   Test out where you can log the unique variables for each function.

    Why can you access variable values in nested functions?

-   Objective challenge:

    Complete the following exercises included here in this JSBin [Callbacks](http://jsbin.com/sadikid/edit?js,console).

-   Objective challenge:

    Complete the following exercises using `.map`, `.filter`, `.reduce`.

    [Code found here](http://jsbin.com/wolayeb/edit?js,console)

-   Project: JavaScript-II
