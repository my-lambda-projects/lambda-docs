


<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

-   [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
-   [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

-   [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
-   [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
-   [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
-   [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

-   [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
-   [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
-   [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
-   [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

-   [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
-   [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
-   [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
-   [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

------------------------------------------------------------------------

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

-   [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
-   [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

-   [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
-   [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
-   [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
-   [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

-   [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
-   [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
-   [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
-   [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

-   [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
-   [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
-   [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
-   [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

------------------------------------------------------------------------

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Java - Read Data using CRUD Operations

<span class="lead"> </span>

<span id="Read_Data_using_CRUD_Operation"></span>

**At the end of this module, you should be able to:**

-   perform CRUD operations on an RDBMS using JPA and Hibernate (reading)
-   use JPA constructs to create advanced queries
-   use the JsonIgnoreProperties annotation to prevent infinite loops
-   use SQL, JPA and Hibernate to perform custom query operations on a RDBMS through a Spring Application

#### Pro Tip

When raising a problem with a supervisor, provide potential solutions to the problem.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to perform CRUD operations on an RDBMS using JPA and Hibernate (reading)

<span id="CRUD_Reading"></span>

##### Overview

-   See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)tt for the code used in the objective.

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   JetBrains IntelliJ IDEA IDE
-   Postman

### Review of CRUD

CRUD are the functions that will be done by our application. They are, with their corresponding HTTP Method:

<table><thead><tr class="header"><th>Letter</th><th>CRUD</th><th>Http Method</th></tr></thead><tbody><tr class="odd"><td>C</td><td>Create</td><td>POST</td></tr><tr class="even"><td>R</td><td>Read</td><td>GET</td></tr><tr class="odd"><td>U</td><td>Update</td><td>PUT, PATCH</td></tr><tr class="even"><td>D</td><td>Delete</td><td>DELETE</td></tr></tbody></table>

##### Follow Along

Now let’s enter some of the code continuing adding to the sample employees application you began in the last module. The finished application for this module can be found at [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)t

-   Under the subpackage `controllers`
    -   add to the class `EmployeeController`
    -   Enter the following code in that class
    -   Entering the comments is optional
    -   Try not entering the imports. Let IntelliJ do that for you
-   Note
    -   we are adding GET mappings, routes to the controller, hence the annotation GetMapping.
    -   GetMapping takes a parameter, the route, which is called `value`
    -   Spring ties together the GetMapping to the Java method that follows the GetMapping

<!-- -->

    package com.lambdaschool.sampleemps.controllers;

    import com.lambdaschool.sampleemps.models.Employee;
    import com.lambdaschool.sampleemps.services.EmployeeService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import java.util.List;

    @RestController
    @RequestMapping("/employees") // optional
    public class EmployeeController
    {
        @Autowired
        private EmployeeService employeeService;

        @GetMapping(value = "/employees")
        public ResponseEntity<?> listAllEmployees()
        {
            List<Employee> myEmployees = employeeService.findAllEmployees();
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }

        @GetMapping(value = "/employeename/{subname}")
        public ResponseEntity<?> listEmployeesWithName(
            @PathVariable
                String subname)
        {
            List<Employee> myEmployees = employeeService.findEmployeeNameContaining(subname);
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }

        @GetMapping(value = "/employeeemail/{subemail}")
        public ResponseEntity<?> listEmployeesWithEmail(
            @PathVariable
                String subemail)
        {
            List<Employee> myEmployees = employeeService.findEmployeeEmailContaining(subemail);
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }
    }

Now we need to update the service for the Employee Model

-   Under the subpackage `services`
    -   add to the class `EmployeeService`
    -   Enter the following code in that class

<!-- -->

    package com.lambdaschool.sampleemps.services;

    import com.lambdaschool.sampleemps.models.Employee;

    import java.util.List;

    public interface EmployeeService
    {
        List<Employee> findAllEmployees();

        List<Employee> findEmployeeNameContaining(String subname);

        List<Employee> findEmployeeEmailContaining(String subemail);

        Employee save(Employee employee);
    }

-   Under the subpackage `services`
    -   add to the class `EmployeeServiceImpl`
    -   Enter the following code in that class

<!-- -->

    package com.lambdaschool.sampleemps.services;

    import com.lambdaschool.sampleemps.models.Employee;
    import com.lambdaschool.sampleemps.repositories.EmployeeRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.util.ArrayList;
    import java.util.List;

    @Service(value = "employeeSerivce") // needed to name this implementation as the service to use
    public class EmployeeServiceImpl
            implements EmployeeService // notice the Impl for implementing a service
    {
        @Autowired
        private EmployeeRepository employeerepos;

        @Override
        public List<Employee> findAllEmployees()
        {
            List<Employee> list = new ArrayList<>();
            /*
             * findAll returns an iterator set.
             * iterate over the iterator set and add each element to an array list.
             */
            employeerepos.findAll()
                    .iterator()
                    .forEachRemaining(list::add);
            return list;
        }

        @Override
        public List<Employee> findEmployeeNameContaining(String subname)
        {
            return employeerepos.findByNameContainingIgnoreCase(subname);
        }

        @Override
        public List<Employee> findEmployeeEmailContaining(String subemail)
        {
            return employeerepos.findByEmails_EmailContainingIgnoreCase(subemail);
        }
        
        @Transactional
        @Override
        public Employee save(Employee employee)
        {
            return employeerepos.save(employee);
        }
    }

We are not ready to test out the application. In fact at this point, the application does not compile. We need to make some updates to the Employee Repository for the application to work. Stay tuned!!!

##### Dig Deeper

-   [CRUD, Spring Boot, PostgreSQL](https://www.callicoder.com/spring-boot-jpa-hibernate-postgresql-restful-crud-api-example/)  
    Callicoder - Spring Boot, PostgreSQL, JPA, Hibernate RESTful CRUD API Example

------------------------------------------------------------------------

#### Learn to use JPA constructs to create advanced queries

<span id="Querying_using_JPA_Constructs"></span>

##### Overview

-   See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   JetBrains IntelliJ IDEA IDE
-   Postman

### Querying the database

Getting data from the database is called Querying the database. Normally we want a subset of the available data which we specify with some search conditions. We say how we want to filter the data. The best way to do this is by using Java Spring Data Java Persistence API, the JPA. Note that the JPA does exist outside of Java Spring Data. However, when combined with Spring Data and Hibernate, the JPA really shines. The queries that are produced through Java Spring Data JPA are highly efficient. Many man hours have gone into making these queries good so let’s take advantage of that!

We can access to the Spring Data JPA when we create the repository connecting our Java application to our database. For example, the `CrudRepository` interface gives us access to the Spring Data JPA. Notice that we are creating an interface extending an interface. Note that an interface can extend another interface just like a class can extend another class.

    public interface EmployeeRepository extends CrudRepository<Employee, Long>
    {
    }

By default we have access to many standard querying methods. These include:

<table><thead><tr class="header"><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>long</td><td>count()</td><td>Returns the number of records</td></tr><tr class="even"><td>boolean</td><td>existsById (long id)</td><td>Returns whether a record with the given id exists</td></tr><tr class="odd"><td>Iterable&lt; T &gt;</td><td>findAll()</td><td>Returns an iterable list of all objects in the table</td></tr><tr class="even"><td>Iterable&lt; T &gt;</td><td>findAllById (Iterable&lt; long &gt; ids)</td><td>Returns an iterable list of all objects in the table with the ids found in the given list</td></tr><tr class="odd"><td>Optional&lt; T &gt;</td><td>findById(long id)</td><td>Returns an optional of the record with the given id</td></tr></tbody></table>

Also included by default are data manipulation methods:

<table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>void</td><td>delete (T object)</td><td>deletes the given object from the table</td></tr><tr class="even"><td>void</td><td>deleteAll()</td><td>deletes all records in the table</td></tr><tr class="odd"><td>void</td><td>deleteAll(Iterable&lt;? extends T&gt; objects)</td><td>deletes the objects in the iterable list from the table</td></tr><tr class="even"><td>void</td><td>deleteById(Long id)</td><td>deletes the record with the given primary key id</td></tr><tr class="odd"><td>Object</td><td>save (S object)</td><td>The record is saved or updated based on the presence of the primary key.<br />
If no primary key is given, one is generated and the record is added to the database.<br />
If a primary key is given and the primary key exists in the database, the record with that primary key is replaced.<br />
If a primary key is given and the primary key does not exists in the database, the record is added to the database with that primary key<br />
The object is returned including any generated primary key</td></tr><tr class="even"><td>Iterable &lt; S &gt;</td><td>saveAll(Iterable&lt;? extends T&gt; objects)</td><td>All records in the iterable list are added or updated based on the presence of the primary key.<br />
The primary key is handled as in the save method.<br />
An iterable list is returned with all the saved objects including any generated primary keys.</td></tr></tbody></table>

These we can use directly in our services. For example, the following code from the EmployeeServiceImpl class, returns a list of all records in the employee table

        public List<Employee> findAllEmployees()
        {
            List<Employee> list = new ArrayList<>();
            /*
             * findAll returns an iterator set.
             * iterate over the iterator set and add each element to an array list.
             */
            employeerepos.findAll().iterator().forEachRemaining(list::add);
            return list;
        }

However, we can add an almost unlimited number of highly efficient queries by exposing other methods. For example, we can search for employees whose name contains a given substring and in the process we want the search to be case insensitive, then we expose another method in our repository:

    public interface EmployeeRepository extends CrudRepository<Employee, Long>
    {
        List<Employee> findByNameContainingIgnoreCase(String subname);
    }

We can then set up to use this method from our repository in our service interface:

    public interface EmployeeService
    {
        <... other code ...>
        List<Employee> findEmployeeNameContaining(String subname);
    }

And finally use the method in our service interface implementation:

        @Override
        public List<Employee> findEmployeeNameContaining(String subname)
        {
            return findEmployeeNameContaining(subname);
        }

And of course to access it the appropriate code will need to be added to the Employee Controller

        @GetMapping(value = "/employeename/{subname}")
        public ResponseEntity<?> listEmployeesWithName(
            @PathVariable
                String subname)
        {
            List<Employee> myEmployees = employeeService.findEmployeeNameContaining(subname);
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }

Here is a break down of what got included in the exposed methods name. We MUST name our methods using these keywords and field names. Field names start with a capital letter and followed by lowercase letters (We know this because we ALWAYS make our field names all lowercase in our models).

<table><thead><tr class="header"><th>Action</th><th>findBy</th><th>data</th><th>filters</th></tr></thead><tbody><tr class="odd"><td>The format is</td><td>findBy</td><td>&lt; FieldName(s) with optional AND, OR &gt;</td><td>&lt; Qualifiers &gt;</td></tr><tr class="even"><td>yielding</td><td>findBy</td><td>Employee</td><td>ContainingIgnoreCase</td></tr></tbody></table>

This table is taken from the Spring IO JPA Query Creation link found in the Additional Resources and gives all the available keywords!

![JPA Keyword Table](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-06.png)

Advanced topic: We can include field names from other tables as well. Let’s say we want to search for employees whose email contains a given substring, for example a certain domain. We can now expose a method in the employee repository as follows:

    public interface EmployeeRepository extends CrudRepository<Employee, Long>
    {
        <... other code ...>

        List<Employee> findByEmails_EmailContainingIgnoreCase(String subemail);
    }

Notice we gave the field name representing the other table `Emails` followed by `_` followed by the field name from the other table `Email`!

Now we can set this up in our service interface

    public interface EmployeeService
    {
        <... other code ...>

        List<Employee> findEmployeeEmailContaining(String subemail);
    }

Implement it in the service interface implementation

        @Override
        public List<Employee> findEmployeeEmailContaining(String subemail)
        {
            return employeerepos.findByEmails_EmailContainingIgnoreCase(subemail);
        }

And access it from the Employee Controller

        @GetMapping(value = "/employeeemail/{subemail}")
        public ResponseEntity<?> listEmployeesWithEmail(
            @PathVariable
                String subemail)
        {
            List<Employee> myEmployees = employeeService.findEmployeeEmailContaining(subemail);
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }

Many great possibilities exist using JPA querying methods. Do explore this great tool!

##### Follow Along

We need to finish creating our code started in Objective 1 CRUD Reading and worked on in the following objectives. So, let’s add some code.

-   Under the subpackage `repositories`
    -   Create the class `EmployeeRepository`
    -   Enter the following code in that class
    -   Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.repositories;

    import com.lambdaschool.sampleemps.models.Employee;
    import org.springframework.data.repository.CrudRepository;

    import java.util.List;

    public interface EmployeeRepository
        extends CrudRepository<Employee, Long>
    {
        List<Employee> findByNameContainingIgnoreCase(String subname);

        List<Employee> findByEmails_EmailContainingIgnoreCase(String subemail);
    }

Now the sample employees application should work. Run the application and try out endpoints!

-   http://localhost:2019/employees/employees/
-   http://localhost:2019/employees/employeename/barn
-   http://localhost:2019/employees/employeeemail/barn

Okay, we still have one small issue. You end up with infinite loops on your Gets. Let’s fix those now.

Do refer to the GitHub repo for more information on the application! See [https://github.com/LambdaSchool/java-sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)t

##### Dig Deeper

-   [CrudRepository](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html)  
    Official Documentation for the CrudRepository class
-   [JPA Reference](https://docs.spring.io/spring-data/jpa/docs/2.2.3.RELEASE/reference/html/#preface)  
    Spring IO JPA Reference
-   [JPA Query](https://docs.spring.io/spring-data/jpa/docs/2.2.3.RELEASE/reference/html/#jpa.query-methods.query-creation)  
    Spring IO JPA Query Creation

------------------------------------------------------------------------

#### Learn to use the JsonIgnoreProperties annotation to prevent infinite loops

<span id="JsonIgnoreProperties"></span>

##### Overview

-   See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)tt for the code used in the objective.

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   JetBrains IntelliJ IDEA IDE
-   Postman

### The Problem

Without some intervention, our responses will end up in infinite loops constantly requesting information. This happens any time we have relationships: `@ManyToMany`, `@OneToMany`, `@ManyToOne`, `@OneToOne`, any relationships!

Let’s look at an example: the One To Many relationship between Employee and Email

To represent this relationship, in the `Employee` model we have

        @OneToMany(mappedBy = "employee",
                cascade = CascadeType.ALL,
                orphanRemoval = true)
        private List<Email> emails = new ArrayList<>();

To represent this relationship, in the `Email` model we have

        @ManyToOne
        @JoinColumn(name = "employeeid",
                nullable = false)
        private Employee employee;

If we run the application as it stands, our output results in an infinite loop. Expand the following to see an example of this data

http://localhost:2019/employees/employees


    [
        {
            "employeeid": 1,
            "name": "CINNAMON",
            "emails": [
                {
                    "emailid": 1,
                    "email": "[email protected]",
                    "employee": {
                        "employeeid": 1,
                        "name": "CINNAMON",
                        "emails": [
                            {
                                "emailid": 1,
                                "email": "[email protected]",
                                "employee": {
                                    "employeeid": 1,
                                    "name": "CINNAMON",
                                    "emails": [
                                        {
                                            "emailid": 1,
                                            "email": "[email protected]",
                                            "employee": {
                                                "employeeid": 1,
                                                "name": "CINNAMON",
                                                "emails": [
                                                    {
                                                        "emailid": 1,
                                                        "email": "[email protected]",
                                                        "employee": {
                                                            "employeeid": 1,
                                                            "name": "CINNAMON",
                                                            "emails": [
                                                                {
                                                                    "emailid": 1,
                                                                    "email": "[email protected]",
                                                                    "employee": {
                                                                        "employeeid": 1,
                                                                        "name": "CINNAMON",

    <... continues ...>

What is happening

-   An Employee’s data gets displayed. Part of this display is list of Emails
    -   Thus an Email object gets printed. The Email object includes an Employee Object
-   Thus an Employee’s data gets displayed. Part of this display is list of Emails
    -   Thus an Email object gets printed. The Email object includes an Employee Object
-   Thus an Employee’s data gets displayed. Part of this display is list of Emails
    -   Thus an Email object gets printed. The Email object includes an Employee Object
-   And so and so for ever

Somehow we need to stop the cycle!

### The Solution

Here is what we do.

-   When we are printing an Employee and say to display the Email, don’t display the Employee again in the Email Object. Notice that this is the `employee` field.
-   When we are printing an Email and say to display the Employee, don’t display the Email again in the Employee Object. Notice that this is the `emails` field.
-   When we are setting the data, getting it in from a client, the client is smart enough to not send unlimited data so we can allow for getting data in - allowsetters. We do not allow data going out - no allowgetters.

We do this by using the annotation `@JsonIgnoreProperties` as follows:

In the `Employee` model we update the One To Many with the `@JsonIgnoreProperties("employee", )` annotation

        @OneToMany(mappedBy = "employee",
                cascade = CascadeType.ALL,
                orphanRemoval = true)
        @JsonIgnoreProperties("employee")
        private List<Email> emails = new ArrayList<>();

In the `Email` model we update the Many to One relationship with the `@JsonIgnoreProperties("emails")`. And we only want to ignore property when we are reading the data.

        @ManyToOne
        @JoinColumn(name = "employeeid",
                nullable = false)
        @JsonIgnoreProperties("emails")
        private Employee employee;

Notice that we are telling JSON to ignore the field of the current model when printing the other model. For example inside the Employee model, we annotate `@JsonIgnoreProperties` with the Employee field. Also notice that we name the field using the field name from the other model. Thus in the Employee model we say to ignore the employee object called `employee`. In the Email model we say to ignore the list of emails `emails`.

Thus we now have this complete output

http://localhost:2019/employees/employees


    [
        {
            "employeeid": 1,
            "name": "CINNAMON",
            "emails": [
                {
                    "emailid": 1,
                    "email": "[email protected]"
                },
                {
                    "emailid": 2,
                    "email": "[email protected]"
                }
            ],
            "jobtitles": [
                {
                    "jobtitleid": 1,
                    "title": "Big Boss"
                },
                {
                    "jobtitleid": 2,
                    "title": "Wizard"
                }
            ]
        },
        {
            "employeeid": 2,
            "name": "BARNBARN",
            "emails": [
                {
                    "emailid": 3,
                    "email": "[email protected]"
                }
            ],
            "jobtitles": [
                {
                    "jobtitleid": 2,
                    "title": "Wizard"
                }
            ]
        },
        {
            "employeeid": 3,
            "name": "JOHN",
            "emails": [],
            "jobtitles": []
        }
    ]

You will need to do something similar for each relationship in your application.

Note:

-   `JsonIgnoreProperties` works great for ending this recursive cycle of reporting
-   If you wish to ignore a specific field in a class, you do not want a specific field to be displayed to the client, for example someone’s password, you would use the annotation `JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`
    -   This allows to write a new password but not display it!
    -   We will see this in action later in the course.

##### Follow Along

Let’s add the `JsonIgnoreProperties` to each one of our relationships.

-   Under the subpackage `models`
    -   in the class `Employee`
    -   add the JsonIgnoreProperties to the relationships for
        -   Job titles
        -   Emails

<!-- -->

        @ManyToMany()
        @JoinTable(name = "employeetitles",
                joinColumns = @JoinColumn(name = "employeeid"),
                inverseJoinColumns = @JoinColumn(name = "jobtitleid"))
        // we want to ignore, not display, the employees collection found in JobTitle
        @JsonIgnoreProperties(value = "employees")
        Set<JobTitle> jobtitles = new HashSet<>();

        @OneToMany(mappedBy = "employee",
                cascade = CascadeType.ALL,
                orphanRemoval = true)
        // we want to ignore, not display, the employee object found in Email
        @JsonIgnoreProperties(value = "employee")
        private List<Email> emails = new ArrayList<>();

-   Under the subpackage `models`
    -   in the class `Email`
    -   add the JsonIgnoreProperties to the relationship for
        -   employee

<!-- -->

        @ManyToOne
        @JoinColumn(name = "employeeid",
            nullable = false)
        // we want to ignore, not display, the emails collection from Employee
        @JsonIgnoreProperties("emails")
        private Employee employee;

-   Under the subpackage `models`
    -   in the class `JobTitle`
    -   add the JsonIgnoreProperties to the relationship for
        -   JobTitle

<!-- -->

        @ManyToMany(mappedBy = "jobtitles")
        // we want to ignore, not display, the jobtitles collection from Employee
        @JsonIgnoreProperties("jobtitles")
        private Set<Employee> employees = new HashSet<>();

***Now*** the sample employees application should work. Run the application and try out endpoints!

-   http://localhost:2019/employees/employees/
-   http://localhost:2019/employees/employeename/barn
-   http://localhost:2019/employees/employeeemail/barn

Do refer to the GitHub repo for more information on the application! See [https://github.com/LambdaSchool/java-sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)

##### Dig Deeper

-   [JPA and Hibernate Circular References](https://hellokoding.com/handling-circular-reference-of-jpa-hibernate-bidirectional-entity-relationships-with-jackson-jsonignoreproperties/)  
    JPA and Hibernate Circular References/Dependencies Handling Example with Jackson \`JsonIgnoreProperties\`
-   [Jackson](https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype)  
    Jackson @JsonIgnore, @JsonIgnoreProperties and @JsonIgnoreType

------------------------------------------------------------------------

#### Learn to use SQL, JPA and Hibernate to perform custom query operations on a RDBMS through a Spring Application

<span id="Querying_using_SQL"></span>

##### Overview

-   See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   JetBrains IntelliJ IDEA IDE
-   Postman

Sometimes we wish to send our clients data that can’t be gotten easily using JPA constructs. Maybe we need more advanced filtering, different types of tables joins, aggregations function, and the like. These call for writing our own custom SQL to query the database and extra the data we want. Let’s do a custom query!

We want to include an endpoint in our application that will return a list of employees with a count of how many job titles they have. To do this we will write a custom query. Let’s start with the query itself, fairly straightforward SQL with a count function. We are using a left join to include all employees, even those without job titles. We are giving specific names to each column. We will be using those in our application.

    SELECT e.name as employee_name,
           count(et.employeeid) as count_job_titles
    FROM employees e
    LEFT JOIN employeetitles et
    ON e.employeeid = et.employeeid
    GROUP BY e.name

##### Follow Along

Let’s add a custom query to the sample employees application. The finished application can be found at [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps\_read](https://github.com/LambdaSchool/java-sampleemps.git)

Now let’s add the query to our Spring Application. The query will go into the appropriate Repository using a `@Query` annotation. Since this report is about employees, I will put the query in the repository.EmployeeRepository class. The complete new class is shown below with the new query added at the bottom.

    package com.lambdaschool.sampleemps.repositories;

    import com.lambdaschool.sampleemps.models.Employee;
    import org.springframework.data.repository.CrudRepository;

    import java.util.List;

    public interface EmployeeRepository
        extends CrudRepository<Employee, Long>
    {
        List<Employee> findByNameContainingIgnoreCase(String subname);

        List<Employee> findByEmails_EmailContainingIgnoreCase(String subemail);

        @Query(value = "SELECT e.name as employee_name, count(et.employeeid) as count_job_titles FROM employees e LEFT JOIN employeetitles et ON e.employeeid = et.employeeid GROUP BY e.name",
            nativeQuery = true)
        List<EmpNameCountJobs> getCountEmpJobs();
    }

Some notes on the new query

-   `@Query` is the notation that says we are doing a query. Makes sense. By default, query can only read, and not manipulate, data.
    -   `@Query` takes some attributes
        -   `value` is the actual query in String form. Yes, the query has to be all on one line!
        -   `nativeQuery = true` means the query will be using the actual database names of things. A preference of mine.
            -   native queries are usually faster
            -   can lose portability to other databases if care is not taken in naming conventions, which of course we do take care in class!
    -   The Query returns a List of some class, `EmpNameCountJobs`, we have yet to define and is invoked by calling the method `getCountEmpJobs()`

Now, let’s create that class `EmpNameCountJobs`. This class is necessary for the Jackson Dependency, which is managed by Spring Boot, to convert our list into JSON.

-   Create New Package called `views`
    -   Right click on the package `sampleemps`
        -   Select `New` -> `Package`
        -   enter `views` at the end of the main package name.
-   Now we need to create the class.
    -   Under the package `views`, create a new Java Class
        -   It is an interface
        -   Name it `EmpNameCountJobs`
-   We have to be very careful with the names of our methods. Specific names are needed for the Spring Framework to properly generate the JSON.
    -   Naming is `getFieldname`. The word `get` followed by the field name starting with a capital letter followed by all lowercase.
    -   This only works if you have kept all field names lowercase as recommended!
    -   This is why we put aliases on each of our columns in the query. We need to know the exact names of the columns!
-   Following those recommendations, you get the following code. Notice that our report, our custom query, has two columns and our interface has two corresponding methods! Order does not matter; naming does!!!

<!-- -->

    package com.lambdaschool.sampleemps.views;

    public interface EmpNameCountJobs
    {
        String getEmployee_name();
        int getCount_job_titles();
    }

Now let’s use our new query. We use like we use any regular read method from our repository. We make a service call and a controller method for our clients!

-   Additions to services.EmployeeService

<!-- -->

    /* ... other code ... */
        List<EmpNameCountJobs> getEmpNameCountJobs();
    /* ... other code ... */

-   Additions to services.EmployeeServiceImpl

<!-- -->

    /* ... other code ... */
        @Override
        public List<EmpNameCountJobs> getEmpNameCountJobs()
        {
            return employeerepos.getCountEmpJobs();
        }
    /* ... other code ... */

-   Additions to controllers.EmployeeController

<!-- -->

    /* ... other code ... */
        @GetMapping(value = "/job/counts")
        public ResponseEntity<?> getEmpJobCounts()
        {
            List<EmpNameCountJobs> myEmployees = employeeService.getEmpNameCountJobs();
            return new ResponseEntity<>(myEmployees,
                HttpStatus.OK);
        }
    /* ... other code ... */

And now we can generate the following JSON!

http://localhost:2019/employees/job/counts


    [
        {
            "employee_name": "Adena Jones",
            "count_job_titles": 0
        },
        {
            "employee_name": "Apryl Brekke",
            "count_job_titles": 0
        },
        {
            "employee_name": "Argentina Homenick",
            "count_job_titles": 0
        },
        {
            "employee_name": "BARNBARN",
            "count_job_titles": 1
        },
        {
            "employee_name": "Brant Brown",
            "count_job_titles": 0
        },
        {
            "employee_name": "CINNAMON",
            "count_job_titles": 2
        },
        {
            "employee_name": "Clint Mertz Jr.",
            "count_job_titles": 0
        },
        {
            "employee_name": "Curtis Marquardt",
            "count_job_titles": 0
        },
        {
            "employee_name": "Donte Kling",
            "count_job_titles": 0
        },
        {
            "employee_name": "Emile Volkman",
            "count_job_titles": 0
        },
        {
            "employee_name": "Enda Walker",
            "count_job_titles": 0
        },
        {
            "employee_name": "Fermin Hermiston",
            "count_job_titles": 0
        },
        {
            "employee_name": "JOHN",
            "count_job_titles": 1
        },
        {
            "employee_name": "Josphine Wisozk",
            "count_job_titles": 0
        },
        {
            "employee_name": "Lauri Kuvalis",
            "count_job_titles": 0
        },
        {
            "employee_name": "Leonel Lowe DVM",
            "count_job_titles": 0
        },
        {
            "employee_name": "Lia Dach III",
            "count_job_titles": 0
        },
        {
            "employee_name": "Luigi Schmidt",
            "count_job_titles": 0
        },
        {
            "employee_name": "Lynwood Hessel",
            "count_job_titles": 0
        },
        {
            "employee_name": "Mohammad Leuschke",
            "count_job_titles": 0
        },
        {
            "employee_name": "Mrs. Eula Barton",
            "count_job_titles": 0
        },
        {
            "employee_name": "Noma Borer",
            "count_job_titles": 0
        },
        {
            "employee_name": "Ralph Stiedemann",
            "count_job_titles": 0
        },
        {
            "employee_name": "Reginald Ferry",
            "count_job_titles": 0
        },
        {
            "employee_name": "Russell Hilpert",
            "count_job_titles": 0
        },
        {
            "employee_name": "Theo Borer V",
            "count_job_titles": 0
        },
        {
            "employee_name": "Traci Mueller",
            "count_job_titles": 0
        },
        {
            "employee_name": "Tristan Kemmer",
            "count_job_titles": 0
        }
    ]

##### Dig Deeper

-   [Spring Data JPA Tutorial Part Three: Custom Queries with Query Methods - dated but good](https://www.petrikainulainen.net/programming/spring-framework/spring-data-jpa-tutorial-three-custom-queries-with-query-methods/)  
-   [Baeldung: Customizing the Result of JPA Queries with Aggregation Functions](https://www.baeldung.com/jpa-queries-custom-result-with-aggregation-functions)  
-   [Ultimate Guide: Custom Queries with Spring Data JPA’s @Query Annotation](https://thoughts-on-java.org/spring-data-jpa-query-annotation/)  
-   [Spring Data JPA Custom Queries using @Query Annotation](https://attacomsian.com/blog/spring-data-jpa-query-annotation)  

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### crudyrestaurants\_read

Using restaurants with menus as our model, we explore CRUD operations related to reading data working towards the crudyrestaurants\_read application found in the repo

[GitHub Repo](https://github.com/LambdaSchool/java-crudyrestaurants.git)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Java Get Orders](https://github.com/LambdaSchool/java-getorders.git)

    This is part 2 of a 3 part series. In the first part you are tasked with setting up the database model in a Java Spring Application. In the second part you are tasked with adding Get routes to the application.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Java Read Data Using CRUD operations for WEB33 with John Mitchell](https://youtu.be/VPrFOQ3vcJY)**
-   [All previous recordings](/archive/WEB4Java/module/rec3THcdjv8BumGCt)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Guided Project: crudyrestaurants\_read
-   Project: Java Get Orders
