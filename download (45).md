

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Database Schema Design

<span class="lead"> </span>

In this module we’ll learn how to create schemas using both SQLite Studio and Knex.

On this lecture we will cover the following topics:

-   Database Management Systems (DBMS)
-   SQLite studio
-   Primary keys
-   Data Types and Column Constraints
-   Knex CLI
-   Migrations
-   Seeds

**At the end of this module, you should be able to:**

-   use SQLite Studio on an existing database
-   explain what is a database schema
-   create and use knex migrations
-   create and use knex seeds

#### Pro Tip

Be on time. It’s a mark of respect not to keep others waiting.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=8BwFOpLpzoE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=GASfty6-KsE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=21Vpcup6LwM), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=tZJUXxYFScU), or enable JavaScript if it is disabled in your browser.

-   [Knex](https://knexjs.org/)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to use SQLite Studio on an existing database

Query builders like Knex.js allow developers to write modular javascript code to execute SQL commands and thus interact with the database

##### Overview

SQLlite Studio is an application that allows us to create, open, view, and modify SQLite databases. To fully understand what SQLite Studio is and how it works, we must also understand the concept of the Database Management Systems (DBMS).

##### Follow Along

### What is a DBMS?

To manage digital databases we use specialized software called **D**ata**B**ase **M**anagement **S**ystems (DBMS). These systems typically run on servers and are managed by **D**ata**B**ase **A**dministrators (DBAs).

In less technical terms, we need a type of software that will allow us to create, access, and generally manage our databases. In the world of relational databases, we specifically use Relational Database Mangement Systems (RDBMs). Some examples are Postgres, SQLite, MySQL, and Oracle.

Choosing a DBMS determines everything from how you set up your database, to where and how the data is stored, to what SQL commands you can use. Most systems share the core of the SQL language that you’ve already learned.

In other words, you can expect `SELECT`, `UPDATE`, `INSERT`, `WHERE` , and the like to be the same across all DBMSs, but the subtleties of the language may vary.

### What is SQLite?

**SQLite** is the DBMS we primarily use at Lambda. As the name suggests, it is a more lightweight system and thus easier to get set up than some others.

SQLite allows us to store databases as single files. Many of the challenges and guided projects in Lambda have a `.db3` extension. That is the database.

SQLite is *not a database* (like relational, graph, or document are databases) but rather *a database management system*.

### Opening an existing database in SQLite Studio

One useful visual interface we might use with a SQLite database is called **SQLite Studio**. [Install SQLITE Studio here.](https://sqlitestudio.pl/)

Once installed, we can use SQLite Studio to open any `.db3` file from a previous lesson. We may view the tables, view the data, and even make changes to the database.

For a more detailed look at SQLite Studio, follow along in the video above.

##### Challenge

Use SQLite Studio to open a database from a previous challenge. Confirm that the data displayed in SQLite Studio matches the data from the server in a `GET` request.

------------------------------------------------------------------------

#### Learn to explain what is a database schema

In this module we’ll learn about schema design and column constraints.

##### Overview

A **database schema** is the shape of our database. It defines what tables we’ll have, which columns should exist within the tables and any restrictions on each column.

A well-designed database schema keeps the data well organized and can help ensure high-quality data.

Note that while schema design is usually left to Database Administrators (DBAs), understanding schema helps when designing APIs and database logic. And in a smaller team, this step may fall on the developer.

##### Follow Along

For a look at schema design in SQLite Studio, follow along in the video above.

When designing a single table, we need to ask three things:

-   What fields (or columns) are present?
-   What type of data do we expect for each field?
-   Are there other restrictions needed for each column?

Looking at the following schema diagram for an `accounts` table, we can the answer to each other those questions:

<table><thead><tr class="header"><th style="text-align: left;">field</th><th style="text-align: left;">data type</th><th style="text-align: left;">metadata</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">id</td><td style="text-align: left;">unsigned integer</td><td style="text-align: left;">primary key, auto-increments, generated by database</td></tr><tr class="even"><td style="text-align: left;">name</td><td style="text-align: left;">string</td><td style="text-align: left;">required, unique</td></tr><tr class="odd"><td style="text-align: left;">budget</td><td style="text-align: left;">numeric</td><td style="text-align: left;">required</td></tr></tbody></table>

### Table Fields

Choosing which fields to include in a table is relatively straight forward. What information needs to be tracked regarding this resource? In the real world, this is determined by the intended use of the product or app.

However, this is one requirement every table should satisfy: a **primary key**. A primary key is a way to identify each entry in the database uniquely. It is most often represented as a auto-incrementing integer called `id` or `[tablename]Id`.

### Datatypes

Each field must also have a specified datatype. The datatype available depends on our DBMS. Some supported datatype in SQLite include:

-   **Null:** Missing or unknown information.
-   **Integer:** Whole numbers.
-   **Real:** Any number, including decimals.
-   **Text:** Character data.
-   **\*Blob:** a large binary object that can be used to store miscellaneous data.

Any data inserted into the table must match the datatypes determined in schema design.

### Constraints

Beyond datatypes, we may add additional **constraints** on each field. Some examples include:

-   **Not Null:** The field cannot be left empty
-   **Unique:** No two records can have the same value in this field
-   **Primary key:** - Indicates this field is the primary key. Both the not null and unique constraints will be enforced.
-   **Default:** - Sets a default value if none is provided.

As with data types, any data that does not satisfy the schema constraints will be rejected from the database.

### Multi-Table Design

Another critical component of schema design is to understand how different tables relate to each other. This will be covered in later lesson.

##### Challenge

Create a new database and a design single table using SQLite Studio.

------------------------------------------------------------------------

#### Learn to create and use knex migrations

In this module we’ll learn about the knex command line tool and how to use it for knex migrations.

##### Overview

Knex provides a **schema builder**, which allows us to write code to design our database schema. However, beyond thinking about columns and constraints, we must also consider updates.

When a schema needs to be updated, a developer must feel confident that the changes go into effect everywhere. This means schema updates on the developer’s local machine, on any testing or staging versions, on the production database, and then on any other developer’s local machines. This is where **migrations** come into play.

A `database migration` describes changes made to the structure of a database. Migrations include things like adding new objects, adding new tables, and modifying existing objects or tables.

##### Follow Along

### Knex Cli

To use migrations (and to make Knex setup easier), we need to use **knex cli**. Install knex globally with `npm install -g knex`.

This allows you to use Knex commands within any repo that has `knex` as a local dependency. If you have any issues with this global install, you can use the `npx knex` command instead.

### Initializing Knex

To start, add the `knex` and `sqlite3` libraries to your repository.

`npm install knex sqlite3`

We’ve seen how to use manually create a config object to get started with Knex, but the best practice is to use the following command:

    knex init

Or, if Knex isn’t globally installed:

    npx knex init

This command will generate a file in your root folder called `knexfile.js`. It will be auto populated with three config objects, based on different environments. We can delete all except for the development object.

    module.exports = {

      development: {
        client: 'sqlite3',
        connection: {
          filename: './dev.sqlite3'
        }
      }

    };

We’ll need to update the location (or desired location) of the database as well as add the `useNullAsDefault` option. The latter option prevents crashes when working with `sqlite3`.

    module.exports = {

      development: {
        // our DBMS driver
        client: 'sqlite3',
        // the location of our db
        connection: {
          filename: './data/database_file.db3',
        },
        // necessary when using sqlite3
        useNullAsDefault: true
      }

    };

Now, wherever we configure our database, we may use the following syntax instead of hardcoding in a config object.

    const knex = require('knex');

    const config = require('../knexfile.js');

    // we must select the development object from our knexfile
    const db = knex(config.development);

    // export for use in codebase
    module.exports = db;

### Knex Migrations

Once our `knexfile` is set up, we can begin creating **migrations**. Though it’s not required, we are going to add an `addition` option to the config object to specify a directory for the migration files.

    development: {
        client: 'sqlite3',
        connection: {
          filename: './data/produce.db3',
        },
        useNullAsDefault: true,
        // generates migration files in a data/migrations/ folder
        migrations: {
          directory: './data/migrations'
        }
      }

We can generate a new migration with the following command:

`knex migrate:make [migration-name]`

If we needed to create an accounts table, we might run:

`knex migrate:make create-accounts`

Note that inside `data/migrations/` a new file has appeared. Migrations have a timestamp in their filenames automatically. Wither you like this or not, **do not edit migration names.**

The migration file should have both an `up` and a `down` function. Within the `up` function, we write the ended database changes. Within the `down` function, we write the code to undo the `up` functions. This allows us to undo any changes made to the schema if necessary.

    exports.up = function(knex, Promise) {
      // don't forget the return statement
      return knex.schema.createTable('accounts', tbl => {
        // creates a primary key called id
        tbl.increments();
        // creates a text field called name which is both required and unique
        tbl.text('name', 128).unique().notNullable();
        // creates a numeric field called budget which is required
        tbl.decimal('budget').notNullable();
      });
    };

    exports.down = function(knex, Promise) {
      // drops the entire table
      return knex.schema.dropTableIfExists('accounts');
    };

References for these methods are found in the **schema builder** section of the [Knex docs](https://knexjs.org/).

At this point, the table is **not** yet created. To run this (and any other) migrations, use the command:

`knex migrate:latest`

Note if the database does not exist, this command will auto-generate one. We can use SQLite Studio to confirm that the accounts table has been created.

#### Changes and Rollbacks

If later down the road, we realize you need to update your schema, you shouldn’t edit the migration file. Instead, you will want to create a new migration with the command:

`knex migrate:make accounts-schema-update`

Once we’ve written our updates into this file we save and close with:

`knex migrate:latest`

If we migrate our database and then quickly realize something isn’t right, we can edit the migration file. However, first, we need to **rolllback** (or undo) our last migration with:

`knex migrate:rollback`

Finally, we are free to rerun that file with `knex migrate` latest.

**NOTE**: A rollback should not be used to edit an old migration file once that file has accepted into a main branch. However, an entire team may use a rollback to return to a previous version of a database.

##### Challenge

Use Knex migrations to create a products table with the following columns:

-   id: make this the primary key.
-   name: should be a string that is unique.
-   price: should be a number.

------------------------------------------------------------------------

#### Learn to create and use knex seeds

In this module we’ll learn how to create and run knex seeds.

##### Overview

Often we want to pre-populate our database with sample data for testing. **Seeds** allow us to add and reset sample data easily.

##### Follow Along

The Knex command-line tool offers a way to **seed** our database; in other words, pre-populate our tables.

Similarly to migrations, we want to customize where our seed files are generated using our `knexfile`

    development: {
        client: 'sqlite3',
        connection: {
          filename: './data/produce.db3',
        },
        useNullAsDefault: true,
        // generates migration files in a data/migrations/ folder
        migrations: {
          directory: './data/migrations'
        },
        seeds: {
          directory: './data/seeds'
        }
      }

To create a seed run: `knex seed:make 001-seedName`

Numbering is a good idea because Knex doesn’t attach a timestamp to the name like migrate does. Adding numbers to the file name, we can control the order in which they run.

We want to create seeds for our accounts table:

`knex seed:make 001-accounts`

A file will appear in the designated seed folder.

    exports.seed = function(knex, Promise) {
      // we want to remove all data before seeding
      // truncate will reset the primary key each time
      return knex('accounts').truncate()
        .then(function () {
          // add data into insert
          return knex('accounts').insert([
            { name: 'Stephenson', budget: 10000 },
            { name: 'Gordon & Gale', budget: 40400 },
          ]);
        });
    };

Run the seed files by typing:

`knex seed:run`

You can now use SQLite Studio to confirm that the accounts table has two entries.

##### Challenge

Create sample data for an existing database table using seeds.

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node DB 2 Guided Project

[GitHub Repo](https://github.com/LambdaSchool/node-db2-guided)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Node DB 2 Project](https://github.com/LambdaSchool/node-db2-project)

    Afternoon project starter for Node DB 2 Module

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Database Schema Design for Web PT 18 w/Jason Maurer](https://youtu.be/sa6AEByzM_0)**

    In this module we’ll learn how to create schemas using both SQLite Studio and Knex. On this lecture we will cover the following topics: Database Management Systems (DBMS) SQLite studio Primary keys Data Types and Column Constraints Knex CLI Migrations Seeds At the end of this module, you should be able to: use SQLite Studio on an existing database explain what is a database schema create and use knex migrations create and use knex seeds

-   [All previous recordings](/archive/FSW/module/recIbfNn9xRhLTOv4)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Use SQLite Studio to open a database from a previous challenge. Confirm that the data displayed in SQLite Studio matches the data from the server in a `GET` request.

-   Objective challenge:

    Create a new database and a design single table using SQLite Studio.

-   Objective challenge:

    Use Knex migrations to create a products table with the following columns:

    -   id: make this the primary key.
    -   name: should be a string that is unique.
    -   price: should be a number.

-   Objective challenge:

    Create sample data for an existing database table using seeds.

-   Guided Project: Node DB 2 Guided Project

-   Project: Node DB 2 Project
