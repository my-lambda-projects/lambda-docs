<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Java - User Authentication

<span class="lead"> </span>

<span id="User_Authentication"></span>

**At the end of this module, you should be able to:**

- understand the flow and implement of Spring Security and OAuth2 to provide authentication for a project
- read user information from the access token
- understand the issues related to CORS and implement solutions to those issues
- understand how to implement a new user and logout endpoints
- use Postman to manually test Web APIs using Authentication

#### Pro Tip

Be on time. It’s a mark of respect not to keep others waiting.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to understand the flow and implement of Spring Security and OAuth2 to provide authentication for a project

<span id="OAuth2_Security"></span>

##### Overview

- See the Github Repository <https://github.com/LambdaSchool/java-safesampleemps.git> for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

You will also need the following environment variables set on your machine

- OAUTHCLIENTID = lambda-client
- OAUTHCLIENTSECRET = lambda-secret

### Securing our APIs

We now have these great API backend systems. We can provide data to our clients, we allow our clients to manipulate that data, and we can even provide our clients data from other systems. Chances are we do not want just anybody to change our data. We also might be working with sensitive data and should not allow everyone access to it. We need to restrict who can do what with our data. With the introduction of auditing fields, we also need to track who did what with our data. We need a way to identify who is the user accessing our system. Several different protocols exist to handle this common situation. One of the more popular ones, and the one used by default in the Spring Security module, is OAuth2.

**OAuth2** is an industry standard protocol for **user authentication**. User authentication is the verification of what human is accessing our system. Client applications request an access token from a backend API system. Gaining an access token allows a user to access projected resources, endpoints and allows the backend system to know who that user is without the user having to provide their username and password for each transaction. Gaining this access token is done through a two step process.

- Clients must be **authorized** to access the system using a client user name and password, called a client id and client secret in the OAuth2 protocol. This client id and client secret could be the same for all clients who want to access the backend API, or each client could receive their own id and secret. The ids and secrets are controlled by the backend system. The backend system must tell the client what client id and client secret to use!
  - Sometimes a client will send an authorization token instead of a client id and client secret. For our purposes, this authorization token is simply the client id and client secret combined and encoded using Base64 encoding.
- After a client has been authorized, an individual user is **authenticated** to the system using a user name and password.

These two steps are necessary but are usually combined into a single request from the client for an access token. After initially getting the access token, the client must send that token with each subsequent request. The access token can be used by the backend system to determine what user is accessing the system.

In the OAuth2 framework, 4 Roles are identified.

- The **client**
  - Often called the frontend. This is the application that wishes to access our backend API server.
- The **Resource Server**
  - This is our backend API server. It is the server that hosts the protected information.
- The **Authorization Server**
  - This is the part of the backend application that grants access tokens. Access tokens are only granted after the client is authorized and the user is authenticated. When we think of using Google, Facebook, GitHub to logon to a system, what we mean is that we are using their authorization server to get an access token. Using these external systems is beyond the scope of this module. For now we be using our own Authorization Server.
- The **Resource Owner**
  - Usually a person that grant access to a protected resource. Think something like a system admin.

### Roles in our code

We will be using Spring Security to implement OAuth2. OAuth2 is the default, standard protocol implemented by Spring Security. That will make implementation easier. The implement is a series of boilerplate code that is customized to fit our applications. We will be using

- An **AuthorizationServerConfig** class that will serve the role of the Authorization Server. We use the `@EnableAuthorizationServer` annotation to set up a default authorization server and then customize it to fit our applications.
- A **ResourceServerConfig** class that will serve the role of the resource server. We use the `@EnableResourceServer` annotation to set up a default resource server and then customize it to fit our application. Most of our application is concerned with how to protect, display, and manipulate resources. So most of our application, including all that we have coded up until this point, can be considered part of the resource server.
- A **SecurityConfig** class that will serve as the main configuration class for our OAuth2 server. We use the `@EnableWebSecurity` annotation to say, yes we want to use web security and then we configure this web security to our own needs.

Do note that often you will hear me refer to the OAuth2 process as authorization or authentication. This is not correct. Those are two different parts of the OAuth2 protocol. However, in the industry often the OAuth2 protocol is referred to as authorization or authentication.

Before we code OAuth2 authentication, let’s look at how the access token flows through the system.

### Gaining Access

In order to request an access token, our client needs to know the client id and client secret. These will be provided to the client by the backend administrator. It is OUR responsibility to give the frontend the client id and client secret. The frontend client does not get to choose what these are, we do. Commonly you will see these being hard to guess random characters, normally 32 character hex strings. Sometimes you will see the client id and client security provided as Base64 API access tokens. A client would use either the client id / client security combination or the API access token to get authorized to the system. They do NOT use both. Which one they use is often left to the client to decide. The format of combining the client id and client secret is to take the following and encode it using Base64:

client id:client secret

Client id: 6779ef20e75817d76902 Client security: 9e51c1701e1a6f5cfb30780d94d38b8d API access token: Njc3OWVmMjBlNzU4MTdkNzY5MDI6OWU1MWMxNzAxZTFhNmY1Y2ZiMzA3ODBkOTRkMzhiOGQ=

For our purposes we will use something easy to read. You may change these to anything you wish. Just make sure to inform your clients of the change! Note: for class purposes, let’s leave them as these defaults. This will make reviewing each other’s code much easier.

Client id: lambda-client Client security: lambda-secret API access token: bGFtYmRhLWNsaWVudDpsYW1iZGEtc2VjcmV0

### Adding a new user

But before we can request access to the system, we need a user set up, you know, the one requesting access!

Adding a new user is the same as adding any other record to our database. The one additional item is that the password has to be encrypted. Although not required, encrypting the password is definitely the preferred practice! We use an encryption algorithm called BCrypt. This is fairly standard in the industry.

We say which algorithm we are going to use in the `SecurityConfig` class. This is where we setup the Bean for PasswordEncoder.

![Security Config PasswordEncoder](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-bcrypt.png)

We then have to encrypt the password in the setter for the User password field.

![User Model Password Setter](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-user.png)

### Authorizing the client

The step in using the API Backend is to Authorize the client, the application wanting to use the API. The client has a special username and password needed to access the backend. They also have special names.

- username => client id
- password => client secret

These are sent to the API backend via the Authorization header in a REST API request. They can either be sent as a username and password, or as is more common an API Key. The API Key is simply the string `client id:client secret` encoded using Base64.

The AuthorizationServerConfig class is responsible for handling the Authorization of the client.

- In our case we list the client id and client secret directly in the AuthorizationServerConfig allowing for only one client id, client secret combination. Some systems provide access to multiple client ids but that is a more advanced topic.
- Note that the client secret is also encrypted using BCrypt, using our encode Bean from the SecurityConfig class.
- Other configurations happen in the AuthorizationServerConfig like how long a token is valid.

![AuthorizationServerConfig](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-AuthServConfig.png)

- We also set what the login endpoint from where a user, not to be confused with the client, gets their authentication token.
  - Client is the fontend system accessing the API Backend
  - User is the person, usually, actually handling data from the Backend.

![AuthorizationServerConfig Login](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-AuthServConfig-Login.png)

### Authenticating the user

NOTE: In most REST API calls from a client, the Authorization and Authentication are handled in a single request. The client just sends the client id and client secret along with a username and password to the API Backend System. That API Backend System takes care of Authorizing the client and then Authenticated the user!

Authenticating a user happens after the client is Authorized. The client must have access to the API Backend System via its client id and client secret before it can request an Authentication token for a user.

The process of Authentication is taking a username and password and determining if that combination is a valid combination, represents a valid user, of the system. If the validity of the user is confirmed, the API Backend System returns to the client an Authentication Token. It is this token that will identify the user in future requests.

That Authentication Token is store in the Token Store. You can think of a Token Store as a table in memory with columns contains data such as

- The Authentication Token
- The time the token is to expire
- The Authentication object of the user, the UserDetails Security Object which is essentially a cached copy of the user record only containing data necessary for security.
- The Token Store Bean is set up in the SecurityConfig class and configured as the Authentication Manager in the AuthorizationServerConfig

![TokenStore Bean](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-TokenStore-Bean.png)

![AuthenticationManager](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-AuthenticationManager.png)

### Using the authentication token

Note that we restrict what user can do what with our data through **user roles**. Users get access to read, manipulate certain pieces of data by what role they are assigned. Role assignment are often done by type of user: admin, dataentry, user. Sometimes departments are added: systemadim, accountingadmin, hrdataentry, manufacturinguser. The name of the role can be anything but is usually something that makes sense to a human reading the role title. Role titles do get hard coded in our applications when we are restricting data to certain roles. So name roles carefully as changing the name of role is a BIG deal!

Now we have an authentication token that identifies that this is a valid user and identifies which user it is. From this authentication token we can also identify what can access.

To access a restricted endpoint, the client send an authentication token in the Authorization header.

Spring Security Framework looks for that authentication token in the TokenStore

- If Spring Security finds the token in the TokenStore

  - Spring Security sees if the user associated with this token has access to the requested endpoint.
    - This is handled through the getAuthority method in the User model
    - This method returns which “Authorities” the user has been granted. In our case, those authorities are equivalent to our roles.

![getAuthority](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-GrantAuthorities.png)

- If Spring Security does not find the token in the TokenStore, an unauthorized status is returned.

- To determine which roles has access to what endpoints, the first place to check is the ResourceServerConfig. This class determines which roles have access to which resources, or endpoints. The majority of your security configuration happens in this class.

![ResourceServerConfig](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-ResourceServerConfig.png)

- You allow access to a resource using `.antMatchers`
- The parameter for `.antMatcher` is a regular expression stating which endpoints you want to restrict.
- The `.antMatchers` ends with a method
  - `.permitAll()` - allows access to all. No Authentication Token is necessary
  - `.authenticated()` - allows access to all authenticated users. A valid authentication token is required.
  - `.hasAnyRole()` - the parameter is a list of roles who have access to these endpoints.
- You can further restrict your security access using a @PreAuthorize annotation in the Controller. This further restrict access to this endpoint to only the given roles. Note: you cannot expand access via this method only further restrict it.

![PreAuthorization](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-PreAuthorization.png)

##### Follow Along

Let’s add user authentication to our sample employees application. Start by opening the application safesampleemps-initial from the GitHub repository <https://github.com/LambdaSchool/java-safesampleemps.git>t. This application is the same as the ending application from the GitHub repository <https://github.com/LambdaSchool/java-exceptionalsampleemps.git>t. These are the employees we will make safe!

Do note that the code we are adding is a minimal set of code to make user authentication possible. We purpose leave out all the code that allows us to manipulate the Users and their Roles. In a full production system, this code we are leaving out would be necessary! For explanation though that additional code would get in the way!

Find the security-boilerplate code in the GitHub Repository <https://github.com/LambdaSchool/java-safesampleemps.git>t, the same repository where our initial application came from. This is the boilerplate code we will be adding!

### POM.XML

We need to tell our application that we will be using Spring Security. We do this by adding the appropriate dependencies to the POM.XML file. Once we add these dependencies to the POM.XML, we must implement security before we can run our application! So add the following dependencies to your POM.XML file. These dependencies can also be found in the security-boilerplate code directory

            <!-- Security Dependencies Start -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-security</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-test</artifactId>
                <scope>test</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.security.oauth</groupId>
                <artifactId>spring-security-oauth2</artifactId>
                <version>2.3.6.RELEASE</version>
            </dependency>
            <!-- Security Dependencies End -->

### Necessary Models

Our application relies on user names - which could be a name, an email, user id - user passwords, and user roles. We need a place to store this information in our application. For the current sample application, we are going to use a separate users table. The user table would normally not only hold our user names and passwords but also anything else that is needed for a user of the system. In our case, combining the users model and the employee model into one table would make sense.

The roles will have a many-to-many relationship with users. A user can have multiple roles. A role should have multiple users.

Let’s add the necessary models. In your safesampleemps application, add the following models from the security_boilerplate code:

- Users
  - In user we have a way to deal with passwords that are coming from the client not encrypted using the method `setPassword(String password)`. When a password is internal to our system, it is encrypted. We can set an already encrypted password using the method `setPasswordNoEncrypt(String password)`.
  - Users have an additional `getAuthority()` method. This is the method Spring Security will use to determine which roles a user has.
- Roles
  - Always keep role names all upper case. Experience shows this will make your life easier!
- UserRoles

And of course we need to add the necessary Repositories to connect these models to the rest of our application. Again inside the security-boilerplate code add the repositories for

- UserRepository
- RoleRepository

We do not need one for UserRoles!

### Necessary Services

We are going to keep our boilerplate simple and access the models through the repositories, bypassing services. This is for our example only. In a production system, USE SERVICES!!! However, Spring Security relies on a service that connects it to our User, Role models. From the boilerplate code, add the service `SecurityUserServiceImpl`.

Now that we have real user id, we need to update the UserAuditing service to use those user ids! Put the updated version of `UserAuditing` from the boilerplate code into your application.

### Configuration

Now for the part totally new related to Security. We are going to configure our web security, enable our authorization server, and enable our resource server.

Work with web security first. Add the code from the boilerplate `SecurityConfig` to your application’s subpackage `config`. This configuration file

- Enables are authentication manager allowing us to work with the user names and passwords
- Connects Spring Security to the service SecurityUserServiceImpl and thus to our user and role tables
- Creates an in memory table to store and maintain the access tokens for our systems. This acts as a separate in memory database. It is in memory for speed of access and so when the system goes down, all access is reset. Users have to sign in again after a system restart.
- Defines the password encryption method we will use. Normally we will use the industry standard BCrypt as we do in this example.

Now let’s enable our Authorization Service. Add the code from the boilerplate `AuthorizationServerConfig` to your application’s subpackage `config`. This configuration file

- Enables our authorization service using a client id and client secret it reads from the environment variables OAUTHCLIENTID and OAUTHCLIENTSECRET respectively.
- We will set the access token to be valid forever. We can set the access token to become invalid after a certain time period forcing a user to sign in to our system again.
- Besides using Roles, OAuth2 provides another layer of security rights called Scopes. We will not be addressing scopes in this module.
- The grant type password tells the authorization server that we will be using the standard user name and password model to authenticate. Other methods exist but this one is by far the most common!
- The default endpoint for requesting an access token in Spring Security is `/oauth/token`. We can easily change this to something like `/login`. The last method in the configuration class `configure(AuthorizationServerEndpointsConfigurer endpoints)` does this for us.

Finally, let’s enable our Resource Service. Add the code from the boilerplate `ResourceServerConfig` to your application’s subpackage `config`. The main purpose of this configuration class is to say which roles have access to which methods and endpoints, what are roles allowed to do. This is done through a series of `antMatchers` which are used to configure the authorized requests in our system. The boilerplate contains a simple series of .antMatchers. We have two Roles, _ADMIN_ and _USER_. _USER_ has access to all endpoints starting with `/employees`. _ADMIN_ has access to all endpoints starting with `/users`. Anyone using the system (`.permitAll()`) can access `/createnewuser`. Anyone who has authenticated to the system can access `/logout`.

Note that in an antMatcher,

- `/users` means just that endpoint
- `/users/**` means the `/users` endpoint and anything below that. So for example
  - `/users`
  - `/users/1`
  - `/users/roles/add/me`

Below is a more complex that shows some of the power of how we control endpoints in our application. This is adapted from the guided project for this module.

            // our antMatchers control which roles of users have access to which endpoints
            // we must order our antmatchers from most restrictive to least restrictive.
            // So restrict at method level before restricting at endpoint level.
            // permitAll = everyone and their brother
            // authenticated = any authenticated, signed in, user
            // hasAnyRole = must be authenticated and be assigned this role!
            http.authorizeRequests()
                .antMatchers("/",
                    "/h2-console/**",
                    "/swagger-resources/**",
                    "/swagger-resource/**",
                    "/swagger-ui.html",
                    "/v2/api-docs",
                    "/webjars/**",
                    "/createnewuser")
                .permitAll()
                .antMatchers(HttpMethod.POST, "/users/**")
                .hasAnyRole("ADMIN")
                .antMatchers(HttpMethod.DELETE, "/users/**")
                .hasAnyRole("ADMIN")
                .antMatchers(HttpMethod.PUT, "/users/**")
                .hasAnyRole("ADMIN")
                .antMatchers("/users/**",
                    "/useremails/**",
                    "/oauth/revoke-token",
                    "/logout")
                .authenticated()
                .antMatchers("/roles/**")
                .hasAnyRole("ADMIN")
                .and()
                .exceptionHandling()
                .accessDeniedHandler(new OAuth2AccessDeniedHandler());

Note: they are called **ant** matcher from an old Apache Organization application called ant which was used for pattern matching. Ant = **A**nother **N**eat **T**ool.

### Security is in place

Thanks to the behind the scenes work of Spring Security, enabling OAuth2 security in Java Spring is simply adding a series of boilerplate code and configuring it to fit our application. We now have user authentication in place! We will see how to access this in the objective covering using Postman with User Authentication!

##### Dig Deeper

- [OAuth Concepts](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)  
  Technology neutral explanation of the OAuth concepts
- [JX User Authentication Guide](https://drive.google.com/open?id=1x-gI8YvZTGSznQvc0mmfzgysr9ptB7pS)  
  JX User Authentication Guide by Rory Murray
- [Spring Security](https://www.developer.com/java/ent/what-is-spring-security.html)-%20%5BSpring%20Boot%20and%20OAuth2%5D(https://spring.io/guides/tutorials/spring-boot-oauth2/)  
  What is Spring Security
- [Implement OAuth 2.0](https://dzone.com/articles/implement-oauth-20-easily-with-spring-boot-and-spr)  
  DZone - Implement OAuth 2.0 Easily with Spring Boot and Spring Security
- [Additional Topic: Facebook](https://www.javainuse.com/spring/spring-social)%20-%20%5BOkta%20Java%20Spring%5D(https://developer.okta.com/blog/2019/05/24/java-spring-tutorials)  
  Facebook Authentication Using Spring Boot + Spring Social Simple Example
- [Additional Topic: Okta](https://developer.okta.com/blog/2019/05/24/java-spring-tutorials)  
  Okta Java Spring
- [Additional Topic: Google](https://developers.google.com/api-client-library/java/google-api-java-client/oauth2)  
  Using OAuth 2.0 with the Google API Client Library for Java
- [Additional Topic: JWT](https://dzone.com/articles/spring-boot-security-json-web-tokenjwt-hello-world)  
  Spring Boot Security + JWT ''Hello World'' Example

---

#### Learn to read user information from the access token

<span id="User_Information_from_Access_Token"></span>

##### Overview

- See the Github Repository <https://github.com/LambdaSchool/java-safesampleemps.git>t for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

Unlike JSON Web Tokens (JWT), no information is included with the authentication token sent to the client. Security is the reason for this. If the token is intercepted during transmission, the interceptor just has the token and no additional information. In order to get additional information, the interceptor would have to query API Backend system, meaning they would have to be able to connect to the system - CORS and client access would have to be configured just right to let this happen.

- Positive is increased security

- Negative is increased web traffic and complexity for the client application

- You can determine the name of the user associated with the given authentication token using a variety of methods
  - Referencing the global class SecurityContextHolder

![SecurityContextHolder](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-SecurityContext.png)

- From the global Authentication class, you can call the method `getPrincipal()` to learn a variety of information about the user and their authorities

- From the global Authentication class, you can call the method `getName()` to return the username. You can then call UserService.findByName() with that name as the parameter and return the entire user record associated with that authentication token.

![Authentication getName](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/JX-12-M3-getName.png)

##### Follow Along

Let’s use these two methods in our code. We are continuing adding to our application safesampleemps-initial from the GitHub repository <https://github.com/LambdaSchool/java-safesampleemps.git> started in the last objective.

We will need some seed data to work with. Let’s add the following code to the SeedData class is on our application. First we will add two roles: ADMIN and USER. Next we add two ADMINs and one USER.

At the top of the existing SeedData Class connect the class to the Role and User Repositories

        // ...

        private Random random = new Random(); // already in SeedData

        @Autowired
        private UserRepository userrepos;

        @Autowired
        private RoleRepository rolerepos;

        // already in SeedData
        @Override
        public void run(String... args)
                throws
                Exception

        // ...

This code can go at the bottom of the existing SeedData Class.

            // Adding SeedData for users
            Role r1 = new Role("ADMIN");
            Role r2 = new Role("USER");
            r1 = rolerepos.save(r1);
            r2 = rolerepos.save(r2);

            // admin
            ArrayList<UserRoles> admins = new ArrayList<>();
            admins.add(new UserRoles(new User(), r1));
            User u1 = new User("barnbarn", "password", admins);
            userrepos.save(u1);

            // we need to start a new list of roles for the new admin user. For each user, a new list of roles needs to be created
            // even the roles are the same between the users. The list of UserRoles though is never the same!
            admins = new ArrayList<>();
            admins.add(new UserRoles(new User(), r1));
            User u2 = new User("admin", "password", admins);
            userrepos.save(u2);

            // users
            ArrayList<UserRoles> users = new ArrayList<>();
            users.add(new UserRoles(new User(), r2));
            User u3 = new User("cinnamon", "ILuvM4th!", users);
            userrepos.save(u3);

Now let’s add some endpoints. You may recall that we gave ADMINs access to the /users and following endpoints and USERs access to the /employees and following endpoints. Let’s create a controller for user. Add the following class to to our `controllers` subpackages. Remember that for this example we are using the User Repository and not User Service.

The code below

- creates an endpoint /users/getuserinfo which returns the following JSON object about a user. This information is from our own database layout. This a great way for a client to determine the user id, user name associated with the given access token.

<!-- -->

      {
        "createdBy": "SYSTEM",
        "createdDate": "2020-05-25 16:08:44",
        "lastModifiedBy": "SYSTEM",
        "lastModifiedDate": "2020-05-25 16:08:44",
        "userid": 53,
        "username": "barnbarn",
        "roles": [
            {
                "createdBy": "SYSTEM",
                "createdDate": "2020-05-25 16:08:44",
                "lastModifiedBy": "SYSTEM",
                "lastModifiedDate": "2020-05-25 16:08:44",
                "role": {
                    "createdBy": "SYSTEM",
                    "createdDate": "2020-05-25 16:08:44",
                    "lastModifiedBy": "SYSTEM",
                    "lastModifiedDate": "2020-05-25 16:08:44",
                    "roleid": 51,
                    "name": "ADMIN"
                }
            }
        ]
      }

- Notice the `Authentication` parameter. This is a class internal to Spring Security. It can used throughout a Spring application to gather information on about the authenticated user, the user associated with the access token the client sent us when it made a request. We can access this `Authentication` object through a parameter or can `@Autowire` it to our class.

<!-- -->

    import com.lambdaschool.sampleemps.models.User;
    import com.lambdaschool.sampleemps.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.Authentication;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    @RequestMapping("/users")
    public class UserController
    {
        @Autowired
        private UserRepository userrepos;

        @GetMapping(value = "/getuserinfo",
                produces = {"application/json"})
        public ResponseEntity<?> getCurrentUserInfo(Authentication authentication)
        {
            User u = userrepos.findByUsername(authentication.getName());
            return new ResponseEntity<>(u,
                    HttpStatus.OK);
        }

    }

Now let’s add another endpoint. This time we will get the user information as Spring Security stores it. This method returns information like

    {
        "password": null,
        "username": "barnbarn",
        "authorities": [
            {
                "authority": "ROLE_ADMIN"
            }
        ],
        "accountNonExpired": true,
        "accountNonLocked": true,
        "credentialsNonExpired": true,
        "enabled": true
    }

Add the following method to the bottom of your UserController class.

        @GetMapping(value = "/getusername",
                produces = {"application/json"})
        public ResponseEntity<?> getCurrentUserName(Authentication authentication)
        {
            return new ResponseEntity<>(authentication.getPrincipal(),
                    HttpStatus.OK);
        }

In the objective on using Authentication in Postman we will discuss how to access these endpoints!

##### Dig Deeper

- [Auto Login User](https://www.baeldung.com/spring-security-auto-login-user-after-registration)  
  Baeldung - Spring Security - Auto Login User After Registration
- [Extracting User Info](https://www.baeldung.com/spring-security-oauth-principal-authorities-extractor)  
  Baeldung - Extracting Principal and Authorities using Spring Security OAuth

---

#### Learn to understand the issues related to CORS and implement solutions to those issues

<span id="CORS"></span>

##### Overview

- See the Github Repository <https://github.com/LambdaSchool/java-safesampleemps.git>t for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We are using the same computer, as our frontend client - think Postman, as the one where our API backend system resides. Same computer, same domain, same “origin”. Soon we will be deploying our API to the cloud. Ultimately this is what we are after, making our API available to others. When we deploy, the client accessing our API and our API backend will most likely be on different computers, different domains, different “origin”. We need to allow different origins to share, use the resources of our API backend. By default only clients and backends running on the same system can access each other. We need to allow **C**ross-**O**rigin **R**esource **S**haring, normally called **CORS**.

We allow CORS, also referred to as preventing CORS errors, we can specific

- Which origins, domains can access our API.
  - Normally we will allow all origins to access our API. This is certainly true of all publicly facing APIs. For company internal APIs, you may wish to restrict which origins can access the API to only those within the company
- Which HTTP Methods will be allowed
- Which Access Control Headers will be allowed

For this course, we are going to allow all origins using any HTTP Methods and using any Access Control Headers. We do this by taking advantage of the Spring Filter Chain which filters who has access to what on our API.

##### Follow Along

Let’s add The CORS Simple Filter to our `safesampleemps` application. Find the provided boilerplate code application `makesafeboilerplate` the configuration class named `SimpleCorsFilter`. The class is provided below for reference. Reading through the code and comments will give you a better understanding of what is happening. Add this class to your `safesampleemps` application under the `config` subpackage.

    import org.springframework.core.Ordered;
    import org.springframework.core.annotation.Order;
    import org.springframework.http.HttpMethod;
    import org.springframework.stereotype.Component;

    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    /**
     * Spring uses filters to manage web traffic. Here we manually add a CORS (Cross-Origin Resource Sharing) filter to the chain.
     * Using the Order annotation, we tell Spring this is the most important filter. If this filter blocks a request,
     * don't do anything else. Just block the request.
     */
    @Component
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public class SimpleCorsFilter
        implements Filter
    {
        @Override
        public void doFilter(
            ServletRequest servletRequest,
            ServletResponse servletResponse,
            FilterChain filterChain) throws
                                     IOException,
                                     ServletException
        {
            // Convert our request and response to Http ones. If they are not Http ones, an exception would be thrown
            // that would handled by our exception handler!
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            HttpServletRequest request = (HttpServletRequest) servletRequest;

            // white list domains that can access this API. * says let everyone access it. To restrict access use something like
            //                 response.setHeader("Access-Control-Allow-Origin",
            //            "https://lambdaschool.com/");
            response.setHeader("Access-Control-Allow-Origin",
                "*");

            // white list http methods that can be used with this API. * says lets them all work! To restrict access use something like
            //        response.setHeader("Access-Control-Allow-Methods", "POST, PUT, GET, OPTIONS, DELETE");
            response.setHeader("Access-Control-Allow-Methods",
                "*");

            // while list access headers that can be used with this API. * says lets them all work! To restrict access use something like
            //        response.setHeader("Access-Control-Allow-Headers", "x-requested-with, authorization, content-type, access_token");
            response.setHeader("Access-Control-Allow-Headers",
                "*");

            // maximum seconds results can be cached
            response.setHeader("Access-Control-Max-Age",
                "3600");

            if (HttpMethod.OPTIONS.name()
                .equalsIgnoreCase(request.getMethod()))
            {
                response.setStatus(HttpServletResponse.SC_OK);
            } else
            {
                filterChain.doFilter(servletRequest,
                    servletResponse);
            }
        }
    }

That is it. You now have CORS in place. I add this filtering class to every one of my API applications. This code allows all domains to access anything. Restrictions on who can access what are handled by the OAuth2 process. Comments are included how to go about restricting origins, HTTP Methods, and Access Control Headers.

##### Dig Deeper

- [Another Approach](https://spring.io/guides/gs/rest-service-cors/)  
  Another Approach - Spring IO CORS

---

#### Learn to understand how to implement a new user and logout endpoints

<span id="Special_Endpoints"></span>

##### Overview

Two special cases arise with user authentication. How does someone create their own user account and sign on all in one step? How does a user logout of the system? Let’s work through each of these scenarios and then code them!

- Creating their own account - Often websites contain an option for users to create their own accounts. This gives the user immediate access but with predefined access. Here is our plan:
  - The user will give us minimal information: name and password.
  - The system will create an account for that user assuming one is not already created. The user will be assigned to the USER role.
  - Within the same method, we will call the login endpoint that assigns access tokens.
  - We will let the system assign an access token.
  - Finally, we will return that access token.
- Logging out - when a user no longer wishes to maintain access to the system, they can logout. To logout we remove the access token from the token store. If the access token is no longer available, it is no longer valid, and thus the user no longer has access. The access token we remove will be the one the authenticated user sends us when they access the logout endpoint. Let’s see how these look in code.

##### Follow Along

Let’s add these two endpoints to our code. We are continuing adding to our application safesampleemps-initial from the GitHub repository https://github.com/LambdaSchool/java-safesampleemps.git using our code from the last objective.

### Create A New User

We need to expose the `findByName(String name)` method in the role repository. The role repository should now look like this:

    public interface RoleRepository
            extends CrudRepository<Role, Long>
    {
        Role findByName(String name);
    }

We need a special user model to work with our incoming data. So under the subpackage `models`, create the class `UserMinimum`. This model does NOT get saved in the database and is only to get the user information in from the client for this endpoint. Specifically by using this model we receive our password in plain text which we will need to get an access token. Add the following code to the UserMinimum class.

    public class UserMinimum
    {
        private String username;
        private String password;

        public String getUsername()
        {
            return username;
        }

        public void setUsername(String username)
        {
            this.username = username;
        }

        public String getPassword()
        {
            return password;
        }

        public void setPassword(String password)
        {
            this.password = password;
        }
    }

Under the controllers subpackage add a class called `Oauthendpoints`. Let’s build this class.

The class is to be a RestController. So add the @RestController annotation.

    @RestController
    public class Oauthendpoints
    {
    }

Inside the body of the class, connect the class to the user and role repositories. Note: the TokenStore is needed for the logout method later in this objective. We should just add it now though!

        @Autowired
        RoleRepository rolerepos;

        @Autowired
        UserRepository userrepos;

        @Autowired
        private TokenStore tokenStore;

Since the endpoint will be adding an access token to the token store and a new user to the database, the HTTP Method is a Post. The endpoint will both consume JSON, the new user to add, and produce JSON, the access token. So the headers will look like this:

        @PostMapping(value = "/createnewuser",
            consumes = {"application/json"},
            produces = {"application/json"})
        public ResponseEntity<?> addSelf(
                HttpServletRequest httpServletRequest,
                @RequestBody UserMinimum newinuser)
        {
        }

Verify that the client has sent us a username and password and that the username does not already exist. To see if the Strings we receive have values, we use the `isBlank()` method. `isBlank()` returns true if all that is in a String are whitespace characters.

        {
            if (newinuser.getUsername().isBlank() || newinuser.getPassword().isBlank())
            {
                throw new EntityNotFoundException("Username and / or password cannot be blank");
            }

            if (userrepos.findByUsername(newinuser.getUsername()) != null)
            {
                throw new EntityExistsException("Username already exists");
            }
        }

Add the user object to add to the database.

            User newuser = new User();
            newuser.setUsername(newinuser.getUsername());
            newuser.setPassword(newinuser.getPassword());
            newuser.addRole(rolerepos.findByName("USER"));
            newuser = userrepos.save(newuser);

Now let’s create the location header just like we always do when we add a new row to the database. However, this time, we must state the URI explicitly as we cannot simply add to the existing URI. The location header’s URI is not derived from the current request, so we have to do a little more work than normal.

            HttpHeaders responseHeaders = new HttpHeaders();
            URI newUserURI = ServletUriComponentsBuilder.fromUriString(httpServletRequest.getServerName() + ":" + httpServletRequest.getLocalPort() + "/users/user/{userId}")
                .buildAndExpand(newuser.getUserid())
                .toUri();
            responseHeaders.setLocation(newUserURI);

Now let’s get an access token. To get the access token we are going to act like an API client and call the endpoint that authenticates users. We set up the endpoint using a RestTemplate, invoke the endpoint, and return the access token!

You can try out the new endpoint by going to the endpoint http://localhost:2019/createnewuser using the following request body

    {
        "username": "stumps",
        "password": "ILuvM4th!"
    }

The user stumps will be created with a role of USER. stumps’ access token will be returned with a status of CREATED.

### Logout a user

To logout a user, a user will access the `/logout` endpoint using their access token. We will find the access token in the token store and remove it. Create another method in the `Oauthendpoints` class using the following code.

        @GetMapping(value = "/logout")
        public ResponseEntity<?> logoutSelf(HttpServletRequest request)
        {
        }

The body of this GET request reads the access token from the request header, finds it in the token store and removes it.

            String authHeader = request.getHeader("Authorization");
            if (authHeader != null)
            {
                // find the token
                String tokenValue = authHeader.replace("Bearer",
                    "")
                    .trim();
                // and remove it!
                OAuth2AccessToken accessToken = tokenStore.readAccessToken(tokenValue);
                tokenStore.removeAccessToken(accessToken);
            }

            return new ResponseEntity<>(HttpStatus.OK);

To test this, sign on as any user. Use that users access token to go to the endpoint http://localhost:2019/logout. Now try to access a secured endpoint with that access token. You will get an invalid access token error message! The user is no longer authenticated to the application!

---

#### Learn to use Postman to manually test Web APIs using Authentication

<span id="Using_Authentication_in_Postman"></span>

##### Overview

- See the Github Repository <https://github.com/LambdaSchool/java-safesampleemps.git> for the code used in the objective.

  ### Software Needed

- Java Development Kit (JDK) - at least version 11

- JetBrains IntelliJ IDEA IDE

- Postman

We have already seen how to use **Postman** to retrieve data from an API system. We have seen how to use Postman to manipulate data. We now need to know how to authenticate a user through Postman so we can access all the other cool endpoints!

##### Follow Along

We need a backend system, an API, to work with. Let’s use the one we have been working on, the one from the Github Repository <https://github.com/LambdaSchool/java-safesampleemps.git>. If you have not been updating the safesampleemps application, you can always clone the repository and use the final version of the application containing all the chances we added during this module.

The authentication process is the same whether you are doing a POST, GET, PUT, PATCH, or DELETE.

- Remember in a previous objective in this Module, we added SeedData to our application. One of the Users we added was BarnBarn with a password of password. BarnBarn has a role of ADMIN. Let’s access an endpoint that requires us to be authenticated and let’s use BarnBarn as the authenticated user
- Launch Postman
- Get a blank tab in Postman
- Let’s surf to an endpoint that requires authentication. We will surf to the endpoint <http://localhost:2019/users/getusername> without authenticating. We get a standard authentication error message like the following:

<!-- -->

    {
        "error": "unauthorized",
        "error_description": "Full authentication is required to access this resource"
    }

![Postman Not Authenticated](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_notauthenticated.png)

Now let’s get an access token. Let’s authenticate our user BarnBarn!

- Get a blank tab in Postman
- Goto the `Authorization` Tab
  - Under Type, select `Oauth 2.0`

![Postman Authorization Tab](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_authentication_tab.png)

- In the next screen, click on the Get New Access Token button

![Postman New Access Token](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_get_token.png)

- Fill in the information in the Get New Access Token window
  - **Token Name**: The token gets saved in Postman for future use. This is the name under which it will be saved.
  - **Grant Type**: We are using the _Password Credentials_ grant type. Select this and the rest of the fields will adjust as to how they are in the window.
  - **Access Token URL**: In our Authorization Server Configuration, we set our endpoint to get an access token to be `/login`, so our Access Token URL becomes <http://localhost:2019/login>
  - **Username**: the username, user id, of the user requesting authentication
  - **Password**: the password of the user requesting authentication
  - **Client ID**: in our case `lambda-client`
  - **Client Secret**: in our case `lambda-secret`
  - **Scope**: we leave blank
  - **Client Authentication**: It should default to _Send as Basic Auth header_

![Postman Get Token Window](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_get_token_window.png)

- Click on the button _Request Token_
- You are presented with a window that contains information including the access token.
- Click the button _Use Token_

![Postman Access Token](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_the_access_token.png)

- We can see the access token in the Access Token box. We are able to surf to a protected endpoint and get our information!

![Postman Success](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2012%20-%20Java%20Frameworks/Module%202%20-%20JX%20Java%20-%20User%20Authentication/assets/postman_success.png)

- We can keep using this token to access protected endpoints as BarnBarn as long as the application is running.
  - We copy the access token, in our example `e343db5d-9dd1-40b1-90bb-1d12b4d4b63d`.
  - We get a new Postman tab.
  - We select the Authorization and paste the token into the Access Token box.
  - We can now access protected endpoints as BarnBarn!

##### Challenge

Sign in as user `cinnamon` with a password of `ILuvM4th!`. cinnamon is the role of USER and so can only access endpoints starting with /employees. Surf to the following endpoints and notice the results

- A route where cinnamon is denied access <http://localhost:2019/users/getusername>
- A route cinnamon can access <http://localhost:2019/employees/employees>

##### Dig Deeper

- [Postman Homepage](https://www.postman.com/)  
  Postman Homepage
- [Postman Learning Center](https://learning.postman.com/)  
  Postman Learning Center
- [Insomnia](https://insomnia.rest/)  
  Popular Postman Competitor - Insomnia

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### java-oauth2

[GitHub Repo](https://github.com/LambdaSchool/java-oauth2.git)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [java-shoppingcart](https://github.com/LambdaSchool/java-shoppingcart.git)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Java OAuth2 for WEB33 with John Mitchell](https://youtu.be/N1FluKULtHU)**
- [All previous recordings](/archive/WEB4Java/module/rececDV2OMIUcY2eH)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Sign in as user `cinnamon` with a password of `ILuvM4th!`. cinnamon is the role of USER and so can only access endpoints starting with /employees. Surf to the following endpoints and notice the results

  - A route where cinnamon is denied access <http://localhost:2019/users/getusername>
  - A route cinnamon can access <http://localhost:2019/employees/employees>

- Guided Project: java-oauth2

- Project: java-shoppingcart
