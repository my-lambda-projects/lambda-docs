Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# Data Structures I

<span class="lead"> </span>

In this module, we will look at how to describe the runtime complexity of an operation using Big O notation. We will also learn about singly linked lists and how to implement a Singly Linked List class in Python. Lastly, we will learn about the stacks and queues as data structures.

**At the end of this module, you should be able to:**

-   define what runtime complexity is, differentiate between various classifications and categorize the performance of an algorithm using Big O notation
-   construct a singly linked list
-   implement queues and stacks with Python lists and a singly linked list

#### Pro Tip

“AI” solves the problem you give it - a system trained to play Tetris learned it could avoid losing by pausing.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=rEx9E_Oq8xg), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=7sk4jG83q80), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=j-fBJpSQ19g), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to define what runtime complexity is, differentiate between various classifications and categorize the performance of an algorithm using Big O notation

##### Overview

### What is an algorithm?

An algorithm is a set of instructions for accomplishing a task. Because of this broad definition, we could call every piece of code an algorithm.

### How do we measure how “good” an algorithm is?

After coming up with a first-pass solution to a problem, we need to measure how “good” our solution is. Will it stand up to the test of millions of users? Is it fast enough that our users will be blown away by how quickly they get their results? Or will torturously slow speeds cause lag that drives them all away?

When given a choice between different algorithms, we want to choose the most efficient algorithm (considering both *time* and *space* efficiency depending on our needs).

*Note: It is common for your first solution to work with a few items or users, but break as you add more. Making sure solutions scale is something that all developers must remain vigilant about.*

### What is Big O notation?

We need a way to talk about efficiency (number of operations in the worst case) in a more general sense.

Big O notation is a way of describing the rate of change in the execution speed of an algorithm when the data size increases. It is the agreed-upon terminology we use to describe how long an algorithm takes to run. It is a way of comparing different algorithm’s efficiencies.

The specific terms of Big O notation describe how fast the runtime grows (relative to the size of the input) with a focus on when the input gets extremely large.

Why do we focus on the growth of runtime versus exact runtime? The exact runtime is dependent on the specific computer that is running the algorithm, so we cannot compare efficiencies that way. By focusing on the general growth, we can avoid the differences in exact runtime between machines and environments.

We also talk about runtime relative to the input size because we need to express our speed in terms of *something*. So we show the speed of the algorithm in terms of the input size. That way, we can see how the speed reacts as the input size grows.

We don’t care about speed when the input size is small. The differences in speed are likely to be minimal when the input size is small. When the input size gets enormous, that is where we can see the differences in efficiency between different algorithms.

### Common Big O run times

Refer to the table below to see a list of the most common run times. The table is ordered from fastest to slowest.

![](https://tk-assets.lambdaschool.com/7e05ba4e-0889-4314-9db7-abaedc4e6d36_Untitled.png)

Besides the table, it’s also essential to look at the curves of these different run times.

![](https://tk-assets.lambdaschool.com/e4357b5f-1d63-44cd-b8a0-4957260ae9ec_Untitled1.png)

Again, `n` represents the size of the data, and on the chart above, `N` represents the number of operations. This visualization should help illustrate why `O(1)` or `O(log n)` is the most desirable.

*Note: Big O only matters for large data sets. An `O(n^3)` solution is adequate, as long as you can guarantee that your datasets will always be small.*

### A few examples

Let’s look at a few different examples of Python functions that print something to the output. For each of these, the input will be `items`.

#### Contanst Time `O(1)`

    def print_one_item(items):
        print(items[0])

Why is this constant time? Because no matter how large or small the input is (1,000,000 or 10), the number of computations within the function is the same.

#### Linear Time `O(n)`

    def print_every_item(items):
        for item in items:
            print(item)

Why is this classified as linear time? Because the speed of the algorithms increases at the same rate as the input size. If `items` has ten items, then the function will print ten times. If it has 10,000 items, then the function will print 10,000 times.

#### Quadratic Time `O(n^2)`

    def print_pairs(items):
        for item_one in items:
            for item_two in items:
                print(item_one, item_two)

Why is this quadratic time? The clue is the nested for loops. These nested for loops mean that for each item in `items` (the outer loop), we iterate through every item in `items` (the inner loop). For an input size of `n`, we have to print `n` \* `n` times or `n^2` times.

### What about constants?

What if we had a function like this?

    def do_a_bunch_of_stuff(items):
        last_idx = len(items) - 1
        print(items[last_idx])

        middle_idx = len(items) / 2
        idx = 0
        while idx < middle_idx:
            print(items[idx])
            idx = idx + 1

        for num in range(2000):
            print(num)

`print(items[last_idx])` is constant time because it doesn’t change as the input changes. So, that portion of the function is `O(1)`.

The while loop that prints up to the middle index is 1/2 of whatever the input size is; we can say that portion of the function is `O(n/2)`.

The final portion will run 2000 times, no matter the size of the input.

So, putting it all together, we could say that the efficiency is `O(1 +                   n/2 + 2000)`. However, we don’t say this. We just describe this function as having linear time `O(n)` because we drop all of the constants. Why do we cut all of the constants? Because as the input size gets huge, adding 2000 or dividing by 2 has minimal effect on the performance of the algorithm.

### Most significant term

Let’s consider the following function:

    def do_different_things(items):
        for item in items:
            print(item)

        for item_one in items:
            for item_two in items:
                print(item_one, item_two)

We could describe this function as `O(n + n^2)`; however, we only need to keep the essential term, which is `n^2`, so this would be `O(n^2)`. Why can we do this? Because as the input size (`n`) gets larger and larger, the less significant terms have less of an effect, and only the most significant term is important.

### Big O represents the worst-case

Let’s consider the following function:

    def search_for_thing(items, thing):
        for item in items:
            if item == thing:
                return True

        return False

What would the result be if it just so happens that the `thing` we are looking for in `items` is the very first item in the list? The function would only have to look at one item in `items` before returning. In this case, it would be `O(1)`. But, when we are talking about the complexity of a function, we usually assume the “worst case”. What would the “worst case” be? It would be if it were the last item in `items`. In that case, we would have to look through all the `items`, and that complexity would be `O(n)`.

*Note: When talking about runtime complexity in casual conversation, engineers often blur the distinction between big theta and big O notation. In reality, these are two distinct ways of describing an algorithm. Big theta gives both an upper and a lower bound for the running time. Big O only gives an upper bound. Refer the following articles to dive deeper: [Big-Theta notation](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation) and [Big-O notation](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation).*

### Do constants ever matter?

Complexity analysis with Big O notation is a valuable tool, and you should get in the habit of thinking about the efficiency of the algorithms you write and use in your code. However, just because two algorithms have the same Big O notation doesn’t mean they are equal.

Imagine you have a script that takes 1 hour to run. By improving the function, you can divide that runtime by six, and now it only takes 10 minutes to run. With Big O notation, `O(n)` and `O(n/6)` can both be written as `O(n)`, but that doesn’t mean it isn’t worth optimizing the script to save 50 minutes every time the script runs.

That being said, there is a term you should become familiar with: **premature optimization** ([xkcd: Optimization](https://xkcd.com/1691/)). Sometimes, you can sacrifice readability or spend too much time on something to improve its efficiency. Depending on the situation, it could be that having a finished product to iterate on is more important than maximally efficient code. It is your job as a developer to know when spending time making your code more efficient is necessary. You will always be making calculated tradeoffs between runtime, memory, development time, readability, and maintainability. It takes time to develop the wisdom to strike the right balance depending on the scenario.

##### Follow Along

Let’s look at some code snippets that exhibit some runtime classifications we’ll discuss in class.

    def foo(n):
        i = 1
        while i < n:
            print(i)
            i *= 2

First, let’s think about what the above function is doing. It’s printing `i`…but `i` is not being incremented by 1, as we might usually see. It’s *doubled* every time we run the loop. So, for example, if `n = 100`, then the final result would be…

    1
    2
    4
    8
    16
    32
    64

Or if `n = 10`, then we would print…

    1
    2
    4
    8

We can use the process of elimination to narrow down which runtime classification makes sense for this algorithm. The number of times the loop runs seems to vary based on the value of `n`, so this is NOT O(1).

We can also see from the above examples that the number of times the loop runs is increasing *slower* than the size of the input is increasing. `n` must be *doubled* before the loop will run one more time. We can eliminate classifications such as O(n log n), O(n^c), O(c^n), and O(n!).

The only two options left at this point are logarithmic and linear. Since the two rates of growth (input, the number of operations) are not the same, **this function must run in logarithmic time!**

##### Challenge

1.  Classify the run times of each of the following scenarios:

A. You are searching for a specific name in a phone book (that is sorted alphabetically). B. You meet someone, and they give you their phone number. You realize later that you forgot their name! To match their number with a name, you look through a phone book until you find their phone number.

1.  Classify the runtimes of each of the following functions:

A. Problem One

    def foo(n):
        sq_root = int(math.sqrt(n))
        for i in range(0, sq_root):
            print(i)

B. Problem Two

    def bar(x):
        sum = 0
        for i in range(0, 1463):
            i += 1
            for j in range(0, x):
                    for k in range(x, x + 15):
                        sum += 1

C. Problem Three

    def baz(array):
        print(array[1])
        midpoint = len(array) // 2
        for i in range(0, midpoint):
            print(array[i])
        for _ in range(1000):
            print('hi')

1.  Do both of these functions have the same runtime? *(Notice the difference between their inputs)*

A.

    def make_num_pairs(n):
        for num_one in range(n):
            for num_two in range(n):
                print(num_one, num_two)

B.

    def make_item_pairs(items):
        for item_one in items:
            for item_two in items:
                print(item_one, item_two)

------------------------------------------------------------------------

#### Learn to construct a singly linked list

The linked list data structure (both singly- and doubly-linked variants), while not used nearly as much as arrays, nonetheless is an important one for students to learn because it provides an alternative way to implement a data structure that students should be intimately familiar with at this point in the curriculum.

##### Overview

Linked lists are a data structure that are commonly used for holding lists of data. What’s another data structure we know of that is really good at doing this? If your mind went off to arrays, you’re exactly right! Why, then, are linked lists not a redundant data structure? As we’ll see when we actually implement a linked list, there are certain cases when a linked list is better compared to an array.

Whereas arrays store and index elements contiguously, each element of a linked list is stored in a node. Each node then has a reference (or a ‘pointer’) to the next node in the linked list. In this way, linked lists describe lists of things in a recursive fashion, while arrays describe lists of things in an iterative fashion.

##### Follow Along

Walk through and diagram an example of inserting a new element into a linked list that contains other elements.

##### Challenge

1.  Draw/model out inserting a new element into a linked list with only one element.
2.  Draw/model out how to traverse through a linked list in order to find a target value.
3.  Draw/model out how to traverse through a linked list in order to find the maximum value in the linked list.

------------------------------------------------------------------------

#### Learn to implement queues and stacks with Python lists and a singly linked list

Queues and stacks are very handy data structures with a myriad of uses, some of which we’ll see in a later lesson. The can be built using arrays or linked lists. What are the tradeoffs that result due to this choice?

##### Overview

Since you guys have seen Stacks before, Queues should be a piece of cake. Whereas a Stack added and removed elements in Last In First Out ordering, a Queue adds and removes elements in First In First Out ordering (just like a queue in real life). The last time you guys implemented a Stack, you undoubtedly utilized the Array built-in methods push and pop. You could use Array built-ins here in order to implement a Queue data structure, but for this go-around let’s leverage the linked list data structure in order to implement the Queue data structure.

##### Follow Along

Talk about associated queue methods and what queues are useful for.

##### Challenge

1.  Draw/model out enqueuing into a queue that uses a linked list as its underlying storage structure.
2.  Draw/model out dequeuing from a queue that uses a linked list as its underlying storage structure.

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Data Structures](https://github.com/LambdaSchool/data-structures)

    A repository where students explore and implement a number of data structures, namely linked lists, queues, binary search trees, and heaps.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Data Structures I for CSPT12 w/Elissa Thomas](https://youtu.be/FQHCKmU9vZc)**

    Defining runtime complexity, Big O notation, singly linked list, and implementing queues and stacks

-   [All previous recordings](/archive/CS/module/rec3MaMAY78iDm7ax)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    1.  Classify the run times of each of the following scenarios:

    A. You are searching for a specific name in a phone book (that is sorted alphabetically). B. You meet someone, and they give you their phone number. You realize later that you forgot their name! To match their number with a name, you look through a phone book until you find their phone number.

    1.  Classify the runtimes of each of the following functions:

    A. Problem One

        def foo(n):
            sq_root = int(math.sqrt(n))
            for i in range(0, sq_root):
                print(i)

    B. Problem Two

        def bar(x):
            sum = 0
            for i in range(0, 1463):
                i += 1
                for j in range(0, x):
                        for k in range(x, x + 15):
                            sum += 1

    C. Problem Three

        def baz(array):
            print(array[1])
            midpoint = len(array) // 2
            for i in range(0, midpoint):
                print(array[i])
            for _ in range(1000):
                print('hi')

    1.  Do both of these functions have the same runtime? *(Notice the difference between their inputs)*

    A.

        def make_num_pairs(n):
            for num_one in range(n):
                for num_two in range(n):
                    print(num_one, num_two)

    B.

        def make_item_pairs(items):
            for item_one in items:
                for item_two in items:
                    print(item_one, item_two)

-   Objective challenge:
    1.  Draw/model out inserting a new element into a linked list with only one element.
    2.  Draw/model out how to traverse through a linked list in order to find a target value.
    3.  Draw/model out how to traverse through a linked list in order to find the maximum value in the linked list.

-   Objective challenge:
    1.  Draw/model out enqueuing into a queue that uses a linked list as its underlying storage structure.
    2.  Draw/model out dequeuing from a queue that uses a linked list as its underlying storage structure.

-   Project: Data Structures
