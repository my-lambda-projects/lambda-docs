Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# Introduction to Python I

<span class="lead"> </span>

Learning new languages is not an uncommon task in the world of software development, and Python is a popular language in the field. This module will introduce students to Python basics, and use those to implement a simple project.

**At the end of this module, you should be able to:**

-   create a simple Python program that utilizes the basic types and data structures, uses correct syntax throughout, and employs conditionals and loops
-   compare and contrast the characteristics of Lists, Tuples, Sets, and Dictionaries in Python
-   write Python code that shows the ability to perform operations on each Lists, Dictionaries, Tuples, and Sets

#### Pro Tip

Be on time. It’s a mark of respect not to keep others waiting.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=KtYGuqq_irU), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=fxDQzub2AtI), or enable JavaScript if it is disabled in your browser.

-   [Python to JS cheatsheet](https://github.com/LambdaSchool/CS-Wiki/wiki/Javascript-Python-cheatsheet)

    Language feature examples in different languages

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to create a simple Python program that utilizes the basic types and data structures, uses correct syntax throughout, and employs conditionals and loops

This objective is designed to introduce students to how Python implements concepts and ideas they already know from previous languages.

##### Overview

##### The Point

Our primary aim for this part of your time at Lambda is to teach you to think like a computer scientist. Thinking like a computer scientist means incorporating some of the best parts of math, engineering, and natural science.

*Note: Learning to think like a computer scientist does not require that you be ‘good at math’. No matter what your previous experience is with mathematical thinking and what level of formal mathematical education you’ve received, we are 100% confident that you can learn to think like a computer scientist. However, by learning to **think** like a computer scientist, you will become better at math (although that’s a secondary benefit and not the point).*

<table><thead><tr class="header"><th>Field of Study</th><th>Features</th></tr></thead><tbody><tr class="odd"><td>Math</td><td>Use formal languages to denote ideas</td></tr><tr class="even"><td>Engineering</td><td>Design things, build systems, and test tradeoffs among alternatives</td></tr><tr class="odd"><td>Natural Science</td><td>Observe the behavior of complex systems, form hypotheses, and test predictions</td></tr></tbody></table>

Computer scientists think by using and combining these features.

But, above all, the most significant skill for a computer scientist is the ability to solve complex problems. Problem-solving means:

1.  defining problems
2.  reasoning about solutions
3.  expressing a solution

Everything we will show you about programming we view as an opportunity to **practice problem-solving skills**. Learning to program is a valuable skill on its own. On another level, by learning to program and understanding the fundamentals of computer science, you are receiving the preeminent “transferable skill”: **how to solve any complex problem**.

*Note: it’s valuable to distinguish between “theoretical” computer science and “experimental” computer science. In a natural science like physics, you can solve an equation to determine the theoretical position of a projectile in a vacuum, or you can conduct an experiment where you launch a projectile and measure where it lands. In computer science, a theoretical approach is writing a Big-O complexity analysis, where an experimental approach would be to run a function with 100,000 inputs and measure how long the operation took.*

##### What Is a Program

> A program is a sequence of instructions that specifies how to perform a computation. Think Python by Allen B. Downey

The computation could be anything. It could require you to get the length of one side of a triangle, to look for every instance of a certain word and to replace it, or to transform a color image into a black-and-white image.

Regardless of the programming language, every language is made up of a few basic instructions.

-   Input   - Receiving data from a keyboard, a file, the network, or some other device
-   Output   - Presenting data on a screen, saving it to a file, sending it over a network
-   Arithmetic and Logic   - Adding, subtracting, multiplying, dividing
-   Conditional execution   - Running the code given certain conditions
-   Repetition   - Executing repeatedly but with a slight modification

I know that seems like a short list, but most every program you’ve ever used, despite its complicated appearance comprises instructions that fit into these groups.

Why is it important to understand this? Because, regardless of the complexity of the problem you are dealing with, if you can break it down into small parts that fit into these categories, you can write a program to solve the problem.

##### Running Python

Refer to the following [guide](https://github.com/LambdaSchool/CS-Wiki/wiki/Installing-Python-3-and-pipenv) to get set up to run Python on your machine.

##### Basics

Let’s now get started with the absolute basics of Python. After going through the following sections, you should know enough Python that you can write simple programs.

###### Print

Now, we want to write our obligatory “Hello, World!” program. All that we need to do is to print “Hello, World!”.

To do this in Python, you write:

    >>> print('Hello World!')
    Hello World!
    >>>

This is an example of a simple **print statement**. Notice that the quotation marks denote the beginning and end of the text that you want displayed but they don’t show up in the result. The parentheses let you know that `print` is a function. We will talk more about functions later.

###### Arithmetic Operators

**Operators** are special symbols that represent computations like addition and multiplication.

<table><thead><tr class="header"><th>operator</th><th>computation</th></tr></thead><tbody><tr class="odd"><td><code class="highlighter-rouge">+</code></td><td>addition</td></tr><tr class="even"><td><code class="highlighter-rouge">-</code></td><td>subtraction</td></tr><tr class="odd"><td><code class="highlighter-rouge">*</code></td><td>multiplication</td></tr><tr class="even"><td><code class="highlighter-rouge">/</code></td><td>division</td></tr><tr class="odd"><td><code class="highlighter-rouge">//</code></td><td>floor division</td></tr><tr class="even"><td><code class="highlighter-rouge">**</code></td><td>exponentiation</td></tr><tr class="odd"><td><code class="highlighter-rouge">%</code></td><td>modulus</td></tr></tbody></table>

Here is an example of using all the operators shown above:

    >>> 30 + 6
    36
    >>> 40 - 4
    36
    >>> 6 * 6
    36
    >>> 72 / 2
    36.0
    >>> 6**2
    36
    >>> 36 % 35
    1
    >>>

###### Values and Types

A **value** is one of the basic building blocks that a program interacts with. So far, we’ve seen values like `6`, `36.0`, and `'Hello, World!'`.

Values belong to different **types**. For instance, `6` is an **integer**, `36.0` is a **floating-point number** and `'Hello, World!'` is a **string**. If you want to know what type a value has, the Python interpreter can tell you:

    >>> type(6)
    <class 'int'>
    >>> type(36.0)
    <class 'float'>
    >>> type('Hello, World!')
    <class 'str'>
    >>>

Notice the word “class” that gets output to the terminal. It uses class here in the sense of a category because a **type** is a category of values.

##### Variables, Expressions, and Statements

The most important feature of a programming language is the ability to manipulate and work with **variables**. A variable is a name that refers to a value.

###### Assignment Statements

An **assignment statement** creates a new variable and gives it a value. See below for an example.

    >>> greeting = 'Good afternoon, sir!'
    >>> x = 23
    >>> pi = 3.141592653589793
    >>>

I made three assignments in this example:

1.  I assigned a string to a new variable named `greeting`
2.  I assigned the integer 23 to `x`
3.  I assigned the (approximate) value of π to `pi`

###### Variable Names

A primary reason that Python is a well-loved programming language is its high readability. Programmers often point out that humans read code much more frequently than they write it. This leads us to conclude that how readable a language is crucial when testing the quality of a language.

Python programmers have developed a fairly complete set of Code Style guidelines and idioms to guide you while authoring code. In fact, you can open any Python interpreter and read “The Zen of Python” by Tim Peters by typing `import this`:

    >>> import this
    The Zen of Python, by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

With all this in mind, you can see why it is important for Python programmers (and all programmers) to choose meaningful variable names. That way, the names of the variables themselves serve as documentation for what it uses the variable for.

There is no limit to the length of a variable name. They can contain letters and numbers, *but they cannot start with a number*. It is possible to use uppercase letters, but convention dictates to only use lowercase letters for variable names. To separate words within a variable name, it is common to use the underscore character (`_`). Also, you cannot use Python keywords as variable names (like `class`, `return`, `def`, `yield`, etc.).

*Note: you **can** overwrite many Python keywords (this is **not** good).*

    >>> int
    <class 'int'>
    >>> int = 5
    >>> int
    5

*It is a common mistake for a beginner to write code that accidentally overwrites a Python keyword by doing something like this:*

    def print_list(list):
    for item in list:
    print(item)

###### Expressions and Statements

An **expression** is a combination of values, variables, and operators.

The following are legal expressions:

    >>> 36
    36
    >>> x
    23
    >>> x + 36
    59
    >>>

###### Script Mode

So far, all the examples we’ve seen have used Python in **interactive mode**, meaning that we are interacting directly with Python’s interpreter. Once you want to work with more than a few lines of code, using the interactive mode can be a bit of a hassle.

Instead of interacting directly with the interpreter, you can save code in a file called a **script** and then run the interpreter in **script mode** to execute the script. We should save Python scripts with the `.py` file extension.

One thing to know is that when you run a script, even though the interpreter evaluates your expressions, it doesn’t display the results unless you tell it to.

For example, in interactive mode, I could write:

    >>> kilometers = 50
    >>> kilometers * 2
    100
    >>>

But, in script mode, if I wanted to see the result of `kilometers *                   2`, I would have to write:

    kilometers = 50
    print(kilometers * 2)

###### Order of Operations

For mathematical operators, Python follows the mathematical convention. You might remember the acronym **PEMDAS** from your earlier school days.

Here is the order of precedence:

1.  **P**arentheses
2.  **E**xponentiation
3.  **M**ultiplication and **D**ivision
4.  **A**ddition and **S**ubtraction

In the example below, you can see how without the parentheses, the multiplication (`4 * 6`) is conducted before the addition (`2 +`). By placing parentheses around `2                   + 4`, we force that operation to be conducted before the multiplication.

    >>> 2 + 4 * 6
    26
    >>> (2 + 4) * 6
    36
    >>>

###### String Operations

You cannot perform mathematical operations on strings, even if the strings look like numbers.

This would not work in Python:

    '8' - '4'
    'hand'/'foot'
    'hundred'*'a million'

**However, there are two exceptions**, `+` and `*`. We use the `+` to **concatenate** strings (linking strings together end-to-end).

For example:

    >>> first = 'ice'
    >>> second = 'cream'
    >>> first + second
    'icecream'
    >>>

You can use the `*` operator to repeat strings. Be aware though that if one value is a string, the other has to be an integer.

For example:

    >>> 'Alright' * 3
    'AlrightAlrightAlright'
    >>>

###### Comments

Add notes to your programs to help explain what the program is doing.

We call these notes **comments**. You can put comments on their own line like this:

    ### compute the surface area of a cylinder
    surface_area = (2 * pi * radius) * (height + radius)

You can also put comments at the end of a line like this:

    surface_area = (2 * pi * radius) * (height + radius) # compute the surface area of a cylinder

You can also use multi-line strings as comments like this:

    '''
    Here is a
    multiline string
    that I am using as a comment
    '''
    """
    You can also use
    double quotes
    """

The most useful comments explain the *why* of the code and don’t explain *what* the code does. The reader should be able to figure out what the code does, but *why* it’s there may be less obvious.

##### Function Calls

We’ve already seen at least one **function call**:

    >>> type(36)
    <class 'int'>
    >>>

The name of this function is `type`. We call the expression inside the parentheses the function **argument**. For this function, the result is the argument’s type.

When talking about functions, we say that a function “takes” an argument and “returns” a result. We can also refer to the result as the **return value**.

##### Composition

Up to now, we’ve used a few different pieces of a program: variables, expressions, and statements. So far, we’ve used them in isolation. But, when writing an actual program, it doesn’t take long before you need to combine these pieces.

In programming, when we talk about taking small pieces and building larger functionality, we are describing **composition**.

Almost anywhere you can put a value, you can put an expression (which evaluates to a value). There is only one exception to this: the left side of an assignment expression has to be a variable name.

Like I said, we can put an expression anywhere we can put a value. For example, instead of this:

    >>> statement = 'Hello, ' + 'World!'
    >>> print(statement)
    Hello, World!
    >>>

You could write this:

    >>> print('Hello, ' + 'World!')
    Hello, World!
    >>>

##### Creating New Functions

So far, we’ve just been using functions that are built-in to Python. But we will need to create our own functions. A **function definition** specifies the name of a new function and the sequence of statements that run when we call the function.

For example:

    def print_lyrics():
        print("Oh yeah, I'll tell you something")
        print("I think you'll understand")
        print("Then I'll say that something")
        print("I wanna hold your hand")

`def` is a keyword in Python that shows that this is a function definition. The function name is `print_lyrics`. The rules for naming functions are the same as the rules for naming variables. The empty parentheses after the function name show that this function doesn’t take any arguments.

We call the first line of the function definition the **header**; we call the rest the **body**. The header must end with a colon and the body has to be indented. The [PEP-8](https://pep8.org/) convention (which we follow at Lambda) is to always indent by four spaces.

Also, notice that we used double quotes in the strings being passed as arguments to the print function. Most people use single quotes unless (like in this case) a single quote (which is also an apostrophe) shows up in the string.

*Note: we recommend using a [linter](https://en.wikipedia.org/wiki/Lint_%28software%29) when writing your python code. Your specific implementation details will change depending on your chosen IDE. This [article](https://code.visualstudio.com/docs/python/linting) shows how you can get linting set up in Visual Studio Code. A [simple internet search](https://www.google.com/search?q=linting+python+in+%22YOUR+IDE+NAME%22) will return other simple guides to help you get set up for your chosen IDE*

##### Why Functions

There are several reasons it is good to divide a program into functions instead of just a long series of independent statements. Here are a few of the best reasons:

1.  By creating a function, you can group statements that are part of the same process into a collection of statements. This makes your program much easier to read.
2.  Functions make your program smaller by eliminating repetition in your code.
3.  By grouping statements into functions and reusing the function throughout your program, if you need to change one statement, you only need to make that change in one part of your program.
4.  A well-designed function can often be useful in other programs. Once you write and debug it once, you can reuse it in other programs.

##### Simple Repetition

Anytime we want to repeat the same statement multiple times, we can do concisely by using a `for` statement.

    >>> for i in range(4):
    ...     print('Hello!')
    ...
    Hello!
    Hello!
    Hello!
    Hello!
    >>>

The syntax of a `for` statement is similar to a function definition. It has a header that ends with a colon and an indented body. Just like a function, the body can contain many statements.

We also call a `for` statement a **loop** because the execution flow runs through the body and then *loops* back to the top.

##### Boolean Expressions

A **boolean expression** is an expression that is *true* or *false*. `True` and `False` are special values that are of type `bool`, they are not strings.

    >>> 2 == 2
    True
    >>> 4 == 8
    False
    >>> type(True)
    <class 'bool'>
    >>> type(False)
    <class 'bool'>
    >>>

The `==` operator is a **relational operator** (Not to be confused with `=` which is an **assignment operator**.). Here are the other relational operators:

<table><thead><tr class="header"><th>Relational Operator</th><th>Explanation</th></tr></thead><tbody><tr class="odd"><td><code class="highlighter-rouge">x != y</code></td><td><code class="highlighter-rouge">x</code> is not equal to <code class="highlighter-rouge">y</code></td></tr><tr class="even"><td><code class="highlighter-rouge">x &gt; y</code></td><td><code class="highlighter-rouge">x</code> is greater than<code class="highlighter-rouge">y</code></td></tr><tr class="odd"><td><code class="highlighter-rouge">x &lt; y</code></td><td><code class="highlighter-rouge">x</code> is less than<code class="highlighter-rouge">y</code></td></tr><tr class="even"><td><code class="highlighter-rouge">x &gt;= y</code></td><td><code class="highlighter-rouge">x</code> is greater than or equal to <code class="highlighter-rouge">y</code></td></tr><tr class="odd"><td><code class="highlighter-rouge">x &lt;= y</code></td><td><code class="highlighter-rouge">x</code> is less than or equal to <code class="highlighter-rouge">y</code></td></tr></tbody></table>

##### Logical Operators

Python has three **logical operators**: `and`, `or`, and `not`.

    >>> True and True
    True
    >>> True and False
    False
    >>> False and False
    False
    >>> True or False
    True
    >>> True or True
    True
    >>> True or False
    True
    >>> False or False
    False
    >>> not True
    False
    >>> not False
    True
    >>>

##### Conditional Execution

When writing programs, we need the ability to adjust the behavior of the program based on the result of checking a condition.

The simplest and most common way to do that is by using an `if` statement:

    if x < 0:
        print('x is negative')

We call the boolean expression that comes after `if` the **condition**. If that expression evaluates to `True`, then the indented statement will run. If it evaluates to `False`, then nothing will happen.

Notice that `if` statements have the same structure as function definitions: a header followed by an indented body. There is not a limit to the number of statements you can include in the body, but there must be at least one.

##### Alternative Execution

Often, in your code, you have two distinct possibilities and you want the condition to determine which behavior occurs. To do that, you would write:

    if x < 0:
        print('x is negative')
    else:
        print('x is positive')

##### Chained Conditionals

What if there are more than two distinct possibilities? One way to deal with this is to use a **chained conditional**:

    if x < y:
        print('x is less than y')
    elif x > y:
        print('x is greater than y')
    else:
        print('x and y are equal')

There is no limit to the number of `elif` clauses, and the `else` clause is not required. However, if we include `else` it must appear at the end of the chain.

##### Nested Conditionals

You can always nest conditionals within other conditionals. For example, we could rewrite the previous **chained conditional** example like so:

    if x == y:
        print('x and y are equal')
    else:
        if x < y:
            print('x is less than y')
        else:
            print('x is greater than y')

*Note: although nested conditional are possible, and the indentation makes the structure clear, they can become difficult to read. It is often recommended to avoid them if you can. Whenever you have nested conditionals, you can often simplify them by using logical operators (`and`, `or`, `not`). That being said, there are those that hold the opposite opinion, so this is not a hard and fast rule, just a general stylistic recommendation.*

##### Short-Circuit Evaluation

When writing conditionals, it’s useful to understand how the ordering of your statements matters. For instance, let’s say we are checking if a number is five (albeit in a contrived way):

    def is_five(n):
        # If n is 0, the `and` will return immediately
        # avoiding the division by 0 error
        return n != 0 and 5 / n == 1

By placing the `n != 0` on the left-hand side, we ensure that if `n` does equal `0` the code will never try to evaluate `5 / n`.

##### Follow Along

Let’s open the python interpreter and try out some things.

### Exercise 1

First, in a print statement, what happens if we leave out one parenthesis, or both?

    >>> print"Hello, World!")
      File "<stdin>", line 1
        print"Hello, World!")
             ^
    SyntaxError: invalid syntax

If we leave the first parenthesis off, we receive a “SyntaxError” error for invalid syntax.

    >>> print("Hello, World!"
    ...
    ...

If we leave the last parenthesis off, the interpreter waits for the closing parenthesis when we hit return and doesn’t evaluate the statement.

    >>> print"Hello, World!"
      File "<stdin>", line 1
        print"Hello, World!"
             ^
    SyntaxError: invalid syntax
    >>>

If we leave off both parentheses, we receive an invalid syntax SyntaxError.

### Exercise 2

We know that you can use a minus sign to make a negative number like `-4`. What will happen if we try to put a plus sign before a number?

    >>> +2
    2
    >>> +8
    8
    >>>

It looks as though this is valid syntax. What about `4++4`?

    >>> 4++4
    8
    >>>

This also works. Does that surprise you? Can you explain why it works?

### Exercise 3

We know that `n = 42` is a legal assignment operation. What about `42 = n`? What do you think will happen here?

    >>> 42 = n
      File "<stdin>", line 1
    SyntaxError: cannot assign to literal
    >>>

We get a SyntaxError that tells us you cannot assign a value to a literal. Let’s try another case and see if we get the same error.

    >>> "42" = n
      File "<stdin>", line 1
    SyntaxError: cannot assign to literal
    >>>

This is what we would expect since `"42"` is also a literal value.

### Exercise 4

Let’s write a function together called `right_justify` that takes a string named `s` as a parameter and prints the string with enough leading spaces so that the last letter of the string is in column 70 of the display.

We need to define our function and add the functionality.

    >>> def right_justify(s):
    ...     return ((70 - len(s)) * ' ') + s
    ...
    >>>

You can see here that we are using the built-in `len` function to the get the length of the `s` parameter. We are taking 70 (the total number of characters we want in one line) and subtracting the length of the string that was passed in. We then use that value and multiplying it by the `' '` string literal. Lastly, we concatenate the string onto the end.

See below to see how our function is working:

    >>> right_justify('lambda')
    '                                                                lambda'
    >>> right_justify('computer science')
    '                                                      computer science'
    >>>

##### Challenge

### Exercise 1

Start the Python interpreter and use it as a calculator.

1.  How many seconds are there in 21 minutes and 15 seconds?
2.  How many miles are there in 5 kilometers?
3.  If you run a 5 kilometer race in 21 minutes and 15 seconds, what is your average pace (time per mile in minutes and seconds)?
4.  What is your average speed in miles per hour?
5.  Suppose the cover price of a book is $19.95, but bookstores get a 25% discount. Shipping costs $2.50 for the first copy and $1 for each additional copy. What is the total wholesale cost for 75 copies?

### Exercise 2

A function object is a value you can assign to a variable or pass as an argument. For example, `do_twice` is a function that takes a function object as an argument and calls it twice:

    def do_twice(f):
        """
        Takes a function and executes it twice.
        """
        f()
        f()

Here’s an example that uses `do_twice` to call a function named `print_spam` twice:

    def print_spam():
        print('spam')

    do_twice(print_spam)

1.  Type this example into a script and test it.
2.  Change `do_twice` so it takes two arguments, a function object and a value, and calls the function twice, passing the value as an argument.
3.  Define a function called `print_twice` that takes one argument and prints the value of that argument twice.
4.  Use the changed version of `do_twice` to call `print_twice` twice, passing `'spam'` as an argument.
5.  Define a new function called `do_four` that takes a function object and a value and calls the function four times, passing the value as a parameter. There should be only two statements in the body of this function, not four.

### Exercise 3

Fermat’s Last Theorem says that there are no positive integers a, b, and c such that

    a**n + b**n == c**n

for any values of n greater than 2.

1.  Write a function named `check_fermat` that takes four parameters—`a`, `b`, `c` and `n` —and checks to see if Fermat’s theorem holds. If `n` is greater than 2 and `a**n + b**n = c**n` the program should print, `"Holy smokes, Fermat was wrong!"` Otherwise the program should print, `"No, that doesn't work."`
2.  Write a function that prompts the user to input values for `a`, `b`, `c` and `n`, converts them to integers, and uses `check_fermat` to check whether they violate Fermat’s theorem.

------------------------------------------------------------------------

#### Learn to compare and contrast the characteristics of Lists, Tuples, Sets, and Dictionaries in Python

This objective is designed to introduce students to the similarities and differences Python Collections (compared to what they have implemented in previous languages).

##### Overview

### Lists

Like a string, a **list** is a sequence of values. In a string, the values are individual characters; in a list they can be of any type. We call the individual values in a list the **elements** or sometimes the **items**.

The simplest way to create a new list is to enclose the elements in square brackets `[` and `]`.

    [2, 4, 6, 8, 10]
    ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']

Here, I’ve made two lists. The first one is a list of numbers. The second one is a list of strings. The elements of a list don’t all have to be of the same type.

    [2, 'four', 6.0, '8', [5, 5]]

Here, I’ve included an integer, a string, a float, another string, and a list.

You can assign lists to variables:

    >>> cheeses = ['Cheddar', 'Edam', 'Gouda']
    >>> numbers = [123, 456]
    >>> empty = []
    >>> print(cheeses, numbers, empty)
    ['Cheddar', 'Edam', 'Gouda'] [123, 456] []
    >>>

To access an element from a list, you use the bracket operator. The expression inside the bracket specifies which index (and the indices start at 0) you want to access. Also, lists are mutable.

    >>> cheeses[0]
    'Cheddar'
    >>> numbers[1]
    456
    >>> numbers[1] = 789
    >>> numbers
    [123, 789]
    >>>

### Dictionaries

A **dictionary** is like a list, but more general. In a list, the indices are required to be integers; in a dictionary they can be (almost) any type.

A dictionary contains a collection of indices, which we call **keys**, and a collection of values. We associate each key with a single value. We call the association of a key and a value a **key-value pair** or sometimes an **item**.

A dictionary represents a one-to-one **mapping** from keys to values. So, it is often said, that each key “maps to” a value. As an example, we will build a very simple dictionary that maps from an English word to a Spanish word. In our case, the keys and values will all be strings.

The built-in function `dict` creates a new dictionary with no items. Because `dict` is the name of the built-in function, never use it as a variable name.

    >>> eng2sp = dict()
    >>> eng2sp
    {}
    >>>

The curly braces, `{}`, represent an empty dictionary. To add items to the dictionary, you can use square brackets like this:

    >>> eng2sp['one'] = 'uno'
    >>> eng2sp
    {'one': 'uno'}
    >>>

You can use the format of the output above to create a dictionary also. We could do:

    >>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
    >>> eng2sp
    {'one': 'uno', 'three': 'tres', 'two': 'dos'}
    >>>

Did you notice anything surprising by what it printed out? Notice that the order of the printed value is not the same as the order when we input the dict. The order of items in a dictionary is unpredictable. But, that shouldn’t be a problem because the elements of a dictionary are never indexed with integer indices (for that, you would use a list).

### Tuples

A tuple is a sequence of values. The values can be any type, and they are indexed by integers. They are a lot like lists. *The major important difference is that tuples are immutable* while lists are mutable.

To create a tuple, you write a comma-separated list of values:

    >>> my_tuple = 'a', 'b', 'c', 'd', 'e'
    >>> my_tuple
    ('a', 'b', 'c', 'd', 'e')
    >>>

Although it is unnecessary for the interpreter, it is common practice to enclose tuples in parentheses:

    >>> my_other_tuple = ('f', 'g', 'h', 'i', 'j')
    >>> my_other_tuple
    ('f', 'g', 'h', 'i', 'j')
    >>>

You can also create a tuple with the built-in `tuple` function:

    >>> t = tuple('lambda')
    >>> t
    ('l', 'a', 'm', 'b', 'd', 'a')
    >>>

Notice that if the argument is a sequence (a string, list, or tuple), the result is a tuple with all the individual elements of the sequence that we passed in.

Let’s prove that tuples are in fact immutable:

    >>> t[0] = 'L'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'tuple' object does not support item assignment
    >>>

### Sets

Python provides another built-in type, called a `set`, that behaves like a collection of dictionary keys with no values mapped to those keys. In a set, you cannot change items, you can only add items. Importantly, you also cannot duplicate items.

To create a set, you would write:

    >>> my_first_set = {'tree', 'building', 'sky'}
    >>> my_first_set
    {'building', 'sky', 'tree'}
    >>>

##### Follow Along

So, in summary we can compare the four most common collection data structures in Python with the following table:

<table><thead><tr class="header"><th>Type</th><th>Description</th><th>Mutability</th><th>Allows Duplicates</th></tr></thead><tbody><tr class="odd"><td>List</td><td>A sequence of values.</td><td>Mutable</td><td>Yes</td></tr><tr class="even"><td>Dictionary</td><td>A list of key-value pairs where the key can be (almost) any type.</td><td>Mutable</td><td>Yes</td></tr><tr class="odd"><td>Tuple</td><td>A sequence of values.</td><td>Immutable</td><td>Yes</td></tr><tr class="even"><td>Set</td><td>A collection of dictionary keys with no values mapped to those keys</td><td>Mutable</td><td>No</td></tr></tbody></table>

When deciding with collection type to use, it’s important to think about your needs for interacting with the data beforehand.

If the order of your data matters, then use a `List`.

If you want to store an immutable (unchangeable) list of data, then use a `Tuple`.

If you need to associate values with keys so you can look up data efficiently, then you should use a `Dictionary`.

If you just need to know if you already have a particular piece of data, order doesn’t matter, and you need not keep duplicates, then use a `Set`.

##### Challenge

As you write Python programs, it is important to know when to use a certain data structure and when to use something else. Write out an explanation of when and why you would use each data structure: a list, a dictionary, a tuple, and a set.

------------------------------------------------------------------------

#### Learn to write Python code that shows the ability to perform operations on each Lists, Dictionaries, Tuples, and Sets

##### Overview

Storing data inside a specific structure that allows you to interact with that data efficiently is important when writing a program. The following is a list of methods for each type of structure we’ve discussed so far. It is crucial that you are comfortable and familiar with these methods. You will use these methods frequently to access and manipulate data in your program.

Before we dive into each of the methods and how they work, it’s also important that you know how to make use of Python’s `dir()` and `help()` methods.

### `dir()`

`dir()` will print out all available properties and methods on an object. Below is an example where you can see all the available properties and methods on `list`:

    >>> dir(list)
    ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
    >>>

### `help()`

`help()` will print out the man page for whatever function you pass to it. Below, I’ve printed out the man page for the `list.append` function:

    >>> help(list.append)
    Help on method_descriptor:

    append(self, object, /)
        Append object to the end of the list.
    (END)

In order to exit the man page, press `q` on your keyboard.

### Lists

Below, you will find some methods available on the list data structure.

#### Methods

##### `append()`

`list.append(element)`

We use this method for appending and adding elements to a list. It is used to add elements to the last position of the list.

Example:

    >>> arr = ['math', 'biology', 1989, 2019]
    >>> arr.append(2021)
    >>> arr
    ['math', 'biology', 1989, 2019, 2021]
    >>>

##### `insert()`

`list.insert(position, element)`

This method inserts an element at a specified position.

Example:

    >>> arr = ['math', 'biology', 1989, 2019]
    >>> arr.insert(2, 2021)
    >>> arr
    ['math', 'biology', 2021, 1989, 2019]
    >>>

##### `extend()`

`list_one.extend(list_two)`

This method adds the contents of one list to the end of another list.

    >>> arr_one = [1, 2, 3, 4, 5]
    >>> arr_two = [1, 2, 3]
    >>> arr_one.extend(arr_two)
    >>> arr_one
    [1, 2, 3, 4, 5, 1, 2, 3]
    >>>

##### `sum()`

This method sums all the elements of a list.

Example:

    >>> arr = [1, 2, 3, 4, 5]
    >>> sum(arr)
    15
    >>>

*Note: sum will only work if all the elements of the list are numbers.*

##### `count()`

This method calculates the total number of occurrences of an element of the list.

`list.count(element)`

Example:

    >>> arr = [1, 1, 1, 2, 3]
    >>> arr.count(1)
    3
    >>> arr.count(2)
    1
    >>> arr.count(3)
    1
    >>>

##### `len()`

*Note: This method works for any container type: list, dictionary, set, range, tuple, etc.*

This method calculates the total length of a list that we pass in as an argument.

`len(list)`

Example:

    >>> arr = [1, 2, 3, 4, 5]
    >>> len(arr)
    5
    >>>

##### `index()`

This method returns the index of the first occurrence of the element passed in as an argument. You can also specify the start and end index where you want to conduct the search.

Example:

    >>> arr_two = ['a', 'b', 'c', 'd', 'e', 'a', 'b']
    >>> arr_two.index('a', 1)
    5
    >>> arr_two.index('a', 1, 2)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ValueError: 'a' is not in list
    >>>

##### `min()`

*Note: this method works on any **iterable** data structure.*

This method calculates the minimum of all the elements of the list.

`min(list)`

Example:

    >>> arr = [4, 3, 2.5, 7, 0.7, 9]
    >>> min(arr)
    0.7
    >>>

##### `max()`

*Note: this method works on any **iterable** data structure.*

This method calculates the maximum of all the elements of the list.

`max(list)`

Example:

    >>> arr = [4, 3, 2.5, 7, 0.7, 9]
    >>> max(arr)
    9
    >>>

##### `sort()`

This method sorts the list in ascending order. You can set the reverse flag to True if you want to sort in descending order.

`list.sort(reverse_flag)`

Example:

    >>> arr = [8, 4, 3, 9, 2, 1, 7, 6]
    >>> arr.sort()
    >>> arr
    [1, 2, 3, 4, 6, 7, 8, 9]
    >>> arr.sort(reverse=True)
    >>> arr
    [9, 8, 7, 6, 4, 3, 2, 1]
    >>>

##### `reverse()`

This method reverses the order of elements in the list (without sorting).

`list.reverse()`

Example:

    >>> arr = [8, 4, 3, 9, 2, 1, 7, 6]
    >>> arr.reverse()
    >>> arr
    [6, 7, 1, 2, 9, 3, 4, 8]
    >>>

##### `pop()`

This method removes an element from the list. If we provide no index, it removes the last element. This method returns the removed element (which is different from `del()` which returns `None`).

`list.pop(index)`

Example:

    >>> arr = [1, 2, 3, 4, 5]
    >>> arr.pop()
    5
    >>> arr
    [1, 2, 3, 4]
    >>> arr.pop(1)
    2
    >>> arr
    [1, 3, 4]
    >>>

##### `del()`

This method deletes an element from the list at the index we pass in.

`del list[index]`

Example:

    >>> arr = [1, 2, 3, 4, 5]
    >>> del arr[1]
    >>> arr
    [1, 3, 4, 5]
    >>>

##### `remove()`

This method removes the element we pass in from the list.

`list.remove(element)`

Example:

    >>> arr = ['a', 'b', 'c', 'd', 'e']
    >>> arr.remove('a')
    >>> arr
    ['b', 'c', 'd', 'e']
    >>>

### Dictionaries

#### Methods

##### `clear()`

This method removes all the elements from a dictionary.

`dictionary.clear()`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> car
    {'brand': 'Honda', 'model': 'CR-V', 'year': 2002}
    >>> car.clear()
    >>> car
    {}
    >>>

##### `copy()`

This method returns a copy of the specified dictionary.

`dictionary.copy()`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> carbon_copy = car.copy()
    >>> carbon_copy
    {'brand': 'Honda', 'model': 'CR-V', 'year': 2002}
    >>> car
    {'brand': 'Honda', 'model': 'CR-V', 'year': 2002}
    >>>

##### `fromkeys()`

This method returns a dictionary with the specified keys and values. The keys parameter is required, but the value parameter is optional. If we pass no value, the default value will be `None`.

`dict.fromkeys(keys, value)`

Example:

    >>> x = ('key1', 'key2', 'key3')
    >>> y = 1
    >>> new_dict = dict.fromkeys(x, y)
    >>> new_dict
    {'key1': 1, 'key2': 1, 'key3': 1}
    >>> dict_without_values = dict.fromkeys(x)
    >>> dict_without_values
    {'key1': None, 'key2': None, 'key3': None}
    >>>

##### `get()`

This method returns the value of the item with the specified key.

`dictionary.get(keyname, value)`

Keyname is required. The value parameter is optional, and this specifies the value to return if the specified key doesn’t exist. The default value to return if the key doesn’t exist is `None`.

Example:

    car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.get("model")
    >>> x
    'CR-V'
    >>>

##### `items()`

This method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.

The view object will reflect any future changes done to the dictionary.

`dictionary.items()`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.items()
    >>> x
    dict_items([('brand', 'Honda'), ('model', 'CR-V'), ('year', 2002)])
    >>>

##### `keys()`

This method returns a view object. The view object contains the keys of the dictionary, as a list.

The view object will reflect any future changes done to the dictionary.

`dictionary.keys`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.keys()
    >>> x
    dict_keys(['brand', 'model', 'year'])
    >>>

##### `pop()`

This method removes the specified item from the dictionary. The value of the removed item is the return value of this method.

`dictionary.pop(keyname, defaultvalue)`

Keyname is a required parameter and specifies the keyname of the item you want to remove. The second parameter allows you to specify a value to return if the specified key doesn’t exit. If this value isn’t specified and no item with the specified key is found, it raises an error.

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.pop("model")
    >>> x
    'CR-V'
    >>>

##### `popitem()`

This method removes and returns some (key, value) pair as a tuple.

`dictionary.popitem(keyname, defaultvalue)`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> car.popitem()
    ('year', 2002)
    >>> car
    {'brand': 'Honda', 'model': 'CR-V'}
    >>> car["price"] = 4000
    >>> car
    {'brand': 'Honda', 'model': 'CR-V', 'price': 4000}
    >>> car.popitem()
    ('price', 4000)
    >>> car
    {'brand': 'Honda', 'model': 'CR-V'}
    >>>

##### `setdefault()`

This method returns the value of the item with the specified key. If the key doesn’t exist, insert the key, with the specified value.

`dictionary.setdefault(keyname, value)`

The keyname parameter is required and specifies the keyname of the item you want to return the value from. The value parameter is optional. If the key exists, this parameter has no effect. If the key does not exist, this value becomes the key’s value.

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.setdefault("model", "Odyssey")
    >>> x
    'CR-V'
    >>> y = car.setdefault("color", "black")
    >>> y
    'black'
    >>> car
    {'brand': 'Honda', 'model': 'CR-V', 'year': 2002, 'color': 'black'}
    >>>

##### `update()`

This method inserts the specified items to the dictionary. The specified items can be a dictionary, or an iterable object.

`dictionary.update(iterable)`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> car.update({"color": "black"})
    >>> car
    {'brand': 'Honda', 'model': 'CR-V', 'year': 2002, 'color': 'black'}
    >>>

##### `values()`

This method returns a view object. The view object contains the values of the dictionary, as a list.

The view object will reflect any future changes done to the dictionary.

`dictionary.values()`

Example:

    >>> car = {
    ...     "brand": "Honda",
    ...     "model": "CR-V",
    ...     "year": 2002
    ... }
    >>> x = car.values()
    >>> x
    dict_values(['Honda', 'CR-V', 2002])
    >>> car["color"] = "black"
    >>> x
    dict_values(['Honda', 'CR-V', 2002, 'black'])
    >>>

### Tuples

#### Methods

##### `count()`

This method returns the number of times a specified value appears in the tuple.

`tuple.count(value)`

Example:

    >>> my_tuple = (1, 3, 4, 5, 2, 3, 4, 6, 7, 2)
    >>> x = my_tuple.count(4)
    >>> x
    2
    >>>

##### `index()`

This method finds the first occurrence of the specified value. It will raise an exception if the value is not found.

`tuple.index(value)`

Example:

    >>> my_tuple = (1, 3, 7, 2, 7, 5, 3, 2, 9, 3)
    >>> x = my_tuple.index(7)
    >>> x
    2
    >>>

### Sets

#### Methods

##### `add()`

This method adds an element to the set. If the element already exists in the set, it will not add the element.

`set.add(element)`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> fruits.add("orange")
    >>> fruits
    {'apple', 'orange', 'banana', 'cherry'}
    >>> fruits.add("banana")
    >>> fruits
    {'apple', 'orange', 'banana', 'cherry'}
    >>>

##### `clear()`

This method removes all elements in a set.

`set.clear()`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> fruits.clear()
    >>> fruits
    set()
    >>>

##### `copy()`

This method copies the set.

`set.copy()`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> x = fruits.copy()
    >>> x
    {'apple', 'banana', 'cherry'}
    >>>

##### `difference()`

This method returns a set that contains the difference between two sets. The returned set contains items that exist only in the first set, and not in both sets.

`set.difference(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> z = x.difference(y)
    >>> z
    {'banana', 'cherry'}
    >>> a = y.difference(x)
    >>> a
    {'google', 'microsoft'}
    >>>

##### `difference_update()`

This method removes the items that exist in both sets. It is different from the `difference()` method because that method *returns a new set*, without the unwanted items, and this method *removes* the unwanted items from the original set.

`set.difference_update(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> x.difference_update(y)
    >>> x
    {'banana', 'cherry'}
    >>>

##### `discard()`

This method removes the specified item from the set. It differs from the `remove()` method, because that method will *raise an error* if the specified item doesn’t exist, this method will not.

`set.discard(value)`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> fruits.discard("banana")
    >>> fruits
    {'apple', 'cherry'}
    >>> fruits.discard("orange")
    >>> fruits
    {'apple', 'cherry'}
    >>>

##### `intersection()`

This method returns a set that contains the similarity between two or more sets. The returned set contains only items that exist in both sets, or in all sets if the comparison is done with over two sets.

`set.intersection(set1, set2, ...)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> z = x.intersection(y)
    >>> z
    {'apple'}
    >>>
    >>> x = {"a", "b", "c"}
    >>> y = {"c", "d", "e"}
    >>> z = {"f", "g", "c"}
    >>> result = x.intersection(y, z)
    >>> result
    {'c'}
    >>>

##### `intersection_update()`

This method removes the items that are not present in both sets (or in all sets if the comparison is done between over two sets).

`set.intersection_update(set1, set2, ...)`

Example:

    >>> x = {"a", "b", "c"}
    >>> y = {"c", "d", "e"}
    >>> z = {"f", "g", "c"}
    >>> x.intersection_update(y, z)
    >>> x
    {'c'}
    >>> y
    {'d', 'c', 'e'}
    >>> z
    {'f', 'c', 'g'}
    >>>

##### `isdisjoint()`

This method returns `True` if none of the items are present in both sets, otherwise it returns `False`.

`set.isdisjoint(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "facebook"}
    >>> z = x.isdisjoint(y)
    >>> z
    True
    >>>
    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> z = x.isdisjoint(y)
    >>> z
    False
    >>>

##### `issubset()`

This method returns `True` if all items in the set exists in the specified set, otherwise it returns `False`.

`set.issubset(set)`

Example:

    >>> x = {"a", "b", "c"}
    >>> y = {"f", "e", "d", "c", "b", "a"}
    >>> z = x.issubset(y)
    >>> z
    True
    >>> 
    >>> x = {"a", "b", "c"}
    >>> y = {"f", "e", "d", "c", "b"}
    >>> z = x.issubset(y)
    >>> z
    False
    >>>

##### `issuperset()`

This method returns `True` if all items in the specified set exists in the original set, otherwise it returns `False`.

`set.issuperset(set)`

Example:

    >>> x = {"f", "e", "d", "c", "b", "a"}
    >>> y = {"a", "b", "c"}
    >>> z = x.issuperset(y)
    >>> z
    True
    >>> 
    >>> x = {"f", "e", "d", "c", "b"}
    >>> y = {"a", "b", "c"}
    >>> z = x.issuperset(y)
    >>> z
    False
    >>>

##### `pop()`

This method removes a random item from the set and returns the removed item.

`set.pop()`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> fruits.pop()
    'apple'
    >>> fruits
    {'banana', 'cherry'}
    >>>

##### `remove()`

This method removes the specified element from the set. This method is different from the `discard()` method because `remove()` will *raise an error* if the specified item doesn’t exist, and the `discard()` method *will not*.

`set.remove(item)`

Example:

    >>> fruits = {"apple", "banana", "cherry"}
    >>> fruits.remove("banana")
    >>> fruits
    {'apple', 'cherry'}
    >>>

##### `symmetric_difference()`

This method returns a set that contains all items from both sets, but not the items present in both sets. The returned set contains a mix of items that are not present in both sets.

`set.symmetric_difference(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> z = x.symmetric_difference(y)
    >>> z
    {'banana', 'cherry', 'microsoft', 'google'}
    >>>

##### `symmetric_difference_update()`

This method updates the original set by removing items that are present in both sets, and inserting the other items.

`set.symmetric_difference_update(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> x.symmetric_difference_update(y)
    >>> x
    {'banana', 'cherry', 'microsoft', 'google'}
    >>>

##### `union()`

This method returns a set that contains all items from the original set, and all items from the specified sets. You can specify as many sets as you want, separated by commas.

`set.union(set1, set2, ...)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> z = x.union(y)
    >>> z
    {'apple', 'microsoft', 'banana', 'cherry', 'google'}
    >>> 
    >>> x = {"a", "b", "c"}
    >>> y = {"f", "d", "a"}
    >>> z = {"c", "d", "e"}
    >>> result = x.union(y, z)
    >>> result
    {'b', 'f', 'd', 'a', 'c', 'e'}
    >>>

##### `update()`

This method updates the current set, by adding items from another set.

`set.update(set)`

Example:

    >>> x = {"apple", "banana", "cherry"}
    >>> y = {"google", "microsoft", "apple"}
    >>> x.update(y)
    >>> x
    {'apple', 'microsoft', 'banana', 'cherry', 'google'}
    >>>

##### Follow Along

We walked through many examples for each method above. If you haven’t already, open the interpreter and try out each method shown above using your own data.

##### Challenge

Complete the following either in a python script file or directly in the python interpreter:

### Lists

1.  Create a list
2.  Access list items
3.  Change the value of a list item
4.  Loop through a list
5.  Check if a list item exists
6.  Get the length of a list
7.  Add an item to the end of a list
8.  Add an item at a specified index
9.  Remove an item
10. Remove an item at a specified index
11. Empty a list
12. Use the `list()` constructor to make a list

### Dictionaries

1.  Create a dictionary
2.  Access the items of a dictionary
3.  Change the value of a specific item in a dictionary
4.  Print all key names in a dictionary, one by one
5.  Print all values in a dictionary, one by one
6.  Use the `values()` function to return values of a dictionary
7.  Loop through both keys and values, by using the `items()` function
8.  Check if a key exists
9.  Get the length of a dictionary
10. Add an item to a dictionary
11. Remove an item from a dictionary
12. Empty a dictionary
13. Use the `dict()` constructor to create a dictionary

### Tuples

1.  Create a tuple
2.  Access tuple items
3.  Change tuple values
4.  Loop through a tuple
5.  Check if a tuple item exists
6.  Get the length of a tuple
7.  Delete a tuple
8.  Use the `tuple()` constructor to create a tuple

### Sets

1.  Create a set
2.  Loop through a set
3.  Check if an item exists
4.  Add an item to a set
5.  Add multiple items to a set
6.  Get the length of a set
7.  Remove an item in a set
8.  Remove an item in a set by using the `discard()` method
9.  Remove the last item in a set by using the `pop()` method
10. Empty a set
11. Delete a set
12. Use the `set()` constructor to create a set

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Intro to Python](https://github.com/LambdaSchool/Intro-Python-I)

    *Note: This project spans two modules (modules 1 and 2). You should roughly try to finish the first half of the problems during module 1 and the second half of the problems during module 2.*

    Toy programs designed to learn the basics of Python.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Intro to Python I for CSPT12 w/Beej Jorgensen](https://youtu.be/vTVkvAhyOv4)**

    Learn to create a simple Python program that utilizes the basic types and data structures, uses correct syntax throughout, and employs conditionals and loops.

-   [All previous recordings](/archive/CS/module/recay2erzDlYUPSeO)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    ### Exercise 1

    Start the Python interpreter and use it as a calculator.

    1.  How many seconds are there in 21 minutes and 15 seconds?
    2.  How many miles are there in 5 kilometers?
    3.  If you run a 5 kilometer race in 21 minutes and 15 seconds, what is your average pace (time per mile in minutes and seconds)?
    4.  What is your average speed in miles per hour?
    5.  Suppose the cover price of a book is $19.95, but bookstores get a 25% discount. Shipping costs $2.50 for the first copy and $1 for each additional copy. What is the total wholesale cost for 75 copies?

    ### Exercise 2

    A function object is a value you can assign to a variable or pass as an argument. For example, `do_twice` is a function that takes a function object as an argument and calls it twice:

        def do_twice(f):
            """
            Takes a function and executes it twice.
            """
            f()
            f()

    Here’s an example that uses `do_twice` to call a function named `print_spam` twice:

        def print_spam():
            print('spam')

        do_twice(print_spam)

    1.  Type this example into a script and test it.
    2.  Change `do_twice` so it takes two arguments, a function object and a value, and calls the function twice, passing the value as an argument.
    3.  Define a function called `print_twice` that takes one argument and prints the value of that argument twice.
    4.  Use the changed version of `do_twice` to call `print_twice` twice, passing `'spam'` as an argument.
    5.  Define a new function called `do_four` that takes a function object and a value and calls the function four times, passing the value as a parameter. There should be only two statements in the body of this function, not four.

    ### Exercise 3

    Fermat’s Last Theorem says that there are no positive integers a, b, and c such that

        a**n + b**n == c**n

    for any values of n greater than 2.

    1.  Write a function named `check_fermat` that takes four parameters—`a`, `b`, `c` and `n` —and checks to see if Fermat’s theorem holds. If `n` is greater than 2 and `a**n + b**n = c**n` the program should print, `"Holy smokes, Fermat was wrong!"` Otherwise the program should print, `"No, that doesn't work."`
    2.  Write a function that prompts the user to input values for `a`, `b`, `c` and `n`, converts them to integers, and uses `check_fermat` to check whether they violate Fermat’s theorem.

-   Objective challenge:

    As you write Python programs, it is important to know when to use a certain data structure and when to use something else. Write out an explanation of when and why you would use each data structure: a list, a dictionary, a tuple, and a set.

-   Objective challenge:

    Complete the following either in a python script file or directly in the python interpreter:

    ### Lists

    1.  Create a list
    2.  Access list items
    3.  Change the value of a list item
    4.  Loop through a list
    5.  Check if a list item exists
    6.  Get the length of a list
    7.  Add an item to the end of a list
    8.  Add an item at a specified index
    9.  Remove an item
    10. Remove an item at a specified index
    11. Empty a list
    12. Use the `list()` constructor to make a list

    ### Dictionaries

    1.  Create a dictionary
    2.  Access the items of a dictionary
    3.  Change the value of a specific item in a dictionary
    4.  Print all key names in a dictionary, one by one
    5.  Print all values in a dictionary, one by one
    6.  Use the `values()` function to return values of a dictionary
    7.  Loop through both keys and values, by using the `items()` function
    8.  Check if a key exists
    9.  Get the length of a dictionary
    10. Add an item to a dictionary
    11. Remove an item from a dictionary
    12. Empty a dictionary
    13. Use the `dict()` constructor to create a dictionary

    ### Tuples

    1.  Create a tuple
    2.  Access tuple items
    3.  Change tuple values
    4.  Loop through a tuple
    5.  Check if a tuple item exists
    6.  Get the length of a tuple
    7.  Delete a tuple
    8.  Use the `tuple()` constructor to create a tuple

    ### Sets

    1.  Create a set
    2.  Loop through a set
    3.  Check if an item exists
    4.  Add an item to a set
    5.  Add multiple items to a set
    6.  Get the length of a set
    7.  Remove an item in a set
    8.  Remove an item in a set by using the `discard()` method
    9.  Remove the last item in a set by using the `pop()` method
    10. Empty a set
    11. Delete a set
    12. Use the `set()` constructor to create a set

-   Project: Intro to Python
