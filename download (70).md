Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Review](#review)

# Array and String Manipulation

<span class="lead"> </span>

**At the end of this module, you should be able to:**

-   recall the time and space complexity, the strengths and weaknesses, and basic operations of a static array
-   describe the differences between in-place and out-of-place algorithms
-   recall the time and space complexity, the strengths and weaknesses, and basic operations of a dynamic array

#### Pro Tip

Know your audience.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=dz5swTXBd_Q), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=HtCVECYa6E0), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=wjMpec22Qo4), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to recall the time and space complexity, the strengths and weaknesses, and basic operations of a static array

##### Overview

Python does not have a static array data type. However, lists are built on dynamic arrays. As you will see, dynamic arrays rely on an underlying static array to work. So while you won’t be creating and using this data structure directly, it is still essential to understand.

An array is a data structure that organizes items sequentially. In memory, each item in the array is stored right next to another item in the array.

Each position in an array has an index. The first position in an array has an index of 0.

##### Follow Along

### Time and Space Complexity

#### Lookup

To look up an item by index in an array is constant time (`O(1`). If you have the specific index of an object in an array, the computations to find that item in memory are all constant time as well.

#### Append

Adding an item to an array is constant time (`O(1)`). We always have a reference point to the last thing in a static array, so we can insert an item after the current end.

#### Insert

In the worst case, inserting an item in an array is linear time (`O(n)`). When you insert into an array, all the items — starting at the index we are inserting into — have to be shifted one index. These items have to be “moved over” to make room for the new item being inserted. The worst-case scenario is when we insert at the 0th index, and every item in the array must shift over.

#### Delete

In the worst case, deleting an item in an array is linear time (`O(n)`). For any item you delete (unless it is the last item), all of the items after that index have to be shifted over to fill the now blank spot in the array. Remember, arrays store data in sequential order, so if we delete an item, we cannot just leave that space blank. If we left the space blank, it would ruin the quick lookup time. To have the fast lookup time, we need to be able to rely on the distance from the start of the array to whatever index we are trying to access.

#### Space

The space complexity of an array is linear (`O(n)`). Each item in the array will take up space in memory.

### Strengths

Static arrays are great because they allow fast lookups and fast appends. No matter how long the array is, getting an item from a specific index is a constant time (`O(1)`) operation. Adding a new element to the end of an array is a constant time operation (`O(1)`).

### Weaknesses

The primary weakness of a static array is that it has a fixed size. You must have some knowledge about the size of the data you will be storing in advance because you need to specify the size of the static array when you create it.

Another weakness is the linear time insertions and deletions. Every time you insert or delete an item from a position other than the end, other items in the static array have to be shifted over so that all of the data remains sequentially stored.

### What data structures are built on static arrays?

The static array is a building block for many other data structures. The most notable is the dynamic array. A dynamic array allows you to use an array without specifying the array’s size when it is instantiated.

### What about array slicing?

You often encounter a scenario where you want to use a subset of items from an existing array. Array slicing is when you take a subset from an existing array and allocate a new array with just the items from the slice.

In Python, the syntax looks like this:

    my_list[start_index:end_index]

The default start index is 0, and if you leave off the end\_index, the slice will capture through the end of the list.

    my_list[:]  # This would be all of the items in my_list
    my_list[:5] # This would be the items from index 0 to 4
    my_list[5:] # This would be the items from index 5 to the end of the list

You might be wondering, what is the time and space complexity of slicing an array? Well, to understand what the complexity is, you need to know what is happening behind the scenes when you take a slice of an array. First, you are *actually allocating a new list*. Second, you copy all of the items in your slice from the original array into the newly allocated list. This means that you have an `O(n)` time cost (for the copying) and an `O(n)` space cost for the newly allocated list.

You must keep these facts in mind and account for them when using a slice in your code. It’s not a free operation.

##### Challenge

1.  Draw out what happens to a static array when you insert an item at the beginning of the array.
2.  Draw out what happens to a static array when you delete an item from the array’s beginning.

##### Dig Deeper

-   <https://www.hackerearth.com/practice/data-structures/arrays/1-d/tutorial/>  
-   <https://www.pythoncentral.io/how-to-slice-listsarrays-and-tuples-in-python/>  

------------------------------------------------------------------------

#### Learn to describe the differences between in-place and out-of-place algorithms

##### Overview

We sometimes refer to in-place algorithms as *destructive* algorithms, since the input’s original state is “destroyed” during the function call.

In general, an in-place function will only create additional variables that are O(1) space.

Out-of-place functions don’t make changes that are visible to other functions. Usually, out-of-place functions copy any data structures or objects before manipulating and changing them.

In Python, primitive values (integers, floating-point numbers, or characters) are copied when passed as arguments. More complex data structures (lists, heaps, or hash tables) are passed by reference.

You can avoid space cost of initializing or copying data structures by using an in-place algorithm. In-place usually have a `O(1)` space cost, however in-place algorithms usually cause side-effects. You have to balance these two considerations.

To be safe and avoid side-effects, you should use an out-of-place algorithm as your default choice. Only use an in-place algorithm if you have specific constraints on your space usage.

##### Follow Along

Here is an example of a function that triples each number in an input list. This function does this *in-place*:

    def triple_list_in_place(int_list):
        for idx, item in enumerate(int_list):
            int_list[idx] *= 3

        # No return statement because we've modified the original list in place.
        # There is no need to return another reference to the same list.

Let’s now do the same thing, but this time we will do it *out-of-place:*

    def triple_list_out_of_place(int_list):
        # Allocate a new list with enough room for all of the elements
        tripled_list = [None] * len(int_list)

        for idx, item in enumerate(int_list):
            tripled_list[idx] = item *= 3

        return tripled_list

Remember, out-of-place algorithms are considered safer and should be the default unless you’re working under space-constraints and cannot afford the extra space complexity.

##### Challenge

1.  In your own words, describe the difference between an in-place algorithm and an out-of-place algorithm.
2.  In your own words, explain when it is an excellent choice to use an in-place algorithm.

##### Dig Deeper

-   <https://www.techiedelight.com/in-place-vs-out-of-place-algorithms/>  

------------------------------------------------------------------------

#### Learn to recall the time and space complexity, the strengths and weaknesses, and basic operations of a dynamic array

##### Overview

One drawback of static arrays is that they have a fixed size, which means you have to decide the number of elements that your array can contain in advance.

A dynamic array is much better than a static array because of one thing: automatic resizing.

When you add more components, a dynamic array automatically grows. Therefore, you don’t have to choose the size in advance.

### Time and Space Complexity

#### Lookup

To look up an item by index in an array is constant time (`O(1`). If you have the specific index of an item in an array, the computations to find that item in memory are all constant time as well.

#### Append

Adding an item to an array is constant time (`O(1)`) in the average case. However, in the worst case, the cost is `O(n)` (this will be explained in more detail below).

#### Insert

In the worst case, inserting an item is linear time (`O(n)`). When you insert into an array, all the items — starting at the index we are inserting into — have to be shifted one index. These items have to be “moved over” to make room for the new item being inserted. The worst-case scenario is inserting at the 0th index, and every item in the array has to shift over.

#### Delete

In the worst case, deleting an item is linear time (`O(n)`). For any item you delete (unless it is the last item), all of the items after that index have to be shifted over to fill the now blank spot in the array. Remember, arrays store data in sequential order, so if we delete an item, we cannot just leave that space blank. If we left the space blank, it would ruin the quick lookup time. To have the fast lookup time, we need to be able to rely on the distance from the start of the array to whatever index we are trying to access.

#### Space

The space complexity of an array is linear (`O(n)`). Each item in the array will take up space in memory.

### Strengths

Dynamic arrays are great for three primary reasons. First, fast lookups. Just as with static arrays, it takes `O(1)` time to retrieve the element at a given index. Second, scaling. You can add as many things as you want, and the dynamic array automatically grows to accommodate them. Third, they work well with the cache. As with static arrays, dynamic arrays put items in memory right next to each other, allowing the effective use of caches.

### Weaknesses

Dynamic arrays have two primary weaknesses. First, worst-case appends are slow. It usually takes `O(1)` time to add a new element to the end of the dynamic array. But if the dynamic array has no space for the new item, it will need to expand, which will take `O(n)` time. Second, insertions and deletions are expensive. Elements are placed next to each other, just like with static arrays; therefore, adding or removing an object in the middle of the array requires other items to “scoot over,” which takes `O(n)` time.

##### Follow Along

### Dynamic Arrays in Python

In Python, dynamic arrays are called lists.

They look like this:

    high_temperatures = []
    high_temperatures.append(72)
    high_temperatures.append(73)
    high_temperatures.append(71)

### Size vs. Capacity

If you create a dynamic array, the implementation of the dynamic array provides an underlying static array. The initial capacity depends on the implementation, but let’s assume our implementation uses ten indices. Let’s imagine that we have added four things to our list. We can then determine that our dynamic array has a size of 4 and a capacity of 10.

The dynamic array stores an end index to track where the dynamic array will end and where the extra capacity will start.

### Doubling appends

What if we are trying to add an element, but our dynamic array’s capacity is already full?

Dynamic arrays automatically generate a new, larger underlying static array to make room. Typically twice as large.

Shouldn’t we extend the current array instead of making an entirely new one twice as large? The reason we don’t do this is that since we instantiated our array, the nearby memory was likely already allocated.

After we allocate the new twice-as-large array, we must copy each object into the new array.

Copying every element (`O(n)` time) is expensive! So whenever we add an object to our dynamic array that forces us to create a new underlying double-size array, it takes `O(n)` time for that append. This doubling append is the worst-case situation. Yet, in the best case (and the average case), the appends are `O(1)` time only.

### The amortized cost of doubling appends

The time cost of each individual “doubling append” costs `O(n)` because of copying each item to a new array.

Simultaneously, the amount of `O(1)` appends doubles each time before the next doubling append.

These two factors cancel each other out, and we may assume that each append has an *average* `O(1)` cost or amortized cost. It is good to be aware that we typically say dynamic arrays have a time cost of `O(1)` for appends. However, strictly speaking, this is only true for the average case. The worst-case append (the doubling append) is `O(n)`.

##### Challenge

1.  What type in Python is a dynamic array?
2.  In your own words, explain why the worst-case time cost of appending to a dynamic array is `O(n)`.
3.  What is the difference between the size of a dynamic array and the capacity of a dynamic array?

##### Dig Deeper

-   <https://www.youtube.com/watch?v=qTb1sZX74K0>  

------------------------------------------------------------------------

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Array and String Manipulation for CSPT15 with Tom Tarpey](https://youtu.be/DWqGc5E4SSs)**

    Lecture 11/10/2020

-   [All previous recordings](/archive/cs/module/recR43dkPzilEMXlE)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:
    1.  Draw out what happens to a static array when you insert an item at the beginning of the array.
    2.  Draw out what happens to a static array when you delete an item from the array’s beginning.
-   Objective challenge:
    1.  In your own words, describe the difference between an in-place algorithm and an out-of-place algorithm.
    2.  In your own words, explain when it is an excellent choice to use an in-place algorithm.
-   Objective challenge:
    1.  What type in Python is a dynamic array?
    2.  In your own words, explain why the worst-case time cost of appending to a dynamic array is `O(n)`.
    3.  What is the difference between the size of a dynamic array and the capacity of a dynamic array?
