Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Review](#review)

# Computer Memory Basics

<span class="lead"> </span>

**At the end of this module, you should be able to:**

-   understand random access memory (RAM) as it relates to data structures
-   convert back and forth from decimal to binary
-   understand how fixed-width integers are stored in memory
-   describe, in general terms, how arrays are stored in memory and the time complexity of lookups
-   describe character encoding and how strings are stored in memory

#### Pro Tip

Celebrate wrong answers, because that means someone’s about to learn!

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=K0gG1GLVTFE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=VQ4mUl7Qtas), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=guuwyw1r9sQ), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=gptCuOJEQDY), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Z7uX9oAetzU), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to understand random access memory (RAM) as it relates to data structures

##### Overview

When your computer runs your code, it has to keep track of all of the variables in your code. Your computer stores all of these variables in something called random access memory (RAM).

##### Follow Along

Sometimes RAM is referred to as “working memory” or just “memory.”

There is a distinction between “memory” and “storage”. “Persistent storage” or “disc storage” holds all files like videos, text documents, and applications. RAM is faster than storage but has less space. Storage is slower but has more space.

Think of RAM like a tall bookcase with a lot of shelves. Think of a typical furniture bookcase and imagine how many “shelves” or “spaces” or “locations” there are. For most modern bookcases, there are about 20. But for computers, they have between billions and trillions of “shelves.”

Those things you put on the shelves are called variables. And one variable, a string variable, might have something like this for an address: `3FL8S7pxx12g`. Each shelf’s number is called its **address.**

Each one of the “shelves” (memory addresses) in our “bookshelf” (RAM) holds 8 bits. You can think of each bit like a tiny switch that can either be “on” or “off.” “On” is represented by a `1`, and “off” is represented by a `0`. A collection of 8 bits is called a byte, so we can say that each slot in RAM holds either 8 bits or 1 byte.

The processor does all the work of the computer. In between the processor and the RAM is something called a memory controller. The memory controller has a direct connection to each slot or “shelf” in RAM. Through that connection, it can read and write to RAM.

The memory controller is connected directly to all the shelves of RAM. This direct connection is crucial because we can access the bits at memory address 0 then read the bits at address 918,873 without having to climb down the many levels in the bookshelf to read this other data. Since we can read data located at any memory address we want without having to climb down the bookshelf, we call such memory *Random* Access Memory.

A spinning hard drive (think of a record spinning on an old record player) does not directly connect to the very tiny bits of data stored on it. Instead, there’s a small mechanical thing called a “head” that physically moves along the disc’s surface to do the reading and writing. Since there’s no direct connection to the data, reading and writing on discs takes longer (the head’s mechanical movement takes time).

Computers are mainly concerned with speed, so they are optimized to get a boost when the processor can access nearby memory addresses in RAM. The processor has temporary storage where it keeps a copy of stuff we recently obtained from RAM (called a cache).

We can think of that block of memory addresses that the processor has decided to keep around as one large cache. It can get read from the processor faster than RAM.

Whenever the processor reads something (say, the player’s position in an old adventure game) out of RAM, it adds it to the cache to be able to use it again in the future. Then, when it needs something else from RAM, it will go to the cache for it. As you can see, the cache helps the processor by saving execution cycles required to go out and read something from RAM.

The processor, not RAM, has the actual cache. The memory controller keeps track of what goes into and comes out of the cache.

We can think of it in several ways. Perhaps, the processor can use the cache as a temporary area to keep a copy of its last actions just in case it needs to reread them.

There is one caveat — it is not as if “everything” goes out to RAM and then gets inserted into the cache. In reality, the cache holds only a handful of memory addresses from RAM. Also, note that these few memory addresses in the cache can be accessed faster than other storage locations.

##### Challenge

Draw a model of how a processor interacts with the cache, memory controller, and RAM whenever it needs to read or write from memory.

##### Dig Deeper

-   <https://en.wikipedia.org/wiki/Random-access_memory>  
-   <https://en.wikipedia.org/wiki/Memory_controller>  
-   <https://en.wikipedia.org/wiki/CPU_cache>  

------------------------------------------------------------------------

#### Learn to convert back and forth from decimal to binary

##### Overview

Computers use the binary number system, so we will represent all of our variables in the binary number system.

Instead of 10 digits like 1, 2, 3, 4, 5, 6, 7, 8, 9, and 0, the binary number system only has two possible digits, 1 and 0. Another way to think of it is that computers only have switches (bits) that can be in an “off state” or an “on state.”

##### Follow Along

Before we try to dig into understanding the binary number system, let’s review how the decimal number system works. Let’s look at the number “101” in decimal.

Even though there are two “1” digits in this number, they don’t represent the same quantity. The leftmost “1” represents one hundred, and the rightmost “1” represents one unit. The “0” in-between is in the tens place.

So this “101” in base ten represents “1 hundred, 0 tens, and 1 one.”

Also, notice how the *places* in base 10 (ones place, tens place, hundreds place, etc.) are *sequential powers of 10*:

-   10^0 = 1
-   10^1 = 10
-   10^2 = 100
-   10^3 = 1000

In a binary (base 2) number system, the *places* are sequential powers of 2:

-   2^0 = 1
-   2^1 = 2
-   2^2 = 4
-   2^3 = 8

So, what if “101” was in binary? What would it represent then? Well, if we read it right to left, we have a “1” in the ones place, a “0” in the twos place, and a “1” in the fours place. We add these values up (4 + 0 + 1) which equals 5.

Below, is a table that shows how to count up to 12 in binary and decimal:

<table><thead><tr class="header"><th>Decimal</th><th>Binary</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0000</td></tr><tr class="even"><td>1</td><td>0001</td></tr><tr class="odd"><td>2</td><td>0010</td></tr><tr class="even"><td>3</td><td>0011</td></tr><tr class="odd"><td>4</td><td>0100</td></tr><tr class="even"><td>5</td><td>0101</td></tr><tr class="odd"><td>6</td><td>0110</td></tr><tr class="even"><td>7</td><td>0111</td></tr><tr class="odd"><td>8</td><td>1000</td></tr><tr class="even"><td>9</td><td>1001</td></tr><tr class="odd"><td>10</td><td>1010</td></tr><tr class="even"><td>11</td><td>1011</td></tr><tr class="odd"><td>12</td><td>1100</td></tr></tbody></table>

##### Challenge

Convert the following decimal numbers into binary numbers:

1.  25
2.  63
3.  9
4.  111

##### Dig Deeper

-   <https://www.mathsisfun.com/binary-number-system.html>  
-   <https://www.mathsisfun.com/definitions/decimal-number-system.html>  

------------------------------------------------------------------------

#### Learn to understand how fixed-width integers are stored in memory

##### Overview

With 1 byte (8 bits), how many different numbers can we represent? The answer is 2^8 = 256! But how do we know this?

##### Follow Along

Let’s see if we can find a pattern:

-   With one bit, we can express two numbers (`0` and `1`)
-   With two bits, for each of the first numbers (`0` or `1`), we can put a `0` or a `1` after it, so we can express four numbers
-   With three bits, we can express eight numbers.

Every time we add a new bit, we double the number of possible numbers we can express in binary. This pattern can be generalized as `2^n`, and `2^8 = 256`.

Often, computers use 4 bytes (32 bits) to represent our variables and can express as many as 2^32 (over 4 billion) possible values. Similarly, computers may use 8 bytes (64 bits) to represent our variables and can express 2^64 (over 10 billion) possible values.

The 2^X in the binary number system is called the **bitsize**. Eight bytes of memory are called “8-bit”, and 16 bytes are called “16-bit,” etc.

Many integers take a fixed amount of space, no matter what number they might have in them.

So, if a variable represents a fixed-width integer, it doesn’t matter if it has the value `0` or `193,457`, the amount of space it takes up in RAM is the same.

The computer can store numbers like 3, 60000000, or -14 in 32 bits, one of the “fixed-width integers” we discussed earlier. All of these fixed-width integers take up constant space (O(1)).

Performing simple operations on them like dividing, multiplying, and addition takes constant time `O(1)`. So, we can think of fixed-width integers as being very space and time-efficient.

The cost of having such space and time-efficient storage for our numbers is that the numbers’ size is limited. The limit is 2^n possibilities, where n represents the number of bits.

With the fixed-width integer, like all data structures, we have to make a tradeoff. To get the time and space efficiency, we have to give up the flexibility of variable size numbers.

##### Challenge

1.  What is the number of possible integer values you can store with 4 bytes? How did you make that calculation?
2.  What is the number of possible integer values you can store with 8 bytes? How did you make that calculation?

##### Dig Deeper

-   <https://vladris.com/blog/2018/10/13/arithmetic-overflow-and-underflow.html>  

------------------------------------------------------------------------

#### Learn to describe, in general terms, how arrays are stored in memory and the time complexity of lookups

##### Overview

We figured out how to store a specific number, now how about two? Or three? This can be tough. Programming languages often let you store several numbers at once.

##### Follow Along

Let’s say we want to count the number of cups of coffee we drink every day. Let’s store each day’s coffee cup count as an 8-bit, fixed-width integer.

We can store our coffee cup counts alongside each other in RAM, starting at memory address 0.

By doing that, we formed an array. RAM is essentially already an array. Just like with each address in RAM, each element in an array has an index. For our simple example, the array element’s index is the same as its memory address in RAM.

Though, usually, we can’t just start an array right at memory address 0. Other programs on our computer are using RAM as well. Let’s imagine that your internet browser software is using the first five slots in memory. We would have to start our array below that at memory address 6. So, index 0 in our array would be at memory address 6. Index 1 would be at memory address 7, and so on.

What do we do if we want to get the coffee cup count at index 3 in our array? How do we know which memory address to access? It’s simple. You take the array’s starting memory address (6) and add the index we are looking for (3). This gets us 9. Now, by accessing the element at memory address 9, we are getting the element at index 3 in our array.

The general way to express this is: “address of nth item in array = address of array start + n”.

We can do this simple math because each slot in memory and the size of our coffee cup count are both 1 byte. But, this is not usually the case. Typically, we use 64-bit integers (8 bytes). To store an array of 64-bit integers, we must use eight memory address slots instead for each integer instead of just 1.

We can reuse the same math as we used before to access elements from our array, but now we need to add some multiplication: “address of nth item in array = address of array start + (n \* size of each item in bytes)”

Although this looks slightly more complicated, it doesn’t have an extra time cost. Remember that all the simple math we are using take O(1) time.

It would be best if you also remembered that because the memory controller gives us a direct connection to each slot in RAM, we can read and write to RAM in O(1) time.

What does this mean? It means that looking up the contents of an array (if you have the index) takes O(1) time. Fast lookups are a critical feature of arrays.

The way we’ve described accessing elements from our array only works if:

1.  Each item in the array has to take up the same number of bytes.
2.  The array has to be stored in contiguous slots in memory without any gaps or interruptions.

In other words, for a formula to access elements to be reliable, our arrays have to be predictable.

Like every other data structure, to get the benefits of fast lookups, we have to operate under certain constraints: same-size elements and uninterrupted chunks of memory.

##### Challenge

Let’s say you need to store an array of 64-bit integers. Your array needs to have enough capacity for 24 integers. How many 1-byte slots of memory need to be allocated to store this array?

##### Dig Deeper

-   <https://en.wikipedia.org/wiki/Array_data_type>  

------------------------------------------------------------------------

#### Learn to describe character encoding and how strings are stored in memory

##### Overview

In this example, we will store some strings. A string, as we know, is just a bunch of characters or letters. One straightforward way to store a string is an array, so let’s see how we can define some mappings to make it easier to store strings in arrays.

##### Follow Along

To use our 8-bit slots in memory, we need a way to encode each character in a string in 8-bits. One common character encoding to do this is called “ASCII”. Here’s how the alphabet is encoded in ASCII:

<table><thead><tr class="header"><th>Letter</th><th>Encoding</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td></tr><tr class="even"><td>B</td><td>01000010</td></tr><tr class="odd"><td>C</td><td>01000011</td></tr><tr class="even"><td>D</td><td>01000100</td></tr><tr class="odd"><td>E</td><td>01000101</td></tr><tr class="even"><td>F</td><td>01000110</td></tr><tr class="odd"><td>G</td><td>01000111</td></tr><tr class="even"><td>H</td><td>01001000</td></tr><tr class="odd"><td>I</td><td>01001001</td></tr><tr class="even"><td>J</td><td>01001010</td></tr><tr class="odd"><td>K</td><td>01001011</td></tr><tr class="even"><td>L</td><td>01001100</td></tr><tr class="odd"><td>M</td><td>01001101</td></tr><tr class="even"><td>N</td><td>01001110</td></tr><tr class="odd"><td>O</td><td>01001111</td></tr><tr class="even"><td>P</td><td>01010000</td></tr><tr class="odd"><td>Q</td><td>01010001</td></tr><tr class="even"><td>R</td><td>01010010</td></tr><tr class="odd"><td>S</td><td>01010011</td></tr><tr class="even"><td>T</td><td>01010100</td></tr><tr class="odd"><td>U</td><td>01010101</td></tr><tr class="even"><td>V</td><td>01010110</td></tr><tr class="odd"><td>W</td><td>01010111</td></tr><tr class="even"><td>X</td><td>01011000</td></tr><tr class="odd"><td>Y</td><td>01011001</td></tr><tr class="even"><td>Z</td><td>01011010</td></tr></tbody></table>

Since we can express characters as 8-bit integers, we can express strings as arrays of 8-bit characters.

For example, we could represent LAMBDA like so:

    L -> 01001100
    A -> 01000001
    M -> 01001101
    B -> 01000010
    D -> 01000100
    A -> 01000001

Each character, once it was encoded, could be stored as one 8-bit slot in memory.

##### Challenge

Draw out a model of a section of memory that stores the string `"Computer Science"` as an array of 8-bit ASCII characters.

##### Dig Deeper

-   <https://www.w3schools.com/charsets/ref_html_ascii.asp>  

------------------------------------------------------------------------

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[CSPT15 Computer Memory Basics with Tom Tarpey](https://youtu.be/vD1DEmxcpMw)**

    Lecture 11/04/2020

-   [All previous recordings](/archive/cs/module/recy2QANAS6Blpc5o)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Draw a model of how a processor interacts with the cache, memory controller, and RAM whenever it needs to read or write from memory.

-   Objective challenge:

    Convert the following decimal numbers into binary numbers:

    1.  25
    2.  63
    3.  9
    4.  111

-   Objective challenge:
    1.  What is the number of possible integer values you can store with 4 bytes? How did you make that calculation?
    2.  What is the number of possible integer values you can store with 8 bytes? How did you make that calculation?

-   Objective challenge:

    Let’s say you need to store an array of 64-bit integers. Your array needs to have enough capacity for 24 integers. How many 1-byte slots of memory need to be allocated to store this array?

-   Objective challenge:

    Draw out a model of a section of memory that stores the string `"Computer Science"` as an array of 8-bit ASCII characters.
