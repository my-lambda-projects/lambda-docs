Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Writing Better Solutions

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- evaluate a first-pass solution and reflect on its validity to decide if the solution needs revision
- apply techniques such as memoization or heuristics to improve an existing first-pass solution

#### Pro Tip

Before you put something on social media, ask yourself - “Would I be okay if this appeared on the front page of the New York Times?”

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [Video: Algorithms Overview](https://youtu.be/RP5PVTY3rRQ)

  Quick overview video introducing why algorithms are important and laying out how we’re going to be talking about solving algorithmic problems.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=1QCmUv4-sIc), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to evaluate a first-pass solution and reflect on its validity to decide if the solution needs revision

##### Overview

This objective is primarily about developing a framework for reflecting on your solution and justifying your decision to stop improving a solution. We can continually improve a solution given enough time or effort. But, in all cases, we are working under constraints. Our chief constraints are our current technical knowledge, our understanding of the problem, and the time we have available to solve the problem. This objective is also about the **R**eflect step of UPE**R**.

It’s tempting, once you have a solution, to stop and move on to your next task immediately. By doing so, you miss out on some vital learning. The best long-term way to improve your problem-solving abilities is by taking the time to review and reflect upon your solution and how you arrived at your solution before moving on. The **R**eflect step of UPER may be the most critical step of all.

During this step, you look deeply at your solution and ask yourself questions about the solution. Eventually, you must decide whether your solution is “good enough” or if you should continue iterating on the problem to improve your solution. How do you make that decision? How does a skilled problem-solver and programmer go about deciding and then justifying a decision about when a solution is “good enough”?

### Things to Be Looking At

During this step, it’s helpful to have categories in mind for the questions you ask and the actions you take. The main categories you look at are:

1.  Performance
    - What is the runtime and space complexity of your solution?
    - Is that an acceptable level of performance for the size of inputs that you can expect?
    - Is your input size constrained in a way that makes runtime complexity less critical?
2.  Readability & Cleanliness
    - Now that you’ve solved the problem one way, can you think of other ways to solve the problem?
    - Are any of the other ways shorter, more readable, or less complicated than the first way that you did it?
    - How readable is your solution? Can you change variable names, function names, or code structure to improve readability?
    - Are there any redundancies or unused code that you can remove? How DRY is your code?
3.  Edge Cases
    - Test your solution and verify that it solves the problem for both the main case and any edge cases.
    - Document any edge cases that are not covered by your solution and explain why they were not solved.
4.  Time Constraints
    - Do you have more time to improve this solution, or would you spend your time better by moving on to the next problem you are trying to solve?
    - Did you document anything that you did “hackily” because of time constraints?
    - Include why you couldn’t do it the “Right Way” and what you would need to do to make it “Right”.
5.  Documentation
    - Have you included adequate comments and documentation that will assist other programmers and your future self in easily using this code?
    - Have you documented the changes that you need to make in the future, so you don’t forget?
    - Have you documented the things that work for now, but you need to address in the future?
6.  Making Connections
    - Does this problem and solution remind you of any other problems that you’ve worked on or already solved? How are they similar or different?
    - Can you make any connections between this problem and something that you will do or have done in the “real-world”?
    - Can your solution also work for other problems that you are working on or have completed?
7.  Process
    - How would you rate your problem-solving process?
    - What would you do differently next time? What went right? What went wrong?

##### Follow Along

We now look at a problem statement and a first-pass solution and assess it using the framework above to justify improving it or leaving it as is.

### Problem Statement

Given a value `a` and an exponent `b`, compute the value of `aᵇ`.

### First-Pass Solution

    def rec_power(a, b):
        # Base case:
        # Anything raised to the power of 0 is 1
        if b == 0:
            return 1

        # Recursive case
        # Call function on `b-1`
        else:
            return a * rec_power(a, b-1)

### Our Evaluation

#### 1. Time Constraints

We have more time to improve this solution. Although we don’t have an unlimited amount of time to work on improvements, we can assume we have enough time to make at least one more iteration.

#### 2. Readability & Cleanliness

The problem is possible to solve iteratively, but upon reflection, this is a perfect problem to solve using recursion, and the solution is readable and concise.

One change that might help with readability is updating the variable names to make them more precise and more comfortable to read.

    def rec_power(base, exponent):
        # Base case:
        # Anything raised to the power of 0 is 1
        if exponent == 0:
            return 1

        # Recursive case
        else:
            return base * rec_power(base, exponent - 1)

By making our variable names more descriptive, our function is now easier to read and understand.

The `else` block here is unnecessary, but keeping or removing this is a matter of preference. Some programmers prefer to keep the `else` block because it can make the logic clearer, but this is a matter of opinion and preference. We will leave our `else` block.

#### 3. Edge Cases

One thing that we didn’t consider while working on our first-pass solution was the edge case of negative exponents. For a quick refresher on negative exponents, you can read [here](https://www.mathsisfun.com/algebra/negative-exponents.html). The inverse of multiplying is dividing. So, instead of multiplying, a negative exponent means how many times to divide by the number. So, 5<sup>-3</sup> is 1 / 5 / 5 / 5 or 0.008. Another way of thinking about negative exponents is to take 1 divided by the result of the positive exponent. So, 5<sup>-3</sup> is equal to 1 / (5<sup>3</sup>). With this understanding, let’s change our function to handle negative exponents.

    def rec_power(base, exponent):
        # Base case:
        # Anything raised to the power of 0 is 1
        if exponent == 0:
            return 1

        # Recursive case, NEGATIVE exponent
        elif exponent < 0:
            return 1 / (base * rec_power(base, -exponent - 1))

        # Recursive case, POSITIVE exponent
        else:
            return base * rec_power(base, exponent - 1)

What about if our exponent isn’t an integer? These are, in fact, possible (see [here](https://www.mathsisfun.com/algebra/exponent-fractional.html) for more information), but for this problem, we say that our `rec_power` is only for integer exponents. We need to change our function to make sure our exponent is an integer.

    def rec_power(base, exponent):
        # Verify that exponent is an integer
        try:
            val = int(exponent)
        except ValueError:
            print("exponent must be an integer")
            return

        # Base case:
        # Anything raised to the power of 0 is 1
        if exponent == 0:
            return 1

        # Recursive case, NEGATIVE exponent
        elif exponent < 0:
            return 1 / (base * rec_power(base, -exponent - 1))

        # Recursive case, POSITIVE exponent
        else:
            return base * rec_power(base, exponent - 1)

#### 4. Performance

This solution is `O(n)`. We know that because if your function only includes one recursive call, then the function has linear time complexity.

`O(n)` is an acceptable level of performance for this function and the expected size of inputs.

#### 5. Documentation

Does our function have enough documentation? I think we have helpful, brief, and descriptive comments that we’ve included already. However, we could make a note about adding support for fractional exponents.

    def rec_power(base, exponent):
        # Verify that exponent is an integer
        # TODO: This function does not support fractional exponents. Will add when necessary.
        try:
            val = int(exponent)
        except ValueError:
            print("exponent must be an integer")
            return

        # Base case:
        # Anything raised to the power of 0 is 1
        if exponent == 0:
            return 1

        # Recursive case, NEGATIVE exponent
        elif exponent < 0:
            return 1 / (base * rec_power(base, -exponent - 1))

        # Recursive case, POSITIVE exponent
        else:
            return base * rec_power(base, exponent - 1)

#### 6. Making Connections

You may have noticed that the Counting Stairs problem is similar to finding the `n`<sup>th</sup> number in the Fibonacci Sequence. It is similar because we need the previous two results to get the new result.

#### 7. Process

This problem was solved using the UPER process. This objective is focused primarily on the **R**eflect step. Still, in order to solve the problem, we had to first **U**nderstand the problem, make a **P**lan for a first-pass solution, **E**xecute our first-pass solution, and then **R**eflect upon our solution to make improvements.

##### Challenge

Below are a problem statement and an example solution. Follow the process outlined above to analyze the first-pass solution. Justify why we should or should not iterate on the solution again.

### Problem Statement

Create a function that takes a list containing **nested lists** as an argument. Each sublist has 2 elements. The first element is the numerator, and the second element is the denominator. Return the sum of the fractions rounded to the nearest whole number.

**Examples:**

    sum_fractions([[18, 13], [4, 5]]) -> 2
    sum_fractions([[36, 4], [22, 60]]) -> 9
    sum_fractions([[11, 2], [3, 4], [5, 4], [21, 11], [12, 6]]) -> 11

**Notes:**

Your result should be a number, not a string.

### Example Solution

    def sum_fractions(lst):
        sum = 0
        for i in range(0, len(lst)):
            for y in range(0, len(lst[1])-1):
                sum += lst[i][y] / lst[i][y+1]
        return round(sum)

---

#### Learn to apply techniques such as memoization or heuristics to improve an existing first-pass solution

##### Overview

### Hard Algorithms

Most algorithms are efficient, meaning they run in at least polynomial time (`O(n^2)`). However, some algorithms do not have a polynomial-time solution (see the [traveling salesman problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)). However, some algorithms give approximate solutions. We cannot consider these types of algorithms correct or complete because the answer is not always exact. These algorithms use heuristics to approximate the solutions.

### What is a heuristic?

In computer science, a heuristic is a technique that allows you to solve a problem faster than you would by using a classic method. Or, when a classic method cannot return an _exact_ answer, a heuristic technique would return an _approximate_ answer. These techniques involve tradeoffs between speed and precision. Another way to think about it is that a heuristic produces a _“good enough”_ solution when an _exact_ solution would either take too long or is not possible to compute.

Heuristics are rule-based techniques such as “always turn left,” “go to the next closest city,” or “pick the most valuable jewel.” These types of rule-bases techniques can often overlap with first-pass techniques like greedy solutions.

### What is memoization?

Memoization is a technique that can make algorithms more efficient by storing the results of computations and returning the stored results instead of duplicating computations. We often use this technique when recursive functions have overlapping recursive cases. Memoization makes it so only the first call of a function with the same inputs incurs the full cost of the call. One thing to know is that memoization increases the time efficiency of a function and decreases the space efficiency (by storing or caching computation results).

This simple recursive factorial algorithm below should look familiar:

    def recursive_factorial(n):
        if n is 0:
            return 1
        else:
            return n * recursive_factorial(n – 1)

The above function is a non-memoized version, and every top-level call to this function incurs the full computational cost. So, if we call `recursive_factorial(5)` and then later call `recursive_factorial(4)`, both calls have to compute `recursive_factorial(4)`.

We can use a lookup table to memoize this function.

    cache = {}

    def recursive_factorial(n):
        if n is 0:
            return 1
        elif n in cache:
            return cache[n]
        else:
            x = n * recursive_factorial(n – 1)
            cache[n] = x
            return x

Now if we invoke:

    recursive_factorial(5)
    recursive_factorial(4)

On the second call, the function retrieves the answer from the lookup table instead of computing it a second time.

Let’s look at the visualization below to verify that this is the case:

![Memoized Recursive Factorial Function Visualized](https://tk-assets.lambdaschool.com/faf9124f-8f10-4fce-ab78-1997d1411ec9_S2-M4-O2-Memoized-Recursive-Factorial.gif)

Notice how on the second call, because `4` is in `cache`, our function returns the value associated with `cache[4]`.

##### Follow Along

Let’s look at the “Climbing Stairs” problem and use memoization to improve the solution.

### Problem Description

> You are climbing a staircase. It takes `n` steps to reach the top.
>
> Each time, you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
>
> **Note:** Given `n` will be a positive integer.
>
> **Example 1:**
>
>     Input: 2
>     Output: 2
>     Explanation: There are two ways to climb to the top.
>     1. 1 step + 1 step
>     2. 2 steps
>
> **Example 2:**
>
>     Input: 3
>     Output: 3
>     Explanation: There are three ways to climb to the top.
>     1. 1 step + 1 step + 1 step
>     2. 1 step + 2 steps
>     3. 2 steps + 1 step

### Current Solution

    def climb_stairs(current, desired):
        if current > desired:
            return 0
        if current == desired:
            return 1
        return climb_stairs(current+1, desired) + climb_stairs(current+2, desired)

### Improving our Solution with Memoization

In the current solution, which we show above, we redundantly calculate for every step. Instead of making duplicate calculations, we can store the result at each step in a Python dictionary and directly return the result from the dictionary whenever the function needs the result from that step. By doing this, we are reducing the time complexity of our algorithm from exponential (`O(2^n)`) to linear (`O(n)`).

Let’s change our previous solution to use memoization.

    def climb_stairs(current, desired, cache = {}):
        if current > desired:
            return 0
        if current == desired:
            return 1
        if current not in cache:
            cache[current] = climb_stairs(current + 1, desired, cache) + climb_stairs(current + 2, desired, cache)
        return cache[current]

Now, before we call the recursive case, we check if we’ve already solved that case by looking in our `cache` dictionary. If we’ve already computed the result for that case, we return the result stored in `cache` and do not have to repeat the computation.

Let’s visualize calling our changed function and see how it differs from our solution without using memoization.

![Climb Stairs Memoized Visualization](https://tk-assets.lambdaschool.com/faf00166-33f0-43f4-8304-f40e10638047_S2-M4-O2ClimbStairsMemoizedVisualization.gif)

You’ll notice that the call stack gets built up the same as the unmemoized version, but as the results get returned, it caches them. Later, when the function would’ve repeated computations with an unmemoized version, our memoized function returns the result from the cache instead.

##### Challenge

Use memoization to improve the efficiency of the function below.

    def recursive_fib(n):
        if n < 1:
            print("Incorrect input.")
        elif n == 1:
            return 0
        elif n == 2:
            return 1
        else:
            return recursive_fib(n - 1) + recursive_fib(n - 2)

Test your solution with large inputs to make sure you’ve correctly improved the efficiency using memoization.

##### Dig Deeper

- [Interview Cake: Memoization](https://www.interviewcake.com/concept/java/memoization)
- [Wikipedia: Memoization](https://en.wikipedia.org/wiki/Memoization)
- [Wikipedia: Heuristics](<https://en.wikipedia.org/wiki/Heuristic_(computer_science)>)
- [Analysis - Problem Solving with Algorithms and Data Structures using Python](https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/toctree.html)  
  Several approaches to solving the same problem are analyzed using Big O notation.
- ["Only Once" Array Problem - First-Pass Solution](https://youtu.be/9_3-PuzH26A)
- ["Only Once" Array Problem - Improved Solution](https://youtu.be/Fy8b5YAYzw4)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Algorithms](https://github.com/LambdaSchool/cs-module-project-algorithms)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Algorithms Writing Better Solutions for CSPT12 w/Beej Hall](https://youtu.be/ig4mJlKY_S0)**

  • Evaluate a first-pass solution and reflect on its validity to decide if the solution needs revision. • Apply techniques such as memoization or heuristics to improve an existing first-pass solution.

- [All previous recordings](/archive/CS/module/recsvJCzPlM2X63ZX)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Below are a problem statement and an example solution. Follow the process outlined above to analyze the first-pass solution. Justify why we should or should not iterate on the solution again.

  ### Problem Statement

  Create a function that takes a list containing **nested lists** as an argument. Each sublist has 2 elements. The first element is the numerator, and the second element is the denominator. Return the sum of the fractions rounded to the nearest whole number.

  **Examples:**

      sum_fractions([[18, 13], [4, 5]]) -> 2
      sum_fractions([[36, 4], [22, 60]]) -> 9
      sum_fractions([[11, 2], [3, 4], [5, 4], [21, 11], [12, 6]]) -> 11

  **Notes:**

  Your result should be a number, not a string.

  ### Example Solution

      def sum_fractions(lst):
          sum = 0
          for i in range(0, len(lst)):
              for y in range(0, len(lst[1])-1):
                  sum += lst[i][y] / lst[i][y+1]
          return round(sum)

- Objective challenge:

  Use memoization to improve the efficiency of the function below.

      def recursive_fib(n):
          if n < 1:
              print("Incorrect input.")
          elif n == 1:
              return 0
          elif n == 2:
              return 1
          else:
              return recursive_fib(n - 1) + recursive_fib(n - 2)

  Test your solution with large inputs to make sure you’ve correctly improved the efficiency using memoization.

- Project: Algorithms
