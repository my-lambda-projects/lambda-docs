Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

- [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

- [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
- [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

- [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
- [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
- [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

- [REST](/csannex/module/rec7YHjLuXabdlhof/)
- [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
- [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

- [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
- [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

- [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

- [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
- [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
- [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
- [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
- [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
- [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
- [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

- [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

- [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
- [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

- [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
- [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
- [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

- [REST](/csannex/module/rec7YHjLuXabdlhof/)
- [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
- [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

- [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
- [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

- [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

- [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
- [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
- [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
- [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
- [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
- [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
- [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Operating Systems

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- describe the major operating systems and their relative strengths
- clearly describe the boot process
- describe the role and function of the kernel, processes, and threads
- clearly describe the role of memory management, drivers, and filesystems

#### Pro Tip

Code is easy, people are hard.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [Video: Operating Systems introduction](https://youtu.be/RQ0cu_vbCPw)

  Discussion of operating system fundamentals

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe the major operating systems and their relative strengths

There are three operating systems that are primarily popular on general purpose computers - Windows, Mac OS X, and Linux.

There are two operating systems that are essential for popular handhelds–Android and iOS.

There are dozens of UNIX variants for simpler processors available. Typically when working with a small dedicated cpu (like an ARM CPU on an IoT device), the operating system supported for that device has been defined by the manufacturer of the device and is a subset of Linux.

Each operating system has its own advantages and disadvantages. Let’s examine some of their strengths.

##### Overview

### Windows

Original popular OS for consumers, no permissions enabled fast and easy development, high performance for games and other user applications. Became a difficult model to maintain with the rise of the internet, leading to many revisions.

Backwards compatibility is the hallmark of Windows, which causes endless headaches for modern developers.

### Linux

Started by Linus Torvalds, who was at the time a student of Andrew Tanenbaum’s, the Linux kernel is a copy of the MINIX kernel, which had been created by his instructor. MINIX is copy of the POSIX, an industry standardized system interface that was originally released in 1988. At the time there were many variants of UNIX, all limited to mainframe computers like VAX and PDP systems. The core of UNIX at this time is POSIX, which is the basis for essentially every successful operating system except Windows.

There are dozens of Linux forks at this time, called distros. Ubuntu is the most famous and successful of these, and unless you want to build up a career in system administration it is not necessary to learn any others. The basics of the Linux operating system depend on a few basic philosophies - processes that accept streams of text as input and produce streams of text as output (pipes), file descriptors as references to device drivers and other hardware (including individual files stored on a permanent storage medium), and security enforced by basic access controls applied to every component of the system.

Development paradigms:

- C and C++ native development.

- Management of symbolic and dynamic links via /usr/lib and /usr/local/lib and /usr/include and many more. Dependencies in linux are stored in files with specific paths, and can either be built natively using `gcc` or loaded using package management.

Technologies you should familiar with:

- Bash and shell scripting
- SSH
- System calls

Technologies to be secondarily familiar with

- Network programming

### macOS (previously Mac OS X)

macOS is another fork of UNIX, now called Darwin but previously FreeBSD, which was created in the 90s by Berkely (Berkeley Software Distribution). OS X features a kernel and basic system libraries that are nearly identical to Linux, with many small differences. OS X’s graphics layer, Cocoa, differs substantially from Linux graphics layers, features much greater reliability and consistency, and uniquely supports development in Objective-C and Swift.

> Infographic: [Unix variant family tree](https://en.wikipedia.org/wiki/History_of_Unix#/media/File:Unix_history-simple.svg)

Technologies you need to be familiar with:

- XCode
- Objective-C
- Interface builder

##### Follow Along

Instructor will describe the major operating systems and their relative strengths.

##### Challenge

Explain the following to someone in class, in your house, or on the phone. If no one is available, any house plant will do.

(The answers to the below questions aren’t necessarily in the above text.)

- Which of the Big Three is your favorite OS? Why?

- What did the Macintosh computer run as an OS before it ran macOS/OS X?

  - What were some of the drawbacks to this old OS?

- Why is C a popular language for writing operating systems?

---

#### Learn to clearly describe the boot process

“Booting up” a computer refers to the process of loading a computer’s operating system into memory so that other applications can be run. The process is relatively similar for each of the major operating systems. Major steps of the boot process are described below.

##### Overview

### Basic Input/Output System (BIOS)

When your computer first boots, it provides power to various electronics components according to the design of the hardware. As each component powers up it executes a Power On Self Test (_POST_). If POST succeeds, a very small operating system is activated with low level drivers to read and write memory, hard disks, simple display output, and potentially network cards.

The BIOS attempts to read the first sector of the boot disc. In the first sector is the Boot Loader, which shows the BIOS which hard disk sector to execute first in order to activate the real operating system.

In Windows, the Boot Loader is called the Master Boot Record. In Linux, it is GRUB or LILO. OS Xs Boot Loader is entirely proprietary.

### Boot-loader

The first-stage boot loader is stored in the BIOS and generally reads the first sector from the boot disk which contains a small program for continuing to load. The small program (usually just a few hundred bytes of machine code) loads and executes the second-state boot loader.

The second-stage, more-complicated boot loader (e.g. GRUB) then does the heavy lifting of loading the rest of the OS. Once the kernel is loaded, the boot loader transfer control to it to continue the boot process.

### Kernel Boot Process

Once the kernel has been loaded, it sets up the execution environment for future processes, initializes hardware drivers, and then switches to _multiuser_ mode.

At this point, it is free to initialize other services that the owner has configured, e.g. MongoDB, sshd, etc.

And finally a login prompt is presented.

##### Follow Along

The instructor will discuss the process by which a computer boots.

##### Challenge

Explain the following to someone in class, or in your house, or on the phone. If no one is available, any house plant will do.

(The answers to the below questions aren’t necessarily in the above text.)

- Why is a first-stage boot loaded necessary? Why not just load the entire secondary bootloader from the start?

- Why is a boot loader necessary at all? Why not just load the kernel directly?

---

#### Learn to describe the role and function of the kernel, processes, and threads

Once we have booted up our machine, how does it actually manage all of the different applications we want run? Because computers have finite resources, the kernel helps manage what resources are allocated to different tasks (otherwise known as processes or threads). How it does this is described in more detail below.

##### Overview

### Kernel

The Kernel is a compiled program that runs the CPU and every piece of fundamental hardware and software in your computer. The Windows and OS X kernels are completely secret and proprietary, but the Linux kernel is available on github (btw, Linus Torvalds also built Git)!

[Linux Kernel](https://github.com/torvalds/linux)

This enables curious developers to build and install a new kernel to their own computer. This is the only opportunity for this outside of private employment with Microsoft or Apple.

### Processes

Every operating system provides the fundamental concept of a process. Processes are applications that run in user space.

An application might spawn many processes over the course of its run.

Processes in modern operating systems run in their own _address spaces_. That is, each process thinks it has its own copy of RAM all to itself. Variables declared in one process are not visible from other processes unless both processes explicitly agree to communicate. (Contrast to threads, below.)

#### Process table

The operating system allocates a list of processes called the process table. The process table is an array data about each process, such as where in memory its stack is located, what local data is needed for the currently executing stack frame, the ID of the process (_pid_), and much more.

#### Process Lifecycle

In Unix, a process is created with the `fork()` system call made by the _parent process_.

A process exits when it’s `main()` returns, when it calls `exit()`, when it is killed, or when it crashes.

After the process exits normally, it exists in a _zombie_ state until the parent calls `wait()` to get exit status information from the child process.

### Threads

At the OS level, threads are processes that share an address space.

In a typical use case, a single process will spawn a number of threads to handle various tasks. Each thread has access to all the global data in the process.

Synchronizing access to shared data across multiple threads (so they don’t step on each others toes) is a tricky problem.

### Scheduling

The kernel is responsible for sharing resources on a system between multiple processes. In the early days of large mainframes, operating systems did not support multi-tasking. Booting a computer might load the basic resources necessary to access registers, memory, and I/O. Once that boot process was complete, the system would load a single program which would run until completion.

Modern operating systems support mult-tasking, which means that the operating system runs multiple applications at the same time. Because a CPU in general can only perform one activity at a time, the operating system loads processes, their stack frames, and their stack resources in a round-robin fashion.

> If your computer has 4 cores, it can only actually run 4 programs at once. You might have hundreds of processes that need to run, though. The kernel decides which process gets some run time next. In any given second, a large number of processes might be switched into and out of a core.

Each time a process is paused, its entire execution state is saved into main memory. The next processes stack frame is loaded from main memory, and execution is resumed.

##### Follow Along

Instructor will cover the role of the kernel and how processes and threads work.

##### Challenge

Write a program that spawns a child process with `fork()`. Have the parent print “I am the parent!”. Have the child print “I am the child!”. Then both processes should exit.

Hint: `man fork` or `man 2 fork`. Pay attention to the return value from `fork()`. It’s a brain-bender.

Warning: don’t run `fork()` in a loop unless you’re careful. You can easily spawn so many processes the system is brought to its knees. For the above assignment, there’s no need for a loop.

---

#### Learn to clearly describe the role of memory management, drivers, and filesystems

What actually allocates memory to your program? How does an application you write communicate with the hardware it uses? How does your machine find that Word document you saved 6 months ago? The answer: memory management, drivers, and file systems, oh my!

##### Overview

### Memory Management

The operating system is responsible for providing user programs access to memory. The operating system creates a stack frame at the beginning of a program’s execution and allocates a section of available free memory for it to utilize. The program’s memory space begins essentially at 0, and it has no knowledge of any memory outside of the memory that has been allocated to it by the operating system.

This is one of the fundamental attack vectors used in attempting to take malicious control of a computer. The operating system is responsible for perfectly isolating each process from one another - if a process is able to gain access to memory other than what has been assigned to it it will be able to hijack the system.

### Drivers

Drivers combine, assembly language, C code, and interrupt-driven programming to provide software control of physical devices. The drivers hide the dirty details of talking to the hardware from software developers. Then they present a consistent, easy-to-use programming interface. For example, a driver might know the details about how to talk specifically to an NVIDIA graphics card. Normal programmers don’t need or want to know those details. They just want to be able to tell any 3D card from any manufacturer how to draw a scene. For that purpose, the driver exposes an OpenGL or Direct3D interface that the programmers can use.

On general purpose computers like Kaby Lake machines, all drivers are written to control hardware on the other side of the PCIx bus. Hardware is built with a PCIx bus controlller, and driver commands configure binary messages to be sent and retrieved from the hardware over that bus.

In smaller systems like IoT and firmware devices, the bus may be a true parallel bus that is shared between the CPU and the device. These buses are synchronized by the system clock. Drivers on these systems have to know how to take control of the hardware device at the hardware level and can be written to any degree of specificity.

How to write drivers on the PCIx bus or on a parallel bus is a lesson in Computer Engineering, not covered here at Lambda School.

### File System

[File systems at The Linux Documentation Project.org](http://www.tldp.org/LDP/sag/html/filesystems.html)

Files are read and written from internal storage using PCIx drivers dedicated to controlling hard disks. The operating system keeps a record of all of the files in the system, called the File Table.

You’ve probably heard of the FAT and vFAT filesystems. Linux users are more familiar with the _ext4_ filesystem.

#### File table features:

- Contiguity
- Redundancy
- Small overhead

Dozens of specific file systems exist for specialized tasks, as well as dozens of general-purpose filesystems.

##### Follow Along

Write a C program that mallocs an area of memory and prints the address of that memory.

See if the address stays the same from run to run.

See if the address varies when run on students’ computers.

##### Challenge

Explain the following to someone in class, or in your house, or on the phone. If no one is available, any house plant will do.

(The answers to the below questions aren’t necessarily in the above text.)

- If a malicious process had access to the data of another process without permission, what are some bad things that could happen?

- If we didn’t have drivers, what would programmers have to do if they wanted to communicate with different brands of USB cards?

- What are some of the book-keeping tasks you can imagine a filesystem needs to keep track of when it comes to storing files?

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Design a Filesystem

Outline in writing (no coding–unless you really want to) the parts you would have to code up to implement a simple filesystem. The filesystem is what keeps track of and organizes files on disk. When you want to read a file, the OS must go retrieve the blocks of the file until it has them all loaded.

[GitHub Repo](https://github.com/LambdaSchool/Operating-Systems-One)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [A Simple Web Server in C](https://github.com/LambdaSchool/C-Web-Server)

  ### Networking Protocols

  In networking, each layer adds a wrapper around the data with more information about data integrity or routing or another information.

  At the highest level, you have your data that you want to transmit. As it is prepared for transmission on the network, the data is _encapsulated_ in other data to help it arrive at its destination. Any particular piece of data will be wrapped, partially unwrapped, and re-wrapped as it moves from wire to wire across the Internet to its destination.

  The act of wrapping data puts a new _header_ on the data. This header encapsulates the original data, _and all the headers that have been added before it_.

  Here is an example of a fully-encapsulated HTTP data packet.

      +-----------------+
      | Ethernet Header |  Deals with routing on the LAN
      +-----------------+
      | IP Header       |  Deals with routing on the Internet
      +-----------------+
      | TCP Header      |  Deals with data integrity
      +-----------------+
      | HTTP Header     |  Deals with web data
      +-----------------+
      | Your Data       |  Whatever you need to send
      |                 |
      |                 |
      +-----------------+

  As the data leaves your LAN and heads out in the world, the Ethernet header will be stripped off, the IP header will be examined to see how the data should be router, and another header for potentially a different protocol will be put on to send the traffic over DSL, a cable modem, or fiber.

  The Ethernet header is created and managed by the network drivers in the OS.

  ### Sockets

  Under Unix-like operating systems, the _sockets API_ is the one used to send Internet traffic. It supports both the TCP and UDP protocols, and IPv4 and IPv6.

  The sockets API gives access to the IP and TCP layers in the diagram above.

  A _socket descriptor_ is a number used by the OS to keep track of open connections.

  You can create a new socket (socket descriptor) with the `socket()` system call.

  Once created you still have to _bind_ it to a particular IP address (which the OS associates with a particular network card). This is done with the `bind()` system call.

  Once bound, you can read and write data to the socket using the `recv()` and `send()` system calls.

  - See also [Beej’s Guide to Network Programming](https://beej.us/guide/bgnet/)

  ### HTTP

  The final piece of information needed for web traffic is the _HyperText Transport Protocol_ (HTTP). While TCP deals with general data integrity and IP deals with routine, HTTP is concerned with `GET` and `POST` requests of web data.

  Like the other stages of networking, HTTP adds a header before the data it wants to send with the packet. Like IP and TCP, This header has a well-defined specification for exactly what needs to be sent.

  Though the specification is complex, a fortunately small amount of information is needed to implement a barebones version.

  For each _HTTP request_ from a client, the server, sends back an _HTTP response_.

  Here is an example HTTP `GET` request and response using version 1.1 of the HTTP protocol getting the page `http://lambdaschool.com/example`:

      GET /example HTTP/1.1
      Host: lambdaschool.com

  And here is a sample HTTP response:

      HTTP/1.1 200 OK
      Date: Wed Dec 20 13:05:11 PST 2017
      Connection: close
      Content-Length: 41749
      Content-Type: text/html

      <!DOCTYPE html><html><head><title>Lambda School ...

  The end of the header on both the request and response is marked by a blank line (i.e. two newlines in a row).

  If the file is not found, a `404` response is generated and returned by the server:

      HTTP/1.1 404 NOT FOUND
      Date: Wed Dec 20 13:05:11 PST 2017
      Connection: close
      Content-Length: 13
      Content-Type: text/plain

      404 Not Found

  Important things to note:

  - For HTTP/1.1, the request **must** include the `Host` header.
  - The second word of the first line of the response gives you a success or failure indicator.
  - `Content-Length` gives the length of the request or response body, not counting the blank line between the header and the body.
  - `Content-Type` gives you the MIME type of the content in the body. This is how your web browser knows to display a page as plain text, as HTML, as a GIF image, or anything else. They all have their own MIME types.
  - Even if your request has no body, a blank line still **must** appear after the header.

  ### What is a Web Server?

  A web server is a piece of software that accepts HTTP requests (commonly GET requests for HTML pages), and returns responses (commonly HTML pages). Other common uses are GET requests for images within web pages, and POST requests to upload data to the server (e.g. a form submission or file upload).

  ### Assignment

  [GitHub repo](https://github.com/LambdaSchool/C-Web-Server)

  We will write a simple web server that returns data on three `GET` endpoints:

  - `http://localhost:3490/` should contain some HTML, e.g. `<h1>Hello, world!</h1>`.
  - `http://localhost:3490/d20` should return a random number between 1 and 20 inclusive as `text/plain` data.
  - `http://localhost:3490/date` should print the current date and time in GMT as `text/plain` data.

  Examine the skeleton source code for which pieces you’ll need to implement.

  For the portions that are already written, study the well-commented code to see how it works.

  Don’t worry: the networking code is already written.

  #### Main Goals

  1.  Add parsing of the first line of the HTTP request header that arrives in the `handle_http_request()` function. It will be in the `request` array.

      Read the three components from the first line of the HTTP header. Hint: `sscanf()`.

      Right after that, call the appropriate handler based on the request type (`GET`, `POST`) and the path (`/`, `/d20`, etc.) You can start by just checking for `/` and add the others later as you get to them. Hint: `strcmp()`. Another hint: `strcmp()` returns \`0 if the strings are the _same_!

      If you can’t find an appropriate handler, call `resp_404()` instead to give them a “404 Not Found” response.

  2.  Implement the `get_root()` handler. This will call `send_response()`. If you need a hint as to what the `send_response()` call should look like, check out the usage of it in `resp_404()`, just above there.

      > The `fd` variable that is passed widely around to all the functions holds a _file descriptor_. It’s just a number use to represent an open communications path. Usually they point to regular files on disk, but in the case it points to an open _socket_ network connection. All of the code to create and use `fd` has been written already, but we still need to pass it around to the points it is used.

  3.  Implement `send_response()`. Hint: `sprintf()`, `strlen()` for computing content length. `sprintf()` also returns the total number of bytes in the result string, which might be helpful.

      > The HTTP `Content-Length` header only includes the length of the body, not the header. But the `response_length` variable used by `send()` is the total length of both header and body.

  4.  Implement the `get_d20()` handler. Hint: `srand()` with `time(NULL)`, `rand()`.

  5.  Implement the `get_date()` handler. Hint: `time(NULL)`, `gmtime()`.

  #### Stretch Goals

  Post a file:

  1.  Implement `find_end_of_header()` to locate the end of the HTTP request header (and start of the body).

  2.  Implement the `post_save()` handler. Modify the main loop to pass the body into it. Have this handler write the file to disk. Hint: `fopen()`, `fwrite()`, `fclose()`.

      The response from `post_save()` should be of type `application/json` and should be `{"status":"ok"}`.

  Concurrency:

  Convert the web server to be multiprocessed by using the `fork()` system call.

  1.  Examine and understand the signal handler on `SIGCHLD` that watches for when child processes exit. (This is already written for you.)

  2.  Modify the main `while` loop to `fork()` a new child process to handle each request.

      _Be careful not to fork-bomb your system to its knees!_

      _Your child process **must** call `exit()` or you will risk having piles of extra processes at work!_

  3.  Modify the `post_save()` function to get an exclusive lock on the file using `flock()`. The lock should be unlocked once the file has been written.

      What happens if multiple processes try to write to the POSTed file at the same time without locking the file?

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- [All previous recordings](/archive/CSAnnex/module/recHPT5QiPS6NOCgz)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Explain the following to someone in class, in your house, or on the phone. If no one is available, any house plant will do.

  (The answers to the below questions aren’t necessarily in the above text.)

  - Which of the Big Three is your favorite OS? Why?

  - What did the Macintosh computer run as an OS before it ran macOS/OS X?

    - What were some of the drawbacks to this old OS?

  - Why is C a popular language for writing operating systems?

- Objective challenge:

  Explain the following to someone in class, or in your house, or on the phone. If no one is available, any house plant will do.

  (The answers to the below questions aren’t necessarily in the above text.)

  - Why is a first-stage boot loaded necessary? Why not just load the entire secondary bootloader from the start?

  - Why is a boot loader necessary at all? Why not just load the kernel directly?

- Objective challenge:

  Write a program that spawns a child process with `fork()`. Have the parent print “I am the parent!”. Have the child print “I am the child!”. Then both processes should exit.

  Hint: `man fork` or `man 2 fork`. Pay attention to the return value from `fork()`. It’s a brain-bender.

  Warning: don’t run `fork()` in a loop unless you’re careful. You can easily spawn so many processes the system is brought to its knees. For the above assignment, there’s no need for a loop.

- Objective challenge:

  Explain the following to someone in class, or in your house, or on the phone. If no one is available, any house plant will do.

  (The answers to the below questions aren’t necessarily in the above text.)

  - If a malicious process had access to the data of another process without permission, what are some bad things that could happen?

  - If we didn’t have drivers, what would programmers have to do if they wanted to communicate with different brands of USB cards?

  - What are some of the book-keeping tasks you can imagine a filesystem needs to keep track of when it comes to storing files?

- Guided Project: Design a Filesystem

- Project: A Simple Web Server in C
