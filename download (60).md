<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Java - Inserting Deleting and Updating Data using CRUD Operations

<span class="lead"> </span>

<span id="Insert_Delete_Update_Data_using_CRUD_Operations"></span>

**At the end of this module, you should be able to:**

- use Postman to manually test Web APIs with all CRUD operations
- perform CRUD operations on an RDBMS JPA and Hibernate (Creating and Updating Records)
- perform CRUD operations on an RDBMS JPA and Hibernate (Updating certain fields in records)
- perform CRUD operations on an RDBMS JPA and Hibernate (Deleting records)
- understand and implement @Transactional annotation

#### Pro Tip

Treat everyone with as much respect and integrity as you wish to be treated with.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to use Postman to manually test Web APIs with all CRUD operations

<span id="Using_Postman"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_create_delete_update](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We have already seen how to use **Postman** to retrieve data from an API system. Now we need to use it to manipulate that data! How do we send Postman the data needed for a POST, PUT, PATCH? Where does the status code appear so we can see what is happening? Where do we find the location header for a POST? Let’s find out!

##### Follow Along

We need a backend system, an API, to work with. We are going to be using the sampleemps_create_delete_update application from the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_create_delete_update](https://github.com/LambdaSchool/java-sampleemps.git)tt.

- Clone the repo (if you haven’t already!)
- Open and run the sampleemps_create_delete_update
- Launch Postman
- Get a blank tab in Postman

### POST

We are going to look at POST. PATCH and PUT work the same. However, POST has the additional Header Location data we need to find.

We are going to add this employee

    {
        "jobtitles": [
            {
                "jobtitleid": 2
            }
        ],
        "name": "Mojo",
        "salary": 100000.00,
        "emails": [
            {
                "email": "[email protected]"
            },
            {
                "email": "[email protected]"
            }
        ]
    }

- Pick `POST` for the HTTP method and use the route `http://localhost:2019/employees/employee`

![Postman POST](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/postmanpost.png)

- Select the `Body` tab from the `Request` Pane
- In the `Body` tab, select `raw` data type. A pull down menu will show at the end of the data type list.
- In the Pull Down menu, select JSON
- In the data panel, enter your JSON data to be sent with the request

![Postman Data](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/postmandata.png)

- You results show up in the Response Pane
- No data is returned so the `Body` is empty
- Go to the `Headers` tab. Here you will find the location header along with all the headers that were returned
- You location header is the header that has
  - KEY = `Location`
  - VALUE = `http://localhost:2019/employees/employee/63`
- Also notice you get a Status of `201 Created`

![Postman Headers](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/postmanheaders.png)

You have now added an employee!

### DELETE

Delete works almost identical to GET. The differences being that you pick the DELETE method and inside of getting data back, you remove the data. So how you do it is similar, the results are vastly different!

Let’s delete employee 8

- Get a new tab in Postman
- HTTP Method is DELETE
- Route is http://localhost:2019/employees/employee/8

Send the request and you get

- Nothing in the `Body`
- Status of `200 OK`

![Postman Delete](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/postmandelete.png)

##### Challenge

Use Postman to do a `PATCH` for employee 14. Due to the random nature of the seed data, you may need to use a different employee id.

The route to use is http://localhost:2019/employees/employee/14

The data to use is

    {
        "salary": 10000000.00,
        "emails": [
            {
                "email": "[email protected]"
            }
        ]
    }

##### Dig Deeper

- [Postman Homepage](https://www.postman.com/)  
  Postman Homepage
- [Postman Learning Center](https://learning.postman.com/)  
  Postman Learning Center
- [Insomnia](https://insomnia.rest/)  
  Popular Postman Competitor - Insomnia

---

#### Learn to perform CRUD operations on an RDBMS JPA and Hibernate (Creating and Updating Records)

<span id="CRUD_Creating_and_replacing"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_create_delete_update](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We are going to look at the sample employees application again. This time let’s explore the application found at <https://github.com/LambdaSchool/java-sampleemps/tree/master/sampleemps_create_delete_update>.

### POST

Let’s first add an employee record to our database. We will then update that record by completely replacing it with new data. So this is what I am planning

- This endpoint POST http://localhost:2019/employees/employee

- Sent with this Request Body

<!-- -->

    {
        "jobtitles": [
            {
                "jobtitleid": 2,
                "title": "Wizard" // here the title of the job is optional!
            }
        ],
        "name": "Mojo",
        "salary": 100000.00,
        "emails": [
            {
                "email": "[email protected]"
            },
            {
                "email": "[email protected]"
            }
        ]
    }

- Yields this output

<!-- -->

    No Body

    Location Header: http://localhost:2019/employees/employee/15
    Status 201 Created

Do note that in the Employee model, we have a column constraint on `name` that affects what data can be added, changed in the employee table.

    <... other code ...>
        @Column(nullable = false, unique = true)
        private String name;
    <... other code ...>

This means that the name of the employee must be present and must be unique. Every employee must have a name and have their own name!

We will add the code to implement this in a moment.

### PUT

- This endpoint PUT http://localhost:2019/employees/employee/15

- Sent with this Request Body

<!-- -->

    {
        "name": "Mojo",
        "salary": 80000.00,
        "emails": [
            {
                "email": "[email protected]"
            }
        ]
    }

- Yields this output

<!-- -->

    No Body

    Status Ok

Now let’s completely replace the record with new data. The HTTP method PUT completely replaces the referenced employee, referenced by a given employee primary key. The employee record and all associated records are replaced in the database, whether they need to be updated or not. Thus PUT endpoint takes a full employee record, just like POST does! If you want to update just certain fields while leaving the rest untouched, use the PATCH method.

Do note that with one to many relationships, the id number of the many part of the relationship changes with each PUT! That is the ONLY data changes with each PUT. Otherwise, you can run a given PUT as many times as you wish, yielding the same result.

- Of course, we need an endpoint in the Employee Controller
- No Location Header is returned because the id of the Employee is already known.
- The final status is OK since no employee record gets created, just replaced.

We will add the code to implement this in a moment.

##### Follow Along

### POST

Let’s add some code to the sample employees application we have been working on.

Add the necessary endpoint to the Employee Controller. The annotation @RequestBody says the parameter is coming in from the Request Body. The @Valid annotation says to verify if the incoming Request Body JSON object can be converted a valid Employee Java Object. If it cannot be converted, throw an exception!

        @PostMapping(value = "/employee",
            consumes = {"application/json"})
        public ResponseEntity<?> addNewEmployee(
            @Valid
            @RequestBody
                Employee newEmployee)
        {

- We “nullify” any id sent in the request body
- We save the record to the database by calling the appropriate method in the Employee Service

<!-- -->

            // ids are not recognized by the Post method
            newEmployee.setEmployeeid(0);
            newEmployee = employeeService.save(newEmployee);

- We create the location header.

<!-- -->

            // set the location header for the newly created resource
            HttpHeaders responseHeaders = new HttpHeaders();
            URI newEmployeeURI = ServletUriComponentsBuilder.fromCurrentRequest() // get the URI for this request
                .path("/{employeeid}") // add to it a path variable
                .buildAndExpand(newEmployee.getEmployeeid()) // populate that path variable with the newly created restaurant id
                .toUri(); // convert that work into a human readable URI
            responseHeaders.setLocation(newEmployeeURI); // in the header, set the location location to that URI

- We return the location header and with a status of created.

<!-- -->

            return new ResponseEntity<>(null,
                responseHeaders,
                HttpStatus.CREATED);
        }

Now, let’s update the implementation of the save method in the class services.EmployeeServiceImp

We will need access to the JobTitleRepository so add it as a field to the class.

        @Autowired
        private JobTitleRepository jtrepos;

- Create a new employee record in case we need to do some additional data manipulations and so we can add in data for associated tables

<!-- -->

        @Transactional
        @Override
        public Employee save(Employee employee)
        {
            Employee newEmployee = new Employee();

- Set the single value fields

<!-- -->

            newEmployee.setName(employee.getName());
            newEmployee.setSalary(employee.getSalary());

- Handle the many to many relationship. In order to have the actual data from the associated table, and not just a pointer to the data, we have to loop through what job titles we want and add them to this employee. Just adding the object pointer is not enough. We need the actual data!!!

<!-- -->

            newEmployee.getJobtitles()
                    .clear();
            for (JobTitle jt : employee.getJobtitles())
            {
                JobTitle newJT = jtrepos.findById(jt.getJobtitleid())
                        .orElseThrow(() -> new EntityNotFoundException("JobTitle " + jt.getJobtitleid() + " Not Found"));

                newEmployee.getJobtitles().add(newJT);
            }

- Handle the one to many relationship. The same idea about needing the actual data works for the emails as well!!!

<!-- -->

            newEmployee.getEmails()
                .clear();
            for (Email e : employee.getEmails())
            {
                Email newEmail = new Email();
                newEmail.setEmail(e.getEmail());
                newEmail.setEmployee(newEmployee);

                newEmployee.getEmails()
                    .add(newEmail);
            }

- Save the record and return the new record along with the newly generated id number

<!-- -->

            return employeerepos.save(newEmployee);

### PUT

Let’s add some code to the sample employees application we have been working on.

Add the necessary endpoint to the Employee Controller.

        @PutMapping(value = "/employee/{employeeid}",
            consumes = {"application/json"})
        public ResponseEntity<?> updateFullEmployee(
            @Valid // verifies the give employee record is valid
            @RequestBody
                Employee updateEmployee, // the Jackson dependency converts from JSON to Java Objects
            @PathVariable
                long employeeid) // the primary key of the employee record to replace
        {
            updateEmployee.setEmployeeid(employeeid); // set the primary key to the one from the path variable
            employeeService.save(updateEmployee);

            return new ResponseEntity<>(HttpStatus.OK);
        }

- Now we need to update the Employee Service Implementation. If we have a non-zero primary key, see if it exists. If it does, great! We will replace that Employee record. If the primary key does not exist, throw an exception and stop the process. This gives us the complete SAVE method:

<!-- -->

        public Employee save(Employee employee)
        {
            Employee newEmployee = new Employee();

            if (employee.getEmployeeid() != 0)
            {
                employeerepos.findById(employee.getEmployeeid())
                    .orElseThrow(() -> new EntityNotFoundException("Employee " + employee.getEmployeeid() + " Not Found"));

                newEmployee.setEmployeeid(employee.getEmployeeid());
            }

            // everything else stays the same!
            // save will create a new record if the id is 0,
            // otherwise save replaces the records!

So test out some endpoints!

- POST http://localhost:2019/employees/employee

You can use the following for test data

    {
        "jobtitles": [
            {
                "jobtitleid": 2,
                "title": "Wizard"
            }
        ],
        "name": "Mojo",
        "salary": 100000.00,
        "emails": [
            {
                "email": "[email protected]"
            },
            {
                "email": "[email protected]"
            }
        ]
    }

- PUT http://localhost:2019/employees/employee/15

You can use the following for test data. Due to the random nature of the seed data, you may have to use a different ID for the employee to update.

    {
        "name": "Corgie",
        "salary": 80000.00,
            "jobtitles": [
            {
                "jobtitleid": 1,
                "title": "Big Boss"
            },
            {
                "jobtitleid": 2,
                "title": "Wizard"
            }
        ],
        "emails": [
            {
                "emailid": 4,
                "email": "[email protected]"
            },
            {
                "emailid": 5,
                "email": "[email protected]"
            }
        ]
    }

Your code will be similar to that found in the GitHub Repo for sampleemps!

##### Dig Deeper

- [REST - PUT vs POST](https://restfulapi.net/rest-put-vs-post/)  
  REST - PUT vs POST
- [CRUD REST API/Service](https://www.springboottutorial.com/spring-boot-crud-rest-service-with-jpa-hibernate)  
  Creating a CRUD REST API/Service with Spring Boot, JPA and Hibernate
- [REST API using Spring Boot](http://progressivecoder.com/rest-api-using-spring-boot-insert-update/)  
  REST API using Spring Boot – Insert and Update Data

---

#### Learn to perform CRUD operations on an RDBMS JPA and Hibernate (Updating certain fields in records)

<span id="CRUD_Partially_Updating"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_create_delete_update](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

#### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

### I do

We have much to do to update in adding these CRUD functions. Find the code in the repo as it is mentioned in the objective!

What if we do not want to replace the whole record but just certain fields. This is where PATCH comes in. Let’s implement PATCH.

#### PATCH

- This endpoint PATCH http://localhost:2019/employees/employee/15

- Sent with this Request Body

<!-- -->

    {
        "salary": 150000.00,
        "emails": [
        {
            "email": "[email protected]"
        }
        ]
    }

- Yields this output

<!-- -->

    No Body

    Status Ok

##### Follow Along

Let’s add some code!

- Of course, we need an endpoint where our frontend client can access the PATCH method.
- This endpoint is similar to the PUT endpoint except
  - The primary key is sent to the Employee Service via a parameter instead of inside the Employee object. This is a personal preference.
  - We do NOT verify that the Employee object is “valid”. A valid employee object would require a Name field. If we are not updating the name field, we won’t have one so the employee object would be registered as invalid. Not what we want.
  - We call the update function as opposed to the save function from the Employee Service Class.

Add the following endpoint to the EmployeeController class

        @PatchMapping(value = "/employee/{employeeid}",
            consumes = {"application/json"})
        public ResponseEntity<?> updateEmployee(
            @RequestBody
                Employee updateEmployee,
            @PathVariable
                long employeeid)
        {
            employeeService.update(updateEmployee,
                employeeid);
            return new ResponseEntity<>(HttpStatus.OK);
        }

- Now we need to make the update function available in the Employee Service class, so add it to the services.EmployeeService class

<!-- -->

    <... other code ...>
        Employee update(Employee employee, long employeeid);
    <... other code ...>

- We need to implement the function in the Employee Service Implementation class.

- We are going to check if fields coming in from the frontend client are NULL, meaning that the frontend client did not send a new value for that field. Primitive data types have to handled differently. Remember that primitive data types are not objects so NULL has no meaning for them. Let’s address that first.

- We need to make some changes to the employee model.

  - If we checked is see if `salary` was NULL, meaning that during PATCH it did not come in from the frontend client, we have to check to see if `salary` is 0.00. Remember NULL has no meaning for doubles.
  - If we check and salary is 0.00, is it 0.00 because the frontend client set it to 0.00 or is it 0.00 because it was not sent by the frontend client. Let’s fix that problem.

- Let’s add the boolean field called `hasvalueforsalary` to the Employee model class. I like to add it right above the salary field. We do NOT need to create Getters and Setters for this field!

- Mark `hasvalueforsalary` as `@Transient`. This means the field will not be saved in the database and is just part of the Java object.

- Notice that we will be referencing `hasvalueforsalary` as a public field and not using a getter and setter. Personal preference again.

<!-- -->

        @Transient
        public boolean hasvalueforsalary = false;
        private double salary;

- Before the class we add the annotation `@JsonIgnoreProperties(value = {"hasvalueforsalary"})`. The `hasvalueforsalary` field will be used internally to the application to determine if a salary value came from the frontend client or should be treated as NULL. Do not ever send this value in JSON to the frontend client.

<!-- -->

    <... other code ...>
    @JsonIgnoreProperties(value = {"hasvalueforsalary"})
    public class Employee
    {
    <... other code ...>

- Finally, let’s update the `setSalary` setter method. Setters are always used to make the conversion from the JSON received from the frontend client to Java objects. We take advantage of that fact by setting `hasvalueforsalary = true` in the setter for `salary`. If `salary` is not included in the JSON from the frontend client, `setSalary` is never called and `hasvalueforsalary` remains false.

<!-- -->

    <... other code ...>
        public void setSalary(double salary)
        {
            hasvalueforsalary = true;
            this.salary = salary;
        }
    <... other code ...>

- Now back to our implementation of the Employee Service update function.
- The header includes the data to update and the primary key of the record to update. Of course, update will change data so make it `@Transactional`

<!-- -->

        @Transactional
        @Override
        public Employee update(
            Employee employee,
            long employeeid)
        {

- Find the employee record referenced by the given primary key and create a new employee record with that data.

<!-- -->

            Employee currentEmployee = employeerepos.findById(employeeid)
                .orElseThrow(() -> new EntityNotFoundException("Employee " + employeeid + " Not Found"));

- Check each non-list field in the employee object that was received from the frontend client. If the field is NULL, meaning that a value did not come in from the frontend client, just keep the old data. If a field is NOT NULL, the frontend client sent in new data and so replace in the object found above that new data.

<!-- -->

            if (employee.getName() != null)
            {
                currentEmployee.setName(employee.getName());
            }

            if (employee.hasvalueforsalary)
            {
                currentEmployee.setSalary(employee.getSalary());
            }

- Relationships require a decision. How to deal with items sent by the frontend client that are part of a relationship?
  - I have decided that if data is sent for the one to many or the many to many relationships, that data is meant to completely replace the data for the relationship.

<!-- -->

            if (employee.getJobtitles().size() > 0)
            {
                currentEmployee.getJobtitles()
                    .clear();
                for (JobTitle jt : employee.getJobtitles())
                {
                    JobTitle newJT = jtrepos.findById(jt.getJobtitleid())
                        .orElseThrow(() -> new EntityNotFoundException("JobTitle " + jt.getJobtitleid() + " Not Found"));

                    currentEmployee.getJobtitles()
                        .add(newJT);
                }
            }

            if (employee.getEmails()
                .size() > 0)
            {
                currentEmployee.getEmails()
                    .clear();
                for (Email e : employee.getEmails())
                {
                    Email newEmail = new Email();
                    newEmail.setEmail(e.getEmail());
                    newEmail.setEmployee(currentEmployee);

                    currentEmployee.getEmails()
                        .add(newEmail);
                }
            }

- Finally, save to the database and return a full employee record with all the updated data. This still does a replace in the database but the frontend client only has to send us the data it wants changed, not all the data as with a PUT.

<!-- -->

            return employeerepos.save(currentEmployee);
        }

You can now test out the endpoint

- PATCH http://localhost:2019/employees/employee/15

You can use the following for test data. Due to the random nature of the seed data, you may have to use a different ID for the employee to update.

    {
        "salary": 10000000.00,
        "jobtitles": [
                {
                    "jobtitleid": 2,
                    "title": "Wizard"
                },
                {
                    "jobtitleid": 1,
                    "title": "Big Boss"
                }
            ],
        "emails": [
            {
                "emailid": 4,
                "email": "[email protected]"
            },
            {
                "emailid": 5,
                "email": "[email protected]"
            }
        ]
    }

##### Dig Deeper

- [PATCH HTTP method?](http://restcookbook.com/HTTP%20Methods/patch/)  
  When should we use the PATCH HTTP method?
- [HTTP PUT vs HTTP PATCH](https://www.baeldung.com/http-put-patch-difference-spring)  
  Baeldung - HTTP PUT vs HTTP PATCH in a REST API
- [PATCH in Spring](https://cassiomolin.com/2019/06/10/using-http-patch-in-spring/)  
  Using HTTP PATCH in Spring

---

#### Learn to perform CRUD operations on an RDBMS JPA and Hibernate (Deleting records)

<span id="CRUD_Deleting"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_read_delete](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

How do we get rid of data in the database. Let’s delete it. This is the most straight forward of the CRUD operations. You say delete with the given employee primary key and that employee and all associated records are deleted. Let’s code it!

- Endpoint DELETE http://localhost:2019/employees/employee/15

- Yields the Output

<!-- -->

    No Body

    Status Ok

##### Follow Along

Let’s code this! First we need an endpoint and from that endpoint we only need a primary key, so in the Employee Controller add the following code. Notice we are doing a delete so we are using `@DeleteMapping` instead of `@GetMapping`!

        @DeleteMapping(value = "/employee/{employeeid}")
        public ResponseEntity<?> deleteEmployeeById(
            @PathVariable
                long employeeid)
        {
            employeeService.delete(employeeid);
            return new ResponseEntity<>(HttpStatus.OK);
        }

Now we need to add the delete method to the Employee Service interface. Note the return is void. Nothing gets returns; there is nothing to get returned. It got deleted!

        void delete(long employeeid);

Now implement the delete method in the Employee Service Implementation. Notice that we first determine if we have the employee primary key in the database. If we do, great delete. If we do not, throw an exception.

The `findById` method returns an object of type `Object`. One of the methods in the class `Object` is `isPresent` which checks to see if the object exist (is not null)!

        @Transactional
        @Override
        public void delete(long employeeid)
        {
            if (employeerepos.findById(employeeid)
                .isPresent())
            {
                employeerepos.deleteById(employeeid);
            } else
            {
                throw new EntityNotFoundException("Employee " + employeeid + " Not Found");
            }
        }

Bye Bye employee. Enjoy your farewell cake!

When we delete an employee, associated email records get deleted. This is because we have CASCADE.ALL set on the One to Many relationship between employee and emails. The Many to Many relationship automatically deletes the joins between employees and jobtitles when employee is deleted. The actual job title table is left intact!

##### Dig Deeper

- [Cascade Types](https://howtodoinjava.com/hibernate/hibernate-jpa-cascade-types/)  
  Hibernate JPA Cascade Types
- [Baeldung](https://www.baeldung.com/spring-data-jpa-delete)  
  Baeldung - Spring Data JPA Delete and Relationships

---

#### Learn to understand and implement @Transactional annotation

<span id="Transactional"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_create_delete_update](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We have much to update in adding these CRUD functions. Find the Transactional code in the repo as it is mentioned in the objective!

The @Transactional Annotation

Any method that changes data should be made transactional!

Two main libraries implement the `@Transactional` annotation. For most purposes these two implementations are interchangeable. In fact, the Spring Framework has its own version of each library. The two libraries are

- `org.springframework.transaction.annotation.Transactional`
- `javax.transaction`

So best practice - if you are using the Spring Framework, import the library `org.springframework.transaction.annotation.Transactional`. Otherwise, import the library `javax.transaction`

To make a method transactional, add the `@Transactional` annotation before the method name. For example:

        @Transactional
        @Override
        public void delete(long employeeid)
        {
            ...
        }

If you make the class transactional, each method in the class is considered transactional. If you make both the class and method transactional, the annotation at the method level takes precedent. I like to make the methods transactional. I have experienced issues with just making a class transactional.

    @Transactional
    @Service(value = "employeeSerivce") // needed to name this implementation as the service to use
    public class EmployeeServiceImpl implements EmployeeService
    {
        ...
    }

Normally we use the transactional annotation to make manipulating data a single transaction. For example, look at delete.

- Delete an employee records triggers
  - Delete of 0 or more email records
  - Delete of 0 or more Employee JobTitle records

For a transactional delete to succeed, all three deletes must succeed. If a problem is found during any of the deletes, the transactional initiates a rollback - all the data deleted is restored and the database is left in the same it was in before the failed delete was attempted. In this matter our database maintains **referential integrity**. We do not delete an employee while leaving emails of that employee in the emails table. Referential integrity can be defined as the accuracy and consistency of data within the various relationships.

Many times it is helpful to make a method work as a single transaction. The `@Transactional` annotation has a couple of useful options.

- `@Transactional(readOnly=true)` - method does not write to the database
- `@Transactional(timeout=XX)` - timeout in seconds. applies to both data manipulation and queries. I know of interviews where you are asked how to restrict how long a query can run before timing out. Here it is!

We have already added `@Transacational` in our code each time we wrote a method to change data, so no need to change any code at this point!

##### Dig Deeper

- [Spring IO](https://spring.io/guides/gs/managing-transactions/)  
  Spring IO - Managing Transactions
- [Spring Boot](https://www.javainuse.com/spring/boot-transaction)  
  Spring Boot Declarative Transaction Management Example
- [Spring Boot](https://www.javainuse.com/spring/boot-transaction-isolation)  
  Spring Boot - Transaction Isolation Tutorial
- [Spring Boot](https://www.javainuse.com/spring/boot-rollback)  
  Spring Boot Transaction Management - Transaction Rollback Example
- [Spring Boot](https://www.javainuse.com/spring/boot-transaction-isolation)  
  Spring Boot - Transaction Isolation Tutorial
- [Spring @Transactional cheat sheet](https://marcin-chwedczuk.github.io/spring-transactional-cheat-sheet)  
  Spring @Transactional cheat sheet

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### crudyrestaurants_delete_save_update

Using restaurants with menus as our model, we explore CRUD operations related to creating, updating and deleting data working towards the crudyrestaurants_delete_save_update application found in the repo

[GitHub Repo](https://github.com/LambdaSchool/java-crudyrestaurants.git)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Crudy Orders](https://github.com/LambdaSchool/java-crudyorders.git)

  This is part 3 of a 3 part series. In the first part you are tasked with setting up the database model in a Java Spring Application. In the second part you are tasked with adding Get routes to the application. In the third part you are tasked with adding the rest of the CRUD operation

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[CRUD Operations for WEB33 with John Mitchell](https://youtu.be/BB5f1Btns5o)**
- [All previous recordings](/archive/WEB4Java/module/recJihkiNn2KH2nEW)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Use Postman to do a `PATCH` for employee 14. Due to the random nature of the seed data, you may need to use a different employee id.

  The route to use is http://localhost:2019/employees/employee/14

  The data to use is

      {
          "salary": 10000000.00,
          "emails": [
              {
                  "email": "[email protected]"
              }
          ]
      }

- Guided Project: crudyrestaurants_delete_save_update

- Project: Crudy Orders
