Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Review](#review)

# Graphs II

<span class="lead"> </span>

**At the end of this module, you should be able to:**

-   represent a breadth-first-search of a graph in pseudo-code and recall typical applications for its use
-   represent a depth-first-search of a graph in pseudo-code and recall typical applications for its use
-   implement a breadth-first search on a graph
-   implement a depth-first search on a graph

#### Pro Tip

We all build on the work of others.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=qDNtVQSgodo), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=RrdVrVWCguE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=TraCqRGMZiQ), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=2XxefUT7Si4), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to represent a breadth-first-search of a graph in pseudo-code and recall typical applications for its use

##### Overview

One method we can use when searching a graph is a **breadth-first search** (BFS). This sorting algorithm explores the graph outward in rings of increasing distance from the starting vertex.

The algorithm never attempts to explore a vert it has already explored or is currently exploring.

For example, when starting from the upper left, the numbers on this graph show a vertex visitation order in a BFS:

![](https://camo.githubusercontent.com/b22308d5dd2fe7ee7f295f89482bdab2f8e8976f/68747470733a2f2f692e696d6775722e636f6d2f314c506e4f41582e6a7067)

We followed the edges represented with thicker black arrows. We did not follow the edges represented with thinner grey arrows because we already visited their destination nodes.

The exact order will vary depending on which branches get taken first and which vertex is the starting vertex.

*Note: it’s essential to know the distinction between a breadth-first search and a breadth-first traversal. A breadth-first traversal is when you visit each vertex in the breadth-first order and do something during the traversal. A breadth-first search is when you search through vertexes in the breadth-first order until you find the target vertex. A breadth-first search usually returns the shortest path from the starting vertex to the target vertex once the target is found.*

### Applications of BFS

-   Pathfinding, Routing
-   Find neighbor nodes in a P2P network like BitTorrent
-   Web crawlers
-   Finding people `n` connections away on a social network
-   Find neighboring locations on the graph
-   Broadcasting in a network
-   Cycle detection in a graph
-   Finding [Connected Components](https://en.wikipedia.org/wiki/Connected_component_(graph_theory))
-   Solving several theoretical graph problems

### Coloring Vertexes

As we explore the graph, it is useful to color verts as we arrive at them and as we leave them behind as “already searched”.

Unvisited verts are white, verts whose neighbors are being explored are gray, and verts with no unexplored neighbors are black.

### Keeping Track of What We Need to Explore

In a BFS, it’s useful to track which nodes we still need to explore. For example, in the diagram above, when we get to node 2, we know that we also need to explore nodes 3 and 4.

We can track that by adding neighbors to a *queue* (which remember is first in, first out), and then explore the verts in the queue one by one.

##### Follow Along

### Pseudo-code for BFS

Let’s explore some pseudo-code that shows a basic implementation of a breadth-first-search of a graph. Make sure you can read the pseudo-code and understand what each line is doing before moving on.

    BFS(graph, startVert):
        for v of graph.vertexes:
            v.color = white

        startVert.color = gray
            queue.enqueue(startVert)

        while !queue.isEmpty():
            u = queue[0]  // Peek at head of the queue, but do not dequeue!

            for v of u.neighbors:
                if v.color == white:
                    v.color = gray
                    queue.enqueue(v)

            queue.dequeue()
            u.color = black

You can see that we start with a graph and the vertex we will start on. The very first thing we do is go through each of the vertices in the graph and mark them with the color white. At the outset, we mark all the verts as unvisited.

Next, we mark the starting vert as gray. We are exploring the starting verts’ neighbors. We also enqueue the starting vert, which means it will be the first vert we look at once we enter the while loop.

The condition we check at the outset of each while loop is if the queue is **not** empty. If it is not empty, we peek at the first item in the queue by storing it in a variable.

Then, we loop through each of that vert’s neighbors and:

-   We check if it is unvisited (the color white).
-   If it is unvisited, we mark it as gray (meaning we will explore its neighbors).
-   We enqueue the vert.

Next, we dequeue the current vert we’ve been exploring and mark that vert as black (marking it as visited).

We continue with this process until we have explored all the verts in the graph.

##### Challenge

On your own, complete the following tasks:

1.  Please spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a breadth-first-search starting with vertex `"I"`.

         class Graph:
             def __init__(self):
                 self.vertices = {
                                     "A": {"B", "C", "D"},
                                     "B": {},
                                     "C": {"E", "F"},
                                     "D": {"G"},
                                     "E": {"G"},
                                     "F": {"J"},
                                     "G": {},
                                     "H": {"C", "J", "K"},
                                     "I": {"D", "E", "H"},
                                     "J": {"L"},
                                     "K": {"C"},
                                     "L": {"M"},
                                     "M": {},
                                     "N": {"H", "K", "M"}
                                 }

3.  Besides marking verts with colors as in the pseudo-code example above, how else could you track the verts we have already visited?

##### Dig Deeper

-   <https://brilliant.org/wiki/breadth-first-search-bfs/>  

------------------------------------------------------------------------

#### Learn to represent a depth-first-search of a graph in pseudo-code and recall typical applications for its use

##### Overview

Another method we can use when searching a graph is a **depth-first search** (DFS). This searching algorithm *“dives”* *“down”* the graph as far as it can before backtracking and exploring another branch.

The algorithm never attempts to explore a vert it has already explored or is exploring.

For example, when starting from the upper left, the numbers on this graph show a vertex visitation order in a DFS:

![](https://camo.githubusercontent.com/30ab40a62286d6fe39210efa52f5b802f383daa0/68747470733a2f2f692e696d6775722e636f6d2f565654433959782e6a7067)

We followed the edges represented with thicker black arrows. We did not follow the edges represented with thinner grey arrows because we already visited their destination nodes.

The exact order will vary depending on which branches get taken first and which vertex is the starting vertex.

### Applications of DFS

DFS is often the preferred method or exploring a graph *if we want to ensure we visit every node in the graph*. For example, let’s say that we have a graph representing all the friendships in the entire world. We want to find a path between two known people, `Andy` and `Sarah`. If we used a depth-first search in this scenario, we could end up exceptionally far away from `Andy` while still not finding a path to `Sarah`. Using a DFS, we will eventually find the path, but it won’t find the shortest route, and it will also likely take a long time.

So, this is an example of where a DFS *would not work well*. What about a genuine use case for DFS. Here are a few examples:

-   Finding [Minimum Spanning Trees](https://en.wikipedia.org/wiki/Minimum_spanning_tree) of weighted graphs
-   Pathfinding
-   Detecting cycles in graphs
-   [Topological sorting](https://en.wikipedia.org/wiki/Topological_sorting), useful for scheduling sequences of dependent jobs
-   Solving and generating mazes

### Coloring Vertexes

Again, as we explore the graph, it is useful to color verts as we arrive at them and as we leave them behind as “already searched”.

Unvisited verts are white, verts whose neighbors are being explored are gray, and verts with no unexplored neighbors are black.

### Recursion

Since DFS will pursue leads in the graph as far as it can, and then “back up” to an earlier branch point to explore that way, recursion is an excellent approach to help “remember” where we left off.

Looking at it with pseudo-code to make the recursion more clear:

    explore(graph) {
        visit(this_vert);
        explore(remaining_graph);
    }

##### Follow Along

### Pseudo-code for DFS

Let’s explore some pseudo-code that shows a basic implementation of a depth-first-search of a graph. Make sure you can read the pseudo-code and understand what each line is doing before moving on.

    DFS(graph):
        for v of graph.verts:
            v.color = white
            v.parent = null

        for v of graph.verts:
            if v.color == white:
                DFS_visit(v)

    DFS_visit(v):
        v.color = gray

        for neighbor of v.adjacent_nodes:
            if neighbor.color == white:
                neighbor.parent = v
                DFS_visit(neighbor)

        v.color = black

You can see that we have two functions in our pseudo-code above. The first function, `DFS()` takes the graph as a parameter and marks all the verts as unvisited (white). It also sets the parent of each vert to `null`. The next loop in this function visits each vert in the graph, and if it is unvisited, it passes that vert into our second function `DFS_visit()`.

`DFS_visit()` starts by marking the vert as gray (in the process of being explored). Then, it loops through all of its unvisited neighbors. In that loop, it sets the parent and then makes a recursive call to the `DFS_visit()`. Once it’s done exploring all the neighbors, it marks the vert as black (visited).

##### Challenge

On your own, complete the following tasks:

1.  Please spend a few minutes researching to find a unique use-case of a depth-first search that we did not mention in the list above.

2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a depth-first-search starting with vertex `"I"`.

         class Graph:
             def __init__(self):
                 self.vertices = {
                                     "A": {"B", "C", "D"},
                                     "B": {},
                                     "C": {"E", "F"},
                                     "D": {"G"},
                                     "E": {"G"},
                                     "F": {"J"},
                                     "G": {},
                                     "H": {"C", "J", "K"},
                                     "I": {"D", "E", "H"},
                                     "J": {"L"},
                                     "K": {"C"},
                                     "L": {"M"},
                                     "M": {},
                                     "N": {"H", "K", "M"}
                                 }

##### Dig Deeper

-   <https://brilliant.org/wiki/depth-first-search-dfs/>  

------------------------------------------------------------------------

#### Learn to implement a breadth-first search on a graph

##### Overview

Now that we’ve looked at and understand the basics of a breadth-first search (BFS) on a graph, let’s implement a BFS algorithm.

##### Follow Along

Before defining our breadth-first search method, review our `Vertex` and `Graph` classes that we defined previously.

    class Vertex:
        def __init__(self, value):
            self.value = value
            self.connections = {}

        def __str__(self):
            return str(self.value) + ' connections: ' + str([x.value for x in self.connections])

        def add_connection(self, vert, weight = 0):
            self.connections[vert] = weight

        def get_connections(self):
            return self.connections.keys()

        def get_value(self):
            return self.value

        def get_weight(self, vert):
            return self.connections[vert]

    class Graph:
        def __init__(self):
            self.vertices = {}
            self.count = 0

        def __contains__(self, vert):
            return vert in self.vertices

        def __iter__(self):
            return iter(self.vertices.values())

        def add_vertex(self, value):
            self.count += 1
            new_vert = Vertex(value)
            self.vertices[value] = new_vert
            return new_vert

        def add_edge(self, v1, v2, weight = 0):
            if v1 not in self.vertices:
                self.add_vertex(v1)
            if v2 not in self.vertices:
                self.add_vertex(v2)
            self.vertices[v1].add_connection(self.vertices[v2], weight)

        def get_vertices(self):
            return self.vertices.keys()

Now, we will add a `breadth_first_search` method to our `Graph` class. One of the most common and simplest ways to implement a BFS is to use a queue to keep track of unvisited nodes and a set to keep track of visited nodes. Let’s start by defining the start of our function with these structures:

    class Graph:
        def __init__(self):
            self.vertices = {}
            self.count = 0

        def __contains__(self, vert):
            return vert in self.vertices

        def __iter__(self):
            return iter(self.vertices.values())

        def add_vertex(self, value):
            self.count += 1
            new_vert = Vertex(value)
            self.vertices[value] = new_vert
            return new_vert

        def add_edge(self, v1, v2, weight = 0):
            if v1 not in self.vertices:
                self.add_vertex(v1)
            if v2 not in self.vertices:
                self.add_vertex(v2)
            self.vertices[v1].add_connection(self.vertices[v2], weight)

        def get_vertices(self):
            return self.vertices.keys()

        def breadth_first_search(self, starting_vert):
            to_visit = Queue()
            visited = set()
            to_visit.enqueue(starting_vert)
            visited.add(starting_vert)
            while to_visit.size() > 0:
                current_vert = to_visit.dequeue()
                for next_vert in current_vert.get_connections():
                    if next_vert not in visited:
                        visited.add(next_vert)
                        to_visit.enqueue(next_vert)

##### Challenge

1.  What is time complexity in Big O notation of a breadth-first search on a graph with `V` vertices and `E` edges?
2.  Which method will find the ***shortest*** path between a starting point and any other reachable node? A breadth-first search or a depth-first search?

##### Dig Deeper

-   <https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/>  

------------------------------------------------------------------------

#### Learn to implement a depth-first search on a graph

##### Overview

The depth-first search algorithm on a graph starts at an arbitrary vertex in the graph and explores as far as possible down each branch before backtracking. So, you start at the starting vertex, mark it as visited, and then move to an adjacent unvisited vertex. You continue this loop until every reachable vertex is visited.

##### Follow Along

Before defining our depth-first search method, review our `Vertex` and `Graph` classes that we defined previously.

    class Vertex:
        def __init__(self, value):
            self.value = value
            self.connections = {}

        def __str__(self):
            return str(self.value) + ' connections: ' + str([x.value for x in self.connections])

        def add_connection(self, vert, weight = 0):
            self.connections[vert] = weight

        def get_connections(self):
            return self.connections.keys()

        def get_value(self):
            return self.value

        def get_weight(self, vert):
            return self.connections[vert]

    class Graph:
        def __init__(self):
            self.vertices = {}
            self.count = 0

        def __contains__(self, vert):
            return vert in self.vertices

        def __iter__(self):
            return iter(self.vertices.values())

        def add_vertex(self, value):
            self.count += 1
            new_vert = Vertex(value)
            self.vertices[value] = new_vert
            return new_vert

        def add_edge(self, v1, v2, weight = 0):
            if v1 not in self.vertices:
                self.add_vertex(v1)
            if v2 not in self.vertices:
                self.add_vertex(v2)
            self.vertices[v1].add_connection(self.vertices[v2], weight)

        def get_vertices(self):
            return self.vertices.keys()

Now, we will add a `depth_first_search` method to our `Graph` class. One of the most common and simplest ways to implement a DFS is to use a set to keep track of visited vertices and use recursion to manage the visitation order. Let’s now define our function:

    class Graph:
        def __init__(self):
            self.vertices = {}
            self.count = 0

        def __contains__(self, vert):
            return vert in self.vertices

        def __iter__(self):
            return iter(self.vertices.values())

        def add_vertex(self, value):
            self.count += 1
            new_vert = Vertex(value)
            self.vertices[value] = new_vert
            return new_vert

        def add_edge(self, v1, v2, weight = 0):
            if v1 not in self.vertices:
                self.add_vertex(v1)
            if v2 not in self.vertices:
                self.add_vertex(v2)
            self.vertices[v1].add_connection(self.vertices[v2], weight)

        def get_vertices(self):
            return self.vertices.keys()

        def depth_first_search(self, vertex, visited = set()):
            visited.add(vertex)
            for next_vert in vertex.get_connections():
                if next_vert not in visited:
                    self.depth_first_search(next_vert, visited)

##### Challenge

1.  Does a depth-first search reliably find the shortest path?
2.  If you didn’t want to use recursion, what data structure could you use to write an iterative depth-first search?

##### Dig Deeper

-   <https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/>  

------------------------------------------------------------------------

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   [All previous recordings](/archive/cs/module/recX4dkkIPeJ6JjX6)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    On your own, complete the following tasks:

    1.  Please spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

    2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a breadth-first-search starting with vertex `"I"`.

             class Graph:
                 def __init__(self):
                     self.vertices = {
                                         "A": {"B", "C", "D"},
                                         "B": {},
                                         "C": {"E", "F"},
                                         "D": {"G"},
                                         "E": {"G"},
                                         "F": {"J"},
                                         "G": {},
                                         "H": {"C", "J", "K"},
                                         "I": {"D", "E", "H"},
                                         "J": {"L"},
                                         "K": {"C"},
                                         "L": {"M"},
                                         "M": {},
                                         "N": {"H", "K", "M"}
                                     }

    3.  Besides marking verts with colors as in the pseudo-code example above, how else could you track the verts we have already visited?

-   Objective challenge:

    On your own, complete the following tasks:

    1.  Please spend a few minutes researching to find a unique use-case of a depth-first search that we did not mention in the list above.

    2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a depth-first-search starting with vertex `"I"`.

             class Graph:
                 def __init__(self):
                     self.vertices = {
                                         "A": {"B", "C", "D"},
                                         "B": {},
                                         "C": {"E", "F"},
                                         "D": {"G"},
                                         "E": {"G"},
                                         "F": {"J"},
                                         "G": {},
                                         "H": {"C", "J", "K"},
                                         "I": {"D", "E", "H"},
                                         "J": {"L"},
                                         "K": {"C"},
                                         "L": {"M"},
                                         "M": {},
                                         "N": {"H", "K", "M"}
                                     }

-   Objective challenge:
    1.  What is time complexity in Big O notation of a breadth-first search on a graph with `V` vertices and `E` edges?
    2.  Which method will find the ***shortest*** path between a starting point and any other reachable node? A breadth-first search or a depth-first search?

-   Objective challenge:
    1.  Does a depth-first search reliably find the shortest path?
    2.  If you didn’t want to use recursion, what data structure could you use to write an iterative depth-first search?
