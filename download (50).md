<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

- [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
- [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
- [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
- [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

- [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
- [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
- [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
- [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

- [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
- [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
- [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
- [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

- [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
- [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
- [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
- [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

- [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
- [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
- [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
- [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

- [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
- [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
- [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
- [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# WEB Unit Testing

<span class="lead"> </span>

In this module, you will learn what a unit test is, and how to write them using Jest.

**At the end of this module, you should be able to:**

- configure tools for adding automated tests to a JS project
- use Jest to write unit tests
- use Test Driven Development

#### Pro Tip

If you have questions about how to do something, try to batch them so you only interrupt your manager once.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=jyWUNzzV29U), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Rg-BErMc8Fo), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to configure tools for adding automated tests to a JS project

##### Overview

### Why Do We Test?

Testing is an important skill for a web developer to have. Its hard to anticipate _every_ way that a user might interact with your site, not to mention it is incredibly time-consuming to manually test all of those options. That’s where automated testing comes in. Any major company will use automated testing on its websites as a safety net, to prevent regressions, and to get a better overall understanding of how an application works. As such, testing is a great thing to have on your resume!

We’ll quickly review what testing is before jumping into tooling we can use for automated testing. Generally speaking, testing is code that checks if the application code is correct.

If we don’t have tests, it’s safe to assume the following:

- application code has to be tested manually
- there is no way to know if a change broke another piece of code
- you cannot be sure if the code is correct
- manually testing takes a lot of unnecessary time
- adding new features becomes slow

#### Advantages of Testing

- verifies edge cases
- developer can concentrate on current changes (safety net)

#### Drawbacks of Testing

- more code to write and maintain
- more tooling
- additional dependencies
- may provide a false sense of security
- trivial test failures may break the build
- regressions (when a new feature breaks existing code)

### What tools do we use for testing?

Hopefully by now you’re convinced that testing is important and want to start using it in your projects. In this course you’ve already used react testing library to write tests for React components, but there are other tools available. Examples of those tools are: Jest, Mocha/chai, jasmine, qunit, enzyme, supertest, istambul, karma, and cypress.

With so many testing tools available, how do you even begin to set up custom testing for a project? It helps to know why you want to test, so that you can pick the tool most suited to your needs.

### Jest

We’ll use the testing library Jest to start setting up our own tests. Jest runs under the hood in react testing library, so a lot of what we do moving forward should look somewhat familiar. With create-react-app and react testing library there was no need to install and set up Jest, but as you grow as a web developer you will likely run into a need to install and use Jest on its own.

Jest is a test runner and command line interface npm package. It was originally made by Facebook and is included out-of-the-box with create-react-app. Jest is a very general purpose testing tool, and it works best with React applications, though it works with other frameworks as well. In addition to the types of tests we’ve seen, Jest can run asynchronous tests, snapshot testing, and produce coverage reports.

#### Watch Mode

You’ll learn how to install and configure Jest in the tutorial below, but first, lets talk briefly about `watch mode`. Instead of running tests manually, Jest has a built-in feature called watch mode that will run tests automatically as files change. Jest detects these changes automatically and only runs the tests pertaining to the changes. This is one of the reasons developers love Jest so much, and hopefully one that you’ll find equally compelling.

##### Follow Along

1.  **Install `jest` with npm.** We first need to install Jest as a developent dependency. As soon as we do, Jest dependencies will show up in our `package.json` file.

    npm install -D jest

1.  **Add test script**. In `package.json` we’ll need to indicate that we’re using jest for testing. This can be done by simply adding `"test": "jest --watch",` to your “scripts” object.
1.  **Run Tests**. We can start Jest by typing `npm test` in a terminal window at the root of the project. However, since there are no tests written, it will return an error “No tests found” because we haven’t actually written any tests yet, so let’s move on.
1.  **Create test files.** By convention, Jest will find your tests in two ways: 1) by placing `.js` files inside a folder called `__tests__` or 2) by ending the name of a file in `.test.js` or `.spec.js`. Technically, you could give the `__tests__` folder a different name, but then you’d need to manually change where Jest looks for test files.

Here we aren’t going to write tests, but at this point you are all set up to do so.

##### Challenge

Install and configure jest into your project from yesterday afternoon. Dig into the Jest Documentation [here](https://jestjs.io/docs/en/configuration) for more specific configuration details you could use.

---

#### Learn to use Jest to write unit tests

##### Overview

In the last objective, we configured Jest in a project. Now we want to actually write and run unit tests.

### Unit Tests

You’ll recall from unit 3 that unit tests are where we isolate smaller units of software (often functions or methods). There are usually many unit tests in a codebase, and because these tests are meant to be run often, they need to run fast. Unit tests are fast, they’re simple to write and execute, and they’re the preferred tool for test driven development (TDD) and behavior driven development (BDD). They are regularly used by developers to test correctness in `units` of code (usually functions).

### What makes a good test?

A good unit test is independent, focused, and, as you might assume, tests only one unit of code. This type of test focuses on one behavior or functionality (even if you have to make multiple assertions), therefore testing only what needs to be tested, and no more.

Another important consideration with testing is that you should try to avoid unnecessary preconditions. If your test relies on outside dependencies or other tests running first, you should factor to isolate the test (much like a pure function).

### Jest Globals

- the `it` global is a method you pass a function to; that function is executed as a block of tests by the test runner.
- the `describe` is optional for grouping a number of related `it` statements; this is also known as a `test suite`.

### Hello World Test

Let’s consider a constant function. We’ll use the ever-so-simple `hello` function for testing purposes.

    export const hello = () => console.log("hello world!");

Next we’d move into our tests folder and set up a test asserting that we `expect` the output of this function to be hello world.

    import { hello } from "./App";
    //arrange
    describe("hello", () => {
      //act
      it("should output hello world!", () => {
        //assert
        expect(hello()).toBe("hello world!");
      });
    });

The test should run automatically in the terminal, thanks to our `watcher`, and you’d see that the test passed. Hopefully this looks familiar to you from our work with react testing library.

Before we dive into writing our own tests with Jest, let’s look at a few more details.

### Important Globals in Jest

A few objects exist in the global scope like `describe` and `it`. You are already familiar with their use cases. When writing custom tests you may find that some tests need to be run more than once, like a test to render without crashing, for example. Jest has built in globals for this use case:

<table><thead><tr class="header"><th>Global</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>beforeAll</td><td>runs once before the first test</td></tr><tr class="even"><td>beforeEach</td><td>runs before the tests, good for setup code</td></tr><tr class="odd"><td>afterEach</td><td>runs after the tests, good for clean up</td></tr><tr class="even"><td>afterAll</td><td>runs once after the last test</td></tr></tbody></table>

If there’s ever a scenario in which you want to skip or isolate a test, use the following globals:

<table><thead><tr class="header"><th>Global</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code class="highlighter-rouge">it.skip()</code></td><td>skips the test</td></tr><tr class="even"><td><code class="highlighter-rouge">it.only()</code></td><td>isolates a test</td></tr></tbody></table>

The remaining globals can be found in the Jest [documentation](https://jestjs.io/docs/en/api)

##### Follow Along

We’re going to write our very own unit test for a JavaScript function called `averageTestScore`. This function takes an array of scores (numbers) and returns the average score.

Copy the following function to a file called `mathHelpers.js`.

    const averageTestScore = testScores => {
      let totalSumScores = 0;
      let numberOfScore = 0;

      for (let i = 0; i < testScores.length; i++) {
        totalSumScores += testScores[i];
        numberOfScore++;
      }

      return totalSumScores / numberOfScore;
    };

    module.exports = averageTestScore;

In a `mathHelpers.test.js` file, we’ll start creating the tests we want to run on our function. Remember, the `it` statements describe what the tests will do. While we’re brainstorming we can use `it.todo()` to capture ideas for future tests and fill up the test details one test at a time later. This will indicate to indicate to our test runner that we don’t want to run that test yet, but to keep note of it instead.

    describe("mathHelpers", () => {
      describe("averageTestScore", () => {
        it.todo("should calculate the average for an array of numbers");

        it.todo("should throw an error if the argument is not an array");
      });
    });

After we’ve created the `it.todo()` statements its time to write the actual tests! We’ll start by changing the `it.todo()`s into `it()` globals. First, we’ll set up dummy data and, as usual, state the expected outcome in the form of a callback. For example, when we have a score array of `[2,4,6,6,2]`, we expect the average `toBe(4)`.

    const { averageTestScore } = require("./mathHelpers.js");

    describe("mathHelpers", () => {

      describe("averageTestScore", () => {

        it("should calculate the average for an array of numbers", () => {
          const scores = [2, 4, 6, 6, 2];

          const average = averageTestScore(scores);

          expect(average).toBe(4);
        })

        it.todo("should throw an error if the argument is not an array", () => {
          expect(() => { averageTestScore(5) }).toThrow();
          expect(() => { averageTestScore("five and two") }).toThrow();
          expect(() => { averageTestScore({ number: 5 }) }).toThrow();
          expect(() => { averageTestScore(undefined).toThrow();
          expect(() => { averageTestScore(null).toThrow();
          expect(() => { averageTestScore(NaN).toThrow();
        })

      });

    });

##### Challenge

Write a unit test on one function from yesterday’s project.

---

#### Learn to use Test Driven Development

##### Overview

Test driven development is the process of writing tests before code. In theory, when you start with the end (the tests) in mind, you can write much higher quality code. You might be familiar with similar philosophies in teaching (backwards planning) – or from the famous book “7 Habits of Highly Effective People” (starting with the end in mind).

Let’s consider some unit of code. We want this function to take 2 numbers and return the first number to the power of the second number.

Some assertions we might want to check are:

- The function returns a number
- The function returns a to the power of b
- The function does not return b to the power of a
- The function returns undefined if one parameter is not a number

There’s really an endless amount of assertions we could check, but for test driven development it helps to think of the most-likely scenarios where the unit could fail.

In this example we’d write all of these tests in Jest. After that we could start hacking away at the function. So as long as all the tests pass, you can be confident in what you’ve created.

##### Follow Along

In this tutorial, let’s consider an example where we want to write a function to accept a list of salaries and remove all of the salaries that are less than `$50,000`.

1.  Spend 3-5 minutes brainstorming test ideas. What are all the possible ways you could design this function wrong? What are all the ways you could design it right? Jot those ideas down.

Your list may contain some of the following ideas, more or less is fine:

- The function should return an array shorter than the original array
- The array should contain numbers
- The function should remove all salaries less than 50,000
- The function should allow for type coercion (“1” = 1)
- The function should not remove 50,000
- The function should not remove any salary above 50,000

1.  From the list generated above, we’ll want to start by writing a single assertion. That might look something like this:

    describe("removeSalaries", () => {
    it("should return an array of shorter length", () => {
    // assertions and matchers here
    });

1.  Next we want to write the test. This is good practice for test writing from logic you are already familiar with. The final result will look something like this:

    describe('removeSalaries', () => {
    it('should return an array of shorter length', () => {
    const salaries = [50000, 45000, 60000];
    expect(removeSalaries(salaries).toHaveLength(1);
    });

1.  Once we’ve written a test we can start writing code to make the test pass. Based on the test we’ve generated so far we have a rudimentary idea of what our function needs to contain. We’ll want to return an array of shorter length than our original array, and that return should filter based on salaries. One version of such a function is below, but there are plenty of options to make our test pass.

    // name function based on test
    const removeSalaries = salaries => {
    //create an empty array
    const higherSalaries = [];
    //use conditional logic to add salaries to the new array
    for (x in salaries) {
    if (salaries[x] < 50000) {
    higherSalaries.append(salaries[x]);
    }
    }
    // return new array
    return higherSalaries;
    };

5Design a series of tests for a function that accepts an array of objects with the format `{name: "string", age: number}` and returns the names of all people who are over the age of `18`. . Once our first test is passing, the process repeats over and over again! As we write tests and refactor code, we develop something thorough and complete. If you need any extra JavaScript practice, feel free to work on it here.

A final test file might look like this:

    describe('removeSalaries', () => {
        it('should return an array of shorter length', () => {
            const salaries = [50000, 45000, 60000];
            expect(removeSalaries(salaries).toHaveLength(1);
        });
        it('should return numbers', () => {
            expect(removeSalaries(salaries).toContainType)
        });
        it('should remove all salaries less than 50,000', () => {
            const salaries = [50000, 45000, 60000];
            const expected = [60000];
            expect(removeSalaries(salaries).arrayContaining(expected);
        });
        it('should allow for type coercion', () => {
            const salaries = ["50000", "45000", "60000"];
            const expected = [60000];
            expect(removeSalaries(salaries).arrayContaining(expected);
        });
        it('should not remove 50,000', () => {
            const salaries = [50000, 60000]
            expect(removeSalaries(salaries).toContain([50000]))
        });
    })

##### Challenge

Design a series of tests for a function that accepts an array of objects with the format `{name: "string", age: number}` and returns the names of all people who are over the age of `18`.

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Web Testing I

[GitHub Repo](https://github.com/LambdaSchool/webtesting-i-guided)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Unit Testing](https://github.com/LambdaSchool/webtesting-i-challenge)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[WEB Unit Testing for Web PT 18 w/Jason Maurer](https://youtu.be/iD9GVaBTMSw)**

  In this module, you will learn what a unit test is, and how to write them using Jest. At the end of this module, you should be able to: configure tools for adding automated tests to a JS project use Jest to write unit tests use Test Driven Development

- [All previous recordings](/archive/WEB4Node/module/recd26oZ3GBNHh3Na)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Install and configure jest into your project from yesterday afternoon. Dig into the Jest Documentation [here](https://jestjs.io/docs/en/configuration) for more specific configuration details you could use.

- Objective challenge:

  Write a unit test on one function from yesterday’s project.

- Objective challenge:

  Design a series of tests for a function that accepts an array of objects with the format `{name: "string", age: number}` and returns the names of all people who are over the age of `18`.

- Guided Project: Web Testing I

- Project: Unit Testing
