<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Intended as a home for Lambda School curriculum.">
  <meta name="author" content="">
  <meta name="generator" content="Jekyll v3.8.0">
  <title>Recursive Sorting · Lambda School</title>

  <link rel='stylesheet' integrity crossorigin='anonymous'
    href='https://d33wubrfki0l68.cloudfront.net/css/0f99ed215b3d52fa1bee44dc614ea3fa1d1bebc0/dist/css/bootstrap.min.css' />

  <link href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" rel="stylesheet">
  <link rel='stylesheet'
    href='https://d33wubrfki0l68.cloudfront.net/css/1bf8317b3d6d0c9d813c92505f052bf79ffdcdfe/assets/css/docs.min.css' />

  <link rel='stylesheet'
    href='https://d33wubrfki0l68.cloudfront.net/css/f3626ab7ab84821f8b60ea92b4a5c6acf59991af/assets/css/main.css' />

  <script>
    ( function ( i, s, o, g, r, a, m ) {
      i[ 'GoogleAnalyticsObject' ] = r;
      i[ r ] = i[ r ] || function () {
        ( i[ r ].q = i[ r ].q || [] ).push( arguments )
      }, i[ r ].l = 1 * new Date();
      a = s.createElement( o ),
        m = s.getElementsByTagName( o )[ 0 ];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore( a, m )
    } )( window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga' );
    ga( 'create', 'UA-122016605-1', 'learn.lambdaschool.com' );
    ga( 'send', 'pageview' );
  </script>

  <script>
    ! function () {
      var analytics = window.analytics = window.analytics || [];
      if ( !analytics.initialize )
        if ( analytics.invoked ) window.console && console.error && console.error( "Segment snippet included twice." );
        else {
          analytics.invoked = !0;
          analytics.methods = [ "trackSubmit", "trackClick", "trackLink", "trackForm", "pageview", "identify", "reset",
            "group", "track", "ready", "alias", "debug", "page", "once", "off", "on"
          ];
          analytics.factory = function ( t ) {
            return function () {
              var e = Array.prototype.slice.call( arguments );
              e.unshift( t );
              analytics.push( e );
              return analytics
            }
          };
          for ( var t = 0; t < analytics.methods.length; t++ ) {
            var e = analytics.methods[ t ];
            analytics[ e ] = analytics.factory( e )
          }
          analytics.load = function ( t, e ) {
            var n = document.createElement( "script" );
            n.type = "text/javascript";
            n.async = !0;
            n.src = "https://cdn.segment.com/analytics.js/v1/" + t + "/analytics.min.js";
            var a = document.getElementsByTagName( "script" )[ 0 ];
            a.parentNode.insertBefore( n, a );
            analytics._loadOptions = e
          };
          analytics.SNIPPET_VERSION = "4.1.0";
          analytics.load( "BjKorwKrSvMamfNoGkBq9rISk7wF6QQX" );
          analytics.page();
        }
    }();
  </script>

  <link rel="apple-touch-icon" href="/assets/img/favicons/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" href="/assets/img/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
  <link rel="icon" href="/assets/img/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
  <link rel="manifest" href="/assets/img/favicons/manifest.json">
  <link rel="mask-icon" href="/assets/img/favicons/safari-pinned-tab.svg" color="#a0001e">
  <link rel="icon" href="/favicon.ico">
  <meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
  <meta name="theme-color" content="#a0001e">
</head>

<body>
  <noscript>Please enable JavaScript to view this page.</noscript>
  <div id="redirect-message" style="display: none;">
    You must be logged in to view this page.
  </div>
  <div id="unauthorized-message" style="display: none;">
    You must be a Lambda School student to view this page.
  </div>
  <div id="content-wrapper" style="visibility: hidden;">
    <a id="skippy" class="sr-only sr-only-focusable" href="#content">
      <div class="container">
        <span class="skiplink-text">Skip to main content</span>
      </div>
    </a>
    <div class="mobile-menu">
      <div class="m-drop">
        <div class="mobile-row">
          <div class="header-row" style="padding: 3px 7px">
            <a class="navbar-brand" href="/" aria-label="Lambda School"><svg xmlns="http://www.w3.org/2000/svg"
                width="33" height="35" viewBox="0 0 33 35" fill="none">
                <path fill-rule="evenodd" clip-rule="evenodd"
                  d="M0 0V16.0609C0 27.7335 9.08929 31.7843 15.7321 34.7513H15.75L16.2857 35C16.4107 34.9289 16.5357 34.8756 16.6786 34.8223C16.75 34.7868 16.8393 34.7513 16.9107 34.7157C23.5714 31.7665 32.6964 27.698 32.6964 16.0609V0H0ZM20.7071 23.4536L20.3571 22.5102L15.6071 10.0736C15.3214 10.802 14.6607 12.5609 13.9464 14.4442L11.2143 21.7817C11.0893 22.1371 11.1607 22.3147 11.25 22.4391C11.4464 22.6701 11.8768 22.6701 12.5554 22.6701H12.6786L12.6768 23.4518H7.56964V22.6701H7.9625C8.65893 22.6701 9.23036 22.368 9.65893 21.5152L10.1768 20.3426L14.9089 8.29696L14.0696 6.07614H18.4804L24.5696 22.0127L25.125 23.4536H20.7071Z"
                  fill="#EC3944" />
              </svg></a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#mobile-course-menu"
              aria-controls="mobile-course-menu" aria-expanded="false" aria-label="Toggle navigation">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false">
                <title>Menu</title>
                <path stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10"
                  d="M4 7h22M4 15h22M4 23h22"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="nav-row">
          <div class="results-container">
            <ul id="results-container" class="dropdown list-group"></ul>
          </div>
          <div id="mobile-course-menu" class="collapse nav-row">
            <div class="docs-mobile-sidebar" id="bd-docs-nav-mobile">
              <nav class="bd-links">
                <div class="bd-toc-item">
                  <h4 class="bd-toc-link">Computer Science Legacy</h4>
                </div>

                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recd4D4w3QrigPqUF">
                    1.&nbsp;&nbsp;Intro to Python and OOP
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/recay2erzDlYUPSeO/">
                        Introduction to Python I
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recwpe3Y9TVWrGT8L/">
                        Introduction to Python II
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/reca7NYptklr7F403/">
                        Introduction to Python III
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recc3eWphKVYd0oHT/">
                        Introduction to Python IV
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recR4gHcvD21ziR9a">
                    2.&nbsp;&nbsp;Data Structures
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/rec3MaMAY78iDm7ax/">
                        Data Structures I
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recMcvOrFw5BWUku3/">
                        Data Structures II
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recx53S3pYfDfvFDm/">
                        Data Structures III
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recHdwPne4Xt3A7lk/">
                        Data Structures IV
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recd9grrKlURJ453N">
                    3.&nbsp;&nbsp;Algorithms
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/reck76SPX26beGSqE/">
                        Iterative Sorting
                      </a>
                    </li>
                    <li class="active bd-sidenav-active">
                      <a href="/cs/module/reccRh9h6ccXghfA4/">
                        Recursive Sorting
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recrCuZQMVI6LvxhD/">
                        A First-Pass Solution
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recsvJCzPlM2X63ZX/">
                        Writing Better Solutions
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recvDjRQEq49uoWsU">
                    4.&nbsp;&nbsp;CS Unit 1 Build
                  </a>
                  <ul class="nav bd-sidenav">

                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recAr3gdL8U57eho1">
                    5.&nbsp;&nbsp;Hash Tables
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/recSwIvbSV630gdVk/">
                        Hash Tables I
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recHzCwboKBLBB0Re/">
                        Hash Tables II
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recsEDFseukQWg92c/">
                        Hash Tables III & IV
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/rec7U9K7OCL5ihj0t">
                    6.&nbsp;&nbsp;Graphs
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/recBMbHtb8AOXq3UL/">
                        Graphs I
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recZL2m6Gx7B4dU3G/">
                        Graphs II
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/reck4RVWsg82eiYPZ/">
                        Graphs III
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recoGWlBHjuJxkL1y/">
                        Graphs IV
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/recndTnO1V8oDbBPb">
                    7.&nbsp;&nbsp;Computer Architecture
                  </a>
                  <ul class="nav bd-sidenav">

                    <li>
                      <a href="/cs/module/recsuJbrrFgbFUCRX/">
                        Computer Architecture: Basics, Number Bases
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/rec2NHr4Eyib7XdED/">
                        Computer Architecture: Bitwise Operations
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recvQUkzz23NTj20G/">
                        Computer Architecture: The System Stack
                      </a>
                    </li>
                    <li>
                      <a href="/cs/module/recGPVAdvQcmopSIO/">
                        Computer Architecture: Subroutines, CALL/RET
                      </a>
                    </li>
                  </ul>
                </div>
                <div class="bd-toc-item ">
                  <a class="bd-toc-link" href="/cs/sprint/reco0t22NdXmr8VyL">
                    8.&nbsp;&nbsp;CS Unit 2 Build
                  </a>
                  <ul class="nav bd-sidenav">

                  </ul>
                </div>
                <hr>
              </nav>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="main-container">
      <div class="sidebar-container bd-sidebar">
        <div class="docs-sidebar">
          <a class="navbar-brand" href="/" aria-label="Lambda School"><svg width="135" height="35" viewBox="0 0 756 197"
              fill="#ec3944">
              <g>
                <path
                  d="M292.9,126.6h-6.7c-9,0-12.6-1.9-12.6-9.5V48.5c0-7.7,1.6-8.6,11.4-9.7v-4.5h-41.3v4.5 c9.8,1.1,11.4,1.9,11.4,9.7v69.3c0,7.7-1.6,8.6-11.4,9.7v4.5h73.7l4.9-29.4h-4.4C308.5,119.6,303.9,126.6,292.9,126.6z">
                </path>
                <path
                  d="M385.5,121.1V79.3c0-15.8-9.4-22.4-26.6-22.4c-15,0-26.8,6.6-26.8,19.3c0,2.4,0.2,3.3,0.8,5h16.6 c-0.5-2-0.7-5-0.7-7.5c0-9.6,3.6-12.4,9.4-12.4c6.4,0,9.7,2,9.7,14.4v11.2l-20.8,7.7c-10.6,4.1-19.3,8.8-19.3,20.7 c0,10.9,7.5,17.8,18.6,17.8c9.9,0,17.4-6.2,21.9-12.1l0.1-0.1l0,0V132h26v-4.4C387.7,127.1,385.5,126.2,385.5,121.1z M368,117.8 c-4.4,3.3-7.6,5.3-12,5.4c-7.7,0-11.2-5.2-11.2-12.6c0-7.7,3.6-11.2,9.8-13.5l13.4-5.4V117.8L368,117.8z">
                </path>
                <path
                  d="M514.4,121V79.5c0-14.8-6-22.4-18.7-22.4c-11.5,0-19.4,6.6-25.5,13.9c-1.8-9.6-7.7-13.9-17.8-13.9 c-11.4,0-18.7,6.2-24.8,13.6V57h-2.3l-23.8,7.4v2.4l8.6,5v49.4c0,5-2.1,6.1-8.9,6.4v4.4h35.1v-4.4c-6.7-0.3-8.7-1.3-8.7-6.4v-47 c4.7-3.6,9.5-6.5,15.5-6.5c7.6,0,10.5,4.2,10.5,12.7v40.8c0,5-1.9,6.1-8.7,6.4v4.4l34.8,0v-4.4c-6.7-0.3-8.6-1.3-8.6-6.4v-47 c4.7-3.6,9.5-6.5,15.5-6.5c7.6,0,10.5,4.2,10.5,12.7l-0.1,40.5c0,5-1.8,6.4-8.6,6.7l0,4.4h35.1v-4.4 C516.7,127.4,514.4,126.1,514.4,121z">
                </path>
                <path
                  d="M573.2,57.3c-11,0-18.5,5.7-23.4,12.8V22.9h-2.7l-23.4,6.8v2.5l8.6,4.5V132h2.9l8-3.5c5.8,3.3,12.3,5,20.2,5 c20.8,0,37.4-15.8,37.4-42.6C600.9,69.9,590.4,57.3,573.2,57.3z M563.4,128.7c-5.4,0-10.3-2.4-13.7-7.9V73.6 c3.4-3.4,8.5-5.7,13.5-5.7c13.9,0,20,12.8,20,29.5C583.3,114.7,575.8,128.5,563.4,128.7z">
                </path>
                <path
                  d="M677,121.2V22.8h-2.6L651,29.6V32l8.6,4.5v25.7c-3.4-3.2-8.8-5.1-15.5-5.1c-19.9,0-35.2,15.3-35.2,41.3 c0,20.7,11.2,34.6,28.1,34.6c9.8,0,17-5.3,22.6-13.1v0.9V132h26.3l0-4.4C679.1,127.3,677,126.3,677,121.2z M659.6,117.1 L659.6,117.1c-3.4,3.4-8,5.1-13.2,5.1c-13.2,0-20.4-12.8-20.4-29.8c0-17.8,7.3-29.2,19.5-29.2c8.7,0,14.1,6.9,14.1,18.3 L659.6,117.1z">
                </path>
                <path
                  d="M747.1,121.1V79.3c0-15.8-9.4-22.4-26.6-22.4c-15,0-26.8,6.6-26.8,19.3c0,2.4,0.2,3.3,0.8,5h16.6 c-0.5-2-0.7-5-0.7-7.5c0-9.6,3.6-12.4,9.4-12.4c6.4,0,9.7,2,9.7,14.4v11.2l-20.8,7.7c-10.6,4.1-19.3,8.8-19.3,20.7 c0,10.9,7.5,17.8,18.6,17.8c9.9,0,17.4-6.2,21.9-12.1v-0.1h0.1l0,11.1l26,0.1v-4.5C749.3,127.1,747.1,126.2,747.1,121.1z M729.6,117.8c-4.4,3.3-7.6,5.3-12.1,5.4c-7.7,0-11.2-5.2-11.2-12.6c0-7.7,3.6-11.2,9.8-13.5l13.4-5.4L729.6,117.8L729.6,117.8z">
                </path>
              </g>
              <path
                d="M0,0v90.4c0,65.7,50.9,88.5,88.1,105.2h0.1l3,1.4c0.7-0.4,1.4-0.7,2.2-1c0.4-0.2,0.9-0.4,1.3-0.6 c37.3-16.6,88.4-39.5,88.4-105V0H0z M116,132l-2-5.3l-26.6-70c-1.6,4.1-5.3,14-9.3,24.6l-15.3,41.3c-0.7,2-0.3,3,0.2,3.7 c1.1,1.3,3.5,1.3,7.3,1.3H71l0,4.4H42.4l0-4.4h2.2c3.9,0,7.1-1.7,9.5-6.5l2.9-6.6l26.5-67.8l-4.7-12.5h24.7l34.1,89.7l3.1,8.1H116z">
              </path>
            </svg></a>
          <ul id="results-container" class="dropdown list-group"></ul>
          <nav class="bd-links collapse" id="bd-docs-nav">
            <div class="bd-toc-item">
              <h4 class="bd-toc-link">Computer Science Legacy</h4>
            </div>

            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recd4D4w3QrigPqUF">
                1.&nbsp;&nbsp;Intro to Python and OOP
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/recay2erzDlYUPSeO/">
                    Introduction to Python I
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recwpe3Y9TVWrGT8L/">
                    Introduction to Python II
                  </a>
                </li>
                <li>
                  <a href="/cs/module/reca7NYptklr7F403/">
                    Introduction to Python III
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recc3eWphKVYd0oHT/">
                    Introduction to Python IV
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recR4gHcvD21ziR9a">
                2.&nbsp;&nbsp;Data Structures
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/rec3MaMAY78iDm7ax/">
                    Data Structures I
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recMcvOrFw5BWUku3/">
                    Data Structures II
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recx53S3pYfDfvFDm/">
                    Data Structures III
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recHdwPne4Xt3A7lk/">
                    Data Structures IV
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recd9grrKlURJ453N">
                3.&nbsp;&nbsp;Algorithms
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/reck76SPX26beGSqE/">
                    Iterative Sorting
                  </a>
                </li>
                <li class="active bd-sidenav-active">
                  <a href="/cs/module/reccRh9h6ccXghfA4/">
                    Recursive Sorting
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recrCuZQMVI6LvxhD/">
                    A First-Pass Solution
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recsvJCzPlM2X63ZX/">
                    Writing Better Solutions
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recvDjRQEq49uoWsU">
                4.&nbsp;&nbsp;CS Unit 1 Build
              </a>
              <ul class="nav bd-sidenav">

              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recAr3gdL8U57eho1">
                5.&nbsp;&nbsp;Hash Tables
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/recSwIvbSV630gdVk/">
                    Hash Tables I
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recHzCwboKBLBB0Re/">
                    Hash Tables II
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recsEDFseukQWg92c/">
                    Hash Tables III & IV
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/rec7U9K7OCL5ihj0t">
                6.&nbsp;&nbsp;Graphs
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/recBMbHtb8AOXq3UL/">
                    Graphs I
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recZL2m6Gx7B4dU3G/">
                    Graphs II
                  </a>
                </li>
                <li>
                  <a href="/cs/module/reck4RVWsg82eiYPZ/">
                    Graphs III
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recoGWlBHjuJxkL1y/">
                    Graphs IV
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/recndTnO1V8oDbBPb">
                7.&nbsp;&nbsp;Computer Architecture
              </a>
              <ul class="nav bd-sidenav">

                <li>
                  <a href="/cs/module/recsuJbrrFgbFUCRX/">
                    Computer Architecture: Basics, Number Bases
                  </a>
                </li>
                <li>
                  <a href="/cs/module/rec2NHr4Eyib7XdED/">
                    Computer Architecture: Bitwise Operations
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recvQUkzz23NTj20G/">
                    Computer Architecture: The System Stack
                  </a>
                </li>
                <li>
                  <a href="/cs/module/recGPVAdvQcmopSIO/">
                    Computer Architecture: Subroutines, CALL/RET
                  </a>
                </li>
              </ul>
            </div>
            <div class="bd-toc-item ">
              <a class="bd-toc-link" href="/cs/sprint/reco0t22NdXmr8VyL">
                8.&nbsp;&nbsp;CS Unit 2 Build
              </a>
              <ul class="nav bd-sidenav">

              </ul>
            </div>
            <hr>
          </nav>
        </div>
      </div>
      <main class="content-container flex-wrapper" role="main">
        <div class="sticky-nav">
          <div class="sprint-nav">
            <ul class="section-nav">
              <li class="toc-entry toc-h2"><a href="#prepare">Prepare</a></li>
              <li class="toc-entry toc-h2"><a href="#learn">Learn</a></li>
              <li class="toc-entry toc-h2"><a href="#project">Project</a></li>
              <li class="toc-entry toc-h2"><a href="#review">Review</a></li>
            </ul>
          </div>

        </div>
        <div class="wrapper limit-width">
          <div class="flex-wrapper">
            <div class="limit-width">
              <div class="jumbotron">
                <h1 class="bd-title" id="content">Recursive Sorting</h1>
                <span class="lead">
                  <p class="bd-lead"></p>
                </span>
                <strong>At the end of this module, you should be able to:</strong>
                <ul>
                  <li>identify when a problem is amenable to a recursive solution and use recursion to solve it</li>
                  <li>trace and accurately identify the output of a recursive function call</li>
                  <li>write a recursive solution to a problem</li>
                  <li>distinguish when to use, classify the performance, and implement code to conduct classic recursive
                    sorting algorithms</li>
                </ul>
              </div>
              <div class="alert alert-warning" role="alert">
                <h4>Pro Tip</h4>
                <p>Keep in mind that anything you put on social media reflects your brand. Consider what is important
                  for you to say and for other people to hear you say, and use this to shape a social media presence
                  that is both professional and authentic to you.</p>
              </div>
              <h2 class="display-4">
                <a id="prepare" class="anchor" href="#prepare" aria-hidden="true"><span
                    class="octicon octicon-link"></span></a>Prepare</h2>
              <p class="lead">Review each preclass resource before class.</p>
              <div class="preclass">
                <ul class="list-group list-group-flush">
                  <li class="list-group-item">
                    <div class="embed-responsive embed-responsive-16by9">
                      <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/n59qpp0SNDo"
                        frameborder="0" allowfullscreen></iframe>
                    </div>
                  </li>
                  <li class="list-group-item">
                    <div class="embed-responsive embed-responsive-16by9">
                      <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/TYsKscmQCWA"
                        frameborder="0" allowfullscreen></iframe>
                    </div>
                  </li>
                </ul>
              </div>
              <h2 class="display-4">
                <a id="learn" class="anchor" href="#learn" aria-hidden="true"><span
                    class="octicon octicon-link"></span></a>Learn</h2>
              <h4 class="mark mb-3 p-2">Learn to identify when a problem is amenable to a recursive solution and use
                recursion to solve it</h4>
              <h5>Overview</h5>
              <h3 id="what-is-recursion">What is recursion?</h3>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>Recursion is a method to solve problems. It means breaking down a problem into smaller and smaller
                sub-problems until the sub-problem is easy to solve. Recursive functions call themselves. Often,
                recursive solutions are terse and elegant. Recursive solutions are not always the most efficient.
                However, they can be an excellent starting point that you can improve the efficiency of afterward.</p>
              <h3 id="a-simple-example">A simple example</h3>
              <p>Let us say that I give you a list of numbers.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre>
                </div>
              </div>
              <p>I ask you to write a function that returns the sum of all the numbers in the list.</p>
              <p>With an iterative approach, you would need a variable to keep track of the sum, a loop that adds each
                item in the list to the sum, and to return the sum after the loop ends.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">i</span>
    <span class="k">return</span> <span class="nb">sum</span>
</code></pre>
                </div>
              </div>
              <p>This iterative function depends on the ability to loop through each item in the list. Another way to
                iterate through a collection is with recursion. It’s a little harder to understand at first, but the
                resulting code is often cleaner, simpler, and easier to understand.</p>
              <p>How many numbers can you sum without having to rely on the loop construct? The answer is two. How can
                we think of our problem as a collection of sums of only two numbers?</p>
              <p>I’ll put it another way. If you had the following, and I asked you to use parentheses to split the
                problem into sums of two numbers, how would you do it?</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>1 + 2 + 3 + 4 + 5
</code></pre>
                </div>
              </div>
              <p>Here is one way you could do it:</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/ac0a1098-22e7-4539-a291-0e5a0dbb5c3c_S2-M2-Illustrations-011.gif"
                  alt="https://tk-assets.lambdaschool.com/ac0a1098-22e7-4539-a291-0e5a0dbb5c3c_S2-M2-Illustrations-011.gif">
              </p>
              <p>You start by separating the problem into two subproblems:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>1 + 2 + 3 + 4 + 5
(1 + (2 + 3 + 4 + 5))
</code></pre>
                </div>
              </div>
              <p>Now, we continue doing so until we can no longer divide the problem into two subproblems:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>1 + 2 + 3 + 4 + 5
(1 + (2 + 3 + 4 + 5))
(1 + (2 + (3 + 4 + 5)))
(1 + (2 + (3 + (4 + 5))))
(1 + (2 + (3 + (4 + (5)))))
</code></pre>
                </div>
              </div>
              <p>Now, let’s see if we can use this example to write a recursive function to sum a list of numbers.</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>The first thing we need to consider for our recursive function is how do we know when to stop adding
                parentheses?</p>
              <p>When we add the first set, we are asking, what is the sum of the first item and the sum of the rest of
                the items?</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/e0a128da-753f-4ec7-bd71-c93c1e1e3416_S2-M2-O1FirstandRest.gif"
                  alt="https://tk-assets.lambdaschool.com/e0a128da-753f-4ec7-bd71-c93c1e1e3416_S2-M2-O1FirstandRest.gif">
              </p>
              <p>But, as we continue dividing the problem into subproblems, we “run out” of the “rest of items.” Once we
                no longer have a list of items longer than one, we cannot break up the list into the first item and the
                rest of the items. So, if someone asks us to sum one number, we know that the result is equal to that
                number. This “running out” is the base case for our recursive function.</p>
              <p><em>Note: we usually place the base case of a recursive function in the first few lines of the
                  function, but it doesn’t have to be.</em></p>
              <p>Let’s start writing out our function in pseudocode:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>sum_list(items)
    if the length of items is one
        return the one item in the list
</code></pre>
                </div>
              </div>
              <p>But what if someone asks us to sum more than one item? We must sum the first number and the sum of the
                rest of the items in the list.</p>
              <p>Let’s add this to our pseudocode:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>sum_list(items)
    if the length of items is one
        return the one item in the list
    otherwise
        return the first item from the list + sum_list(the rest of the items)

</code></pre>
                </div>
              </div>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <p>Now, let’s convert our pseudocode into actual Python code:</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre>
                </div>
              </div>
              <p><img src="https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg"
                  alt="upeR"></p>
              <p>Now that we have our function defined let’s see what happens when we call it.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/6f586ee8-343f-4c62-a94e-fbda772ab2e9_S2-M2-O1-Sum-List-Call-Stack-Animation.gif"
                  alt="https://tk-assets.lambdaschool.com/6f586ee8-343f-4c62-a94e-fbda772ab2e9_S2-M2-O1-Sum-List-Call-Stack-Animation.gif">
              </p>
              <p>Now, you can see how the recursive calls go “out” before they return and start working their way “back”
                to the original call.</p>
              <h3 id="an-even-simpler-example">An even simpler example</h3>
              <p>Maybe you are still confused? Let’s write a recursive function that can print each integer from <code
                  class="highlighter-rouge">n</code> down to <code class="highlighter-rouge">0</code>.</p>
              <p>We start by writing our function in pseudocode.</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>print_to_zero(n):
    print n
    if n is 0
        return
    return print_to_zero(n - 1)
</code></pre>
                </div>
              </div>
              <p>The first line of our pseudocode function prints the value of <code class="highlighter-rouge">n</code>.
                Then, we check the base case, is <code class="highlighter-rouge">n</code> equal to <code
                  class="highlighter-rouge">0</code>, and if it is, we return and stop recursing. The final return in
                our pseudocode is our recursive case, where we decrement the previous call’s <code
                  class="highlighter-rouge">n</code> value and call the function itself with that decremented value (the
                recursive case).</p>
              <p>Let’s turn it into actual Python code and then look at a visualization of the call stack when we call
                this function.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">print_to_zero</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># base case
</span>        <span class="k">return</span>
    <span class="k">return</span> <span class="n">print_to_zero</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># recursive case
</span></code></pre>
                </div>
              </div>
              <p><img
                  src="https://tk-assets.lambdaschool.com/f6d24e36-d891-4127-bb06-ea22cb2247ec_S2-M2-O1PrinttoZeroVisualization.gif"
                  alt="Print to Zero Visualization"></p>
              <p>One thing you might’ve realized is that our current function doesn’t handle inputs of less than <code
                  class="highlighter-rouge">0</code>. Ideally, our function should be able to handle these inputs
                without getting stuck in an infinite recursion (which would lead to a stack overflow).</p>
              <p>Let’s modify our function so that it handles inputs of less than zero.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">print_to_zero</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># base case
</span>        <span class="k">return</span>
    <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">print_to_zero</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># recursive case
</span></code></pre>
                </div>
              </div>
              <h3 id="three-rules-of-recursion">Three rules of recursion</h3>
              <p>Let’s use our <code class="highlighter-rouge">sum_list</code> function to see if we could make more
                generalized observations about recursion.</p>
              <p>The three rules for a recursive function are:</p>
              <ol>
                <li>Must have a base case.</li>
                <li>Must change its state to move towards the base case.</li>
                <li>Must call itself.</li>
              </ol>
              <h4 id="1-must-have-a-base-case">1. Must have a base case</h4>
              <p>The first rule for recursion is that a recursive algorithm <strong><em>must have a base
                    case</em></strong>.</p>
              <p>What is a base case? It allows the algorithm to <em>stop</em> recursing. With our <code
                  class="highlighter-rouge">sum_list</code> function, what allows the algorithm to stop recursing?</p>
              <p>It’s the first line, <code class="highlighter-rouge">if len(items) == 1:</code>. Notice how if this
                condition is true, it returns a value and doesn’t make a recursive call to itself. We are saying to stop
                recursing if the list to sum has only one item.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Base Case
</span>        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre>
                </div>
              </div>
              <h4 id="2-must-change-its-state-to-move-towards-the-base-case">2. Must change its state to move towards
                the base case</h4>
              <p>The second rule is that the algorithm <strong><em>must change its state to move towards the base
                    case</em></strong>.</p>
              <p>How does our function do that? With each subsequent recursion, the list passed into <code
                  class="highlighter-rouge">sum_list</code> is one item smaller. For example, on the first recursion
                <code class="highlighter-rouge">items</code> is <code class="highlighter-rouge">[2,3,4,5]</code> and on
                the subsequent recursion <code class="highlighter-rouge">items</code> is <code
                  class="highlighter-rouge">[3,4,5]</code>.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Base Case
</span>        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c1"># items[1:] has one less item
</span></code></pre>
                </div>
              </div>
              <p>It’s obvious then that regardless of the list’s length, we will reach the base case where the list we
                are summing has only one item.</p>
              <h4 id="3-must-call-itself">3. Must call itself</h4>
              <p>The third rule is that the algorithm <strong><em>must call itself</em></strong>. We are doing this on
                the final line of the function.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Base Case
</span>        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum_list</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c1"># Calls sum_list recursively
</span></code></pre>
                </div>
              </div>
              <p><img
                  src="https://tk-assets.lambdaschool.com/fc57628d-9174-46f8-811c-aeac4e532706_S2-M2-Illustrations-O1-Rules-For-Recursion.gif"
                  alt="https://tk-assets.lambdaschool.com/fc57628d-9174-46f8-811c-aeac4e532706_S2-M2-Illustrations-O1-Rules-For-Recursion.gif">
              </p>
              <h3 id="when-should-i-use-recursion">When should I use recursion?</h3>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>Now that we’ve considered one recursive algorithm and we’ve also discussed the three rules of
                recursion, we should think about when it is appropriate to use recursion.</p>
              <p>When you are out in the world solving real-world problems, the problem itself doesn’t say, “Hey! You
                should use recursion to solve me!” It’s your job as the problem-solver to decide if using recursion
                makes sense.</p>
              <p>So, what clues or hints might you find within a problem that could lead you to use recursion?</p>
              <ul>
                <li>Compute the nth term</li>
                <li>List the first or last n terms</li>
                <li>Generate all permutations</li>
              </ul>
              <p>Another way to think about it is to use the three rules. Is there a clear base case or stopping point
                that you are working towards (Rule 1)? Is there a clear way that the state of the data changes with each
                iteration that brings it closer to the base case (Rule 2)?</p>
              <h5>Follow Along</h5>
              <p>We now look at another typical example to learn recursion–computing factorials.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>A factorial (<code class="highlighter-rouge">n!</code>) is computed by taking <code
                  class="highlighter-rouge">n * (n-1) * (n-2) * ... 1</code>.</p>
              <p>For example, <code class="highlighter-rouge">4!</code> is computed by doing the following:</p>
              <p><code class="highlighter-rouge">4 * (4 - 1) * (4 - 2) * (4 - 3)</code></p>
              <p><code class="highlighter-rouge">4 * 3 * 2 * 1</code></p>
              <p><code class="highlighter-rouge">24</code></p>
              <p>When does computing factorials come in handy? They are required when figuring combinations; how many
                ways can we arrange this many items? Or how many orders can there be with this list? Also, they are
                useful for determining ways of choosing a certain number of items from a collection. For example, if you
                have 100 different menu items, how many possible 5-item orders could you make?</p>
              <p>Okay, let’s get back to our <code class="highlighter-rouge">4!</code> example. Let’s look again at the
                computation and see if we can make some connections to our three rules for recursion.</p>
              <p><code class="highlighter-rouge">4! = 4 * (4 - 1) * (4 - 2) * (4 - 3)</code></p>
              <p>First, how did we know to stop writing? Why didn’t we just keep going?</p>
              <p><code class="highlighter-rouge">4! = 4 * (4 - 1) * (4 - 2) * (4 - 3) * (4 - 4) * (4 - 5) * (4 - 6) *
                  ...</code></p>
              <p>Well, before when talking about the general case we wrote factorial like</p>
              <p><code class="highlighter-rouge">n! = n * (n - 1) * (n - 2) * ... 1</code></p>
              <p>What is the last item in the procedure, or how did we know to stop? When the item is <code
                  class="highlighter-rouge">1</code>. Could this serve as the base case for our recursive factorial
                function? Let’s try it out!</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>We start by writing pseudocode.</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>recursive_factorial(n)
    if n equals 1
        return 1
</code></pre>
                </div>
              </div>
              <p>Okay, so now we have a base case (Rule 1). But what about changing the state to move towards the base
                case (Rule 2)?</p>
              <p>Let’s look again at <code class="highlighter-rouge">4!</code></p>
              <p><code class="highlighter-rouge">4! = 4 * (4 - 1) * (4 - 2) * (4 - 3)</code></p>
              <p>Notice that just like we can write <code class="highlighter-rouge">4!</code> as <code
                  class="highlighter-rouge">4 * (4 - 1) * ... 1</code>, we can write <code class="highlighter-rouge">(4
                  - 1)!</code> as <code class="highlighter-rouge">(4 - 1) * (4 - 2) * ... 1</code>. So, the inverse
                would also be true; we can write <code class="highlighter-rouge">(4 - 1) * (4 - 2) * ... 1</code> as
                <code class="highlighter-rouge">(4 - 1)!</code>. Which means we can write <code
                  class="highlighter-rouge">4!</code> as <code class="highlighter-rouge">4 * (4 - 1)!</code>.</p>
              <p>Okay, we can’t miss what we just discovered. Our discovery means that we can express factorial in terms
                of itself. For any <code class="highlighter-rouge">n!</code> we can solve it by breaking it into smaller
                sub-problems that also require factorial (Rule 3). And Rule 2 is satisfied because we make each
                subsequent call to factorial on a smaller <code class="highlighter-rouge">n</code>.</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>recursive_factorial(n)
    if n equals 1
        return 1
    otherwise
        return n * recursive_factorial(n - 1)
</code></pre>
                </div>
              </div>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <p>Now, we just need to convert our pseudocode into actual Python code. Luckily, in Python, this is
                usually quite trivial to do.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">recursive_factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
                </div>
              </div>
              <h5>Challenge</h5>
              <ol>
                <li>Write a <em>recursive</em> search function that receives as input an array of integers and a target
                  integer value. This function should return <code class="highlighter-rouge">True</code> if the target
                  element exists in the array, and <code class="highlighter-rouge">False</code> otherwise.
                  <ul>
                    <li>What would be the base case(s) we’d have to consider for implementing this function?</li>
                    <li>How should our recursive solution converge on our base case(s)?</li>
                  </ul>
                </li>
                <li>In your own words, write out the three rules for recursion and how you can identify when a problem
                  is amenable to using a recursive method.</li>
              </ol>
              <hr>
              <h4 class="mark mb-3 p-2">Learn to trace and accurately identify the output of a recursive function call
              </h4>
              <h5>Overview</h5>
              <h3 id="what-is-a-stack">What is a stack?</h3>
              <p>A stack is a simple data structure. In the future, we cover stacks in more detail, but for now, a
                cursory understanding is helpful.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>Let’s start with an example. What if you were throwing a dinner party, and you had a bunch of tasks to
                get done before your friends started arriving? One method for tracking your to-do items would be to get
                some sticky notes, write our tasks on a sticky note, and place them in a pile. To choose what to work
                on, you’d take the top sticky note off the pile and discard it after you complete it. If in the course
                of your work, you think of another task to complete, you’d write a new sticky note and place it on top
                of the pile.</p>
              <p>So, there are two ways of interacting with a stack. You can <strong>pop</strong> the top item off, or
                you can <strong>push</strong> an item onto the top.</p>
              <h3 id="what-is-the-call-stack">What is the call stack?</h3>
              <p>The whole reason we are talking about stacks in the first place is so we can understand the call stack.
                Call stacks help us understand recursion.</p>
              <p>Whenever your program calls a function, the computer sets aside a chunk of memory for that function’s
                execution context. Any variables in that function scope are stored here.</p>
              <p>The computer stores these chunks of memory in the call stack, which has two fundamental operations;
                pushing onto the top and popping off the top of the stack. The computer pushes a chunk on the stack when
                a function is called. The computer pops a chunk off when a function finishes executing and returns.
                Let’s look at a simple example.</p>
              <p>We have two functions defined in our scope–one to add 2 to our input and another to add 4.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">add_four</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_two</span><span class="p">(</span><span class="n">add_two</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
</code></pre>
                </div>
              </div>
              <p>Let’s think about what the call stack looks like when we call these functions. First, what happens when
                we run the following:</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">add_four</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</code></pre>
                </div>
              </div>
              <p><img
                  src="https://tk-assets.lambdaschool.com/5dca1dc0-856b-44cb-a010-0f0304577567_S2-M2-O2-Add-2-Add-4.gif"
                  alt="https://tk-assets.lambdaschool.com/5dca1dc0-856b-44cb-a010-0f0304577567_S2-M2-O2-Add-2-Add-4.gif">
              </p>
              <ol>
                <li>
                  <code class="highlighter-rouge">add_two</code> call gets pushed onto the call stack</li>
                <li>
                  <code class="highlighter-rouge">num</code> gets stored in memory with the value <code
                    class="highlighter-rouge">2</code>
                </li>
                <li>
                  <code class="highlighter-rouge">num + 2</code> gets returned as <code
                    class="highlighter-rouge">4</code> and that call gets popped off</li>
                <li>
                  <code class="highlighter-rouge">add_four</code> call gets pushed on the stack, and <code
                    class="highlighter-rouge">6</code> gets stored as <code class="highlighter-rouge">num</code>
                </li>
                <li>the innermost <code class="highlighter-rouge">add_two</code> call gets pushed onto the stack, and
                  <code class="highlighter-rouge">6</code> gets stored as <code class="highlighter-rouge">num</code>
                </li>
                <li>the innermost <code class="highlighter-rouge">add_two</code> call returns <code
                    class="highlighter-rouge">8</code> and pops off</li>
                <li>the second <code class="highlighter-rouge">add_two</code> call gets pushed onto the stack with <code
                    class="highlighter-rouge">8</code> as <code class="highlighter-rouge">num</code>
                </li>
                <li>the second <code class="highlighter-rouge">add_two</code> call</li>
                <li>returns <code class="highlighter-rouge">10</code> and gets popped off</li>
                <li>we are back in the context of <code class="highlighter-rouge">add_four</code>, which now returns
                  <code class="highlighter-rouge">10</code> and pops off the stack</li>
                <li>the stack is now empty</li>
              </ol>
              <h5>Follow Along</h5>
              <h3 id="fibonacci">Fibonacci</h3>
              <p>Next, we look at the Fibonacci Sequence. (Here is an <a
                  href="https://www.youtube.com/watch?v=SjSHVDfXHQ4">interesting talk</a> about the Fibonacci Sequence.)
              </p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>This is a series of numbers:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
</code></pre>
                </div>
              </div>
              <p>We can derive the next number in the sequence by summing the previous two numbers. So, the next number
                in the series shown above would be 55 (34 + 21).</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/9cb8ba72-5a54-4f6c-a356-3783c6467455_S2-M2-Illustrations-O2-Fibonacci.gif"
                  alt="https://tk-assets.lambdaschool.com/9cb8ba72-5a54-4f6c-a356-3783c6467455_S2-M2-Illustrations-O2-Fibonacci.gif">
              </p>
              <p>We can write the Fibonacci Sequence like this:</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/917bd4a9-b98f-413f-a292-8dbfe9e67ca0_S2-M2-Illustrations-Fibonacci-Sequence-Table.001.jpeg"
                  alt="https://tk-assets.lambdaschool.com/917bd4a9-b98f-413f-a292-8dbfe9e67ca0_S2-M2-Illustrations-Fibonacci-Sequence-Table.001.jpeg">
              </p>
              <p>So, we can write the 7th term as x<sub>n</sub>, and you can describe any term in the sequence as:</p>
              <p>x<sub>n</sub> = x<sub>n-1</sub> + x<sub>n-2</sub></p>
              <p>Using this rule, if you wanted to find the 10th term, you could write:</p>
              <p>x<sub>10</sub> = x<sub>10-1</sub> + x<sub>10-2</sub></p>
              <p>x<sub>10</sub> = x<sub>9</sub> + x<sub>8</sub></p>
              <p>x<sub>10</sub> = 34 + 21</p>
              <p>x<sub>10</sub> = 55</p>
              <p>With the information above, it’s easy to write a simple, naïve algorithm to find the n<sup>th</sup>
                term in the Fibonacci Sequence.</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>We can start with pseudocode.</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>recursive_fib(n):
    if n is less than or equal to 1
        return n
    otherwise
        return recursive_fib(n - 1) + recursive_fib(n - 2)
</code></pre>
                </div>
              </div>
              <p>Luckily, since this is quite a simple algorithm, it is relatively trivial to convert this into Python
                code.</p>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre>
                </div>
              </div>
              <p>The function now represents the rules for the sequence that we’ve gone over. The base cases are the
                first two terms in the sequence; the 0<sup>th</sup> term is 0 and the 1<sup>st</sup> term is 1. For
                every other term, we find the value by summing the previous two terms.</p>
              <p>Despite having a good understanding of the function and the rule for the sequence, we may not have an
                excellent conceptual understanding of what happens with the call stack when the function gets
                called–let’s inspect closer.</p>
              <p>To more clearly illustrate the building of the stack, we will split our return statement up like this:
              </p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_minus_1</span> <span class="o">=</span> <span class="n">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n_minus_2</span> <span class="o">=</span> <span class="n">recursive_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_minus_1</span> <span class="o">+</span> <span class="n">n_minus_2</span>
</code></pre>
                </div>
              </div>
              <p>Now, let’s find the 4th item in the sequence by calling <code
                  class="highlighter-rouge">recursive_fib(4)</code>.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/6af00728-5ab9-4013-893a-63fd932664c5_S2-M2-O2-Recursive-Fib-Call-Stack.gif"
                  alt="https://tk-assets.lambdaschool.com/6af00728-5ab9-4013-893a-63fd932664c5_S2-M2-O2-Recursive-Fib-Call-Stack.gif">
              </p>
              <p>It might be helpful to watch the call stack animation above many times – until you understand what is
                happening. It can take some time, but eventually, it clicks, and it makes all future recursion problems
                easier when it does.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>The stack gets kicked off by the first <code class="highlighter-rouge">recursive_fib(4)</code> call.
                Then, on line 5, <code class="highlighter-rouge">recursive_fib(3)</code> gets pushed onto the stack.
                Then, <code class="highlighter-rouge">recursive_fib(2)</code> and <code
                  class="highlighter-rouge">recursive_fib(1)</code>. We are finally at a base case. That means we should
                be able to return and pop something off the stack. We do, and <code
                  class="highlighter-rouge">recursive_fib(1)</code> returns <code class="highlighter-rouge">1</code> and
                pops off the stack. We are now on line 6 in the context of the <code
                  class="highlighter-rouge">recursive_fib(2)</code> call. Now, we push <code
                  class="highlighter-rouge">recursive_fib(0)</code> onto the stack, which returns <code
                  class="highlighter-rouge">0</code> and immediately pops off. Again, in the context of <code
                  class="highlighter-rouge">recursive_fib(2)</code>, we can now return our sum of <code
                  class="highlighter-rouge">n_minus_1</code> and <code class="highlighter-rouge">n_minus_2</code>. These
                values are <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">0</code>
                respectively, so we return <code class="highlighter-rouge">1</code> and pop <code
                  class="highlighter-rouge">recursive_fib(2)</code> off the stack.</p>
              <p>Now, we are in the context of <code class="highlighter-rouge">recursive_fib(3)</code>, and we push
                <code class="highlighter-rouge">recursive_fib(1)</code>, which returns <code
                  class="highlighter-rouge">1</code> and pops off. We can now return from <code
                  class="highlighter-rouge">recursive_fib(3)</code> with <code class="highlighter-rouge">1 + 1</code> or
                <code class="highlighter-rouge">2</code>.</p>
              <p>Next, in the context of <code class="highlighter-rouge">recursive_fib(4)</code>, we push <code
                  class="highlighter-rouge">recursive_fib(2)</code> onto the stack. What you should notice here is that
                we have to repeat what we previously did when we pushed <code
                  class="highlighter-rouge">recursive_fib(2)</code> to get to <code class="highlighter-rouge">1 +
                  0</code> or <code class="highlighter-rouge">1</code>. <em>This should get you thinking of what you
                  would do differently in a recursive function to prevent this repeat behavior.</em></p>
              <p>Once we repetitiously build and tear down the stack to get <code class="highlighter-rouge">1</code>, we
                are ready to return from our <code class="highlighter-rouge">recursive_fib(4)</code> context. We return
                <code class="highlighter-rouge">2 + 1</code> or <code class="highlighter-rouge">3</code>, pop <code
                  class="highlighter-rouge">recursive_fib(4)</code> off the stack, and now our call stack is empty.</p>
              <p>Here is another way to visualize what is happening as we build and tear down the stack:</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/9b54936d-1d54-4b46-b75c-26d2214ecbaf_S2-M2-Illustrations-Recursive-Fib-Tree-Call-Stack.gif"
                  alt="https://tk-assets.lambdaschool.com/9b54936d-1d54-4b46-b75c-26d2214ecbaf_S2-M2-Illustrations-Recursive-Fib-Tree-Call-Stack.gif">
              </p>
              <h5>Challenge</h5>
              <ol>
                <li>You are still learning the ins and outs of recursion and suppose you end up making a mistake and
                  writing a recursive function that runs forever. Your computer separates a spot in memory on the call
                  stack for each function call. What ends up happening to the stack when your recursive function keeps
                  running forever?</li>
                <li>What two operations does a stack have?</li>
                <li>Where do all function calls go?</li>
                <li>I am tasking you with tiling a 2” x 16” area of the floor. The tiles you are using are 1” x 2”. How
                  many ways are there to cover the area with tiles? <em>See three possible layouts in the image
                    below.</em>
                  <img
                    src="https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg"
                    alt="https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg">
                </li>
              </ol>
              <hr>
              <h4 class="mark mb-3 p-2">Learn to write a recursive solution to a problem</h4>
              <h5>Overview</h5>
              <p>The first problem we will solve using recursion is reversing a string. We need to write a recursive
                function that takes in a string and returns the reverse of that string.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>To start, let’s consider how we can break this problem into subproblems. Once we do that, the recursive
                solution will make itself apparent. Let’s consider the string <code
                  class="highlighter-rouge">"LAMBDA"</code>. The reverse of <code
                  class="highlighter-rouge">"LAMBDA"</code> is <code class="highlighter-rouge">"ADBMAL"</code>. We must
                figure out a way to restate the process of reversing a string in terms of itself.</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>We need to figure out how you can reverse a string by reversing smaller and smaller substrings. So,
                upon reflection, we can realize that the reverse of <code class="highlighter-rouge">"LAMBDA"</code> is
                the reverse of <code class="highlighter-rouge">"AMBDA"</code> + <code
                  class="highlighter-rouge">"L"</code>. And, continuing, the reverse of <code
                  class="highlighter-rouge">"AMBDA"</code> is the reverse of <code
                  class="highlighter-rouge">"MBDA"</code> + <code class="highlighter-rouge">"A"</code>. So, now that
                we’ve figured out a way to break our problems into smaller subproblems, we need to figure out how we
                know when to stop or what would be the base case?</p>
              <p>Well, let’s just continue our example above and see if the base case will make itself apparent.</p>
              <ul>
                <li>The reverse of <code class="highlighter-rouge">"MBDA"</code> is equal to the reverse of <code
                    class="highlighter-rouge">"BDA"</code> + <code class="highlighter-rouge">"M"</code>.</li>
                <li>The reverse of <code class="highlighter-rouge">"BDA"</code> is equal to the reverse of <code
                    class="highlighter-rouge">"DA"</code> + <code class="highlighter-rouge">"B"</code>.</li>
                <li>The reverse of <code class="highlighter-rouge">"DA"</code> is equal to the reverse of <code
                    class="highlighter-rouge">"A"</code> + <code class="highlighter-rouge">"D"</code>.</li>
                <li>The reverse of <code class="highlighter-rouge">"A"</code> is equal to the reverse of <code
                    class="highlighter-rouge">""</code> + <code class="highlighter-rouge">"A"</code>.</li>
              </ul>
              <p>Now, once we get to the reverse of <code class="highlighter-rouge">""</code>, we don’t have any further
                substrings to make. You can’t make a substring out of an empty string, so this seems like the logical
                base case where we can begin returning and start popping off the call stack.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/5a122628-d0fe-4f6d-a953-7398dddc849e_S2-M2-Illustrations-O3-Reverse-String-Call-Stack.gif"
                  alt="https://tk-assets.lambdaschool.com/5a122628-d0fe-4f6d-a953-7398dddc849e_S2-M2-Illustrations-O3-Reverse-String-Call-Stack.gif">
              </p>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <p>So, we now undertand our recursive case and our base case. We now need to turn that into actual Python
                code. For our recursive case, where we are stating <code class="highlighter-rouge">reverse("LAMBDA") =
                  reverse("AMBDA") + "L"</code>, we can state this in general terms as <code
                  class="highlighter-rouge">reverse(str) = reverse(str[1:]) + str[0]</code>. And we can check for an
                empty string for our base case with <code class="highlighter-rouge">len(str) == 0</code>.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre>
                </div>
              </div>
              <p>Now that we’ve coded it up. Let’s test it out and visualize how our recursive calls will affect the
                call stack.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/cb5f36b7-ff23-406d-a295-ecdca6ec3b7c_S2-M2-O3-Reverse-String-Call-Stack-Visualization.gif"
                  alt="https://tk-assets.lambdaschool.com/cb5f36b7-ff23-406d-a295-ecdca6ec3b7c_S2-M2-O3-Reverse-String-Call-Stack-Visualization.gif">
              </p>
              <p><img src="https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg"
                  alt="upeR"></p>
              <p>Notice how our call stack builds until we get to our base case, and then we start returning our
                strings, popping off the stack, and can slowly assemble our reversed string.</p>
              <h5>Follow Along</h5>
              <p>Next, we will use recursion to check if a string is a palindrome. So, our recursive function will
                receive a string as an input and return <code class="highlighter-rouge">True</code> if the string is a
                palindrome and return <code class="highlighter-rouge">False</code> if it is not a palindrome.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <p>First, what is a palindrome? A palindrome is a sequence of characters that reads the same forwards and
                backward. For example, <code class="highlighter-rouge">"abcddcba"</code> is a palindrome, but <code
                  class="highlighter-rouge">"abcd"</code> is not.</p>
              <p>Let’s try to reason what the simplest subproblem would be and see if we can come up with a base case.
                One thing to notice right away is that a string of one character or an empty string is a palindrome by
                definition. So, our base case is a string of length 1 or 0.</p>
              <p>Now, how do we move closer towards the base case with each subsequent function call? Well, one thing we
                have to notice is that for all palindromes, the first and last characters are equal. So, for example, we
                know right away that <code class="highlighter-rouge">"abcd"</code> is not a palindrome because the first
                and last characters (<code class="highlighter-rouge">a</code> and <code
                  class="highlighter-rouge">d</code>) are not the same. Thinking about this further, this is how we
                could break our massive problem into subproblems. Notice that for a palindrome like <code
                  class="highlighter-rouge">"abcddcba"</code>, the property of the first and last characters matching is
                true for the outer string but also true for each inner substring.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/1a3f8eed-917a-4d17-b743-7d856c6fffa7_S2-M2-Illustrations-Palindrome.001.jpeg"
                  alt="https://tk-assets.lambdaschool.com/1a3f8eed-917a-4d17-b743-7d856c6fffa7_S2-M2-Illustrations-Palindrome.001.jpeg">
              </p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>So, now we understand our base case (a string of length 0 or 1) and our recursive case(first and last
                characters or equal). Let’s represent the full recursive solution in pseudocode:</p>
              <ul>
                <li>If the string is of length 0 or 1, it is a palindrome.</li>
                <li>Otherwise, compare the first and last characters.
                  <ul>
                    <li>If the first and last characters are equal, strip those characters and check if the remaining
                      characters are a palindrome.</li>
                  </ul>
                </li>
              </ul>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <p>Now that we defined the pseudocode let’s turn it into actual Python code.</p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="c1"># If the string is of length 0 or 1, it is a palindrome.
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="c1"># Otherwise, compare the first and last characters.
</span>    <span class="k">if</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># If the first and last characters are equal, strip those characters and check if the remaining characters are a palindrome.
</span>        <span class="k">return</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre>
                </div>
              </div>
              <p><img src="https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg"
                  alt="upeR"></p>
              <p>Let’s visualize the call stack when we call our defined function.</p>
              <p>First, we will look at an example on a string that is a palindrome.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/2ab1dabe-ace3-474f-a716-48b4c6376035_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization.gif"
                  alt="https://tk-assets.lambdaschool.com/2ab1dabe-ace3-474f-a716-48b4c6376035_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization.gif">
              </p>
              <p>Next, let’s look at an example on a string that is not a palindrome.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/5adac8b7-ea52-4672-9f5f-121407618850_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization-2.gif"
                  alt="https://tk-assets.lambdaschool.com/5adac8b7-ea52-4672-9f5f-121407618850_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization-2.gif">
              </p>
              <p>Notice, how in both cases, the call stack keeps building until it can reach one of the base cases. The
                first base case is if the string is of length 0 or 1 (returns <code
                  class="highlighter-rouge">True</code>). The second is if the first and last character <strong>do
                  not</strong> match (returns <code class="highlighter-rouge">False</code>). Once one of the function
                calls returns a boolean value, this bubbles up to the first call and is the return value for the
                original function call.</p>
              <h5>Challenge</h5>
              <ol>
                <li>
                  <p>I place you in the hexagon that is labeled “Start”. I task you with getting to the hexagon that is
                    labeled “End”. Each move, you can only take one step to a neighboring cell, and you must move to the
                    right (closer to the hexagon labeled “End”). How many unique ways can you reach the hexagon labeled
                    “End”?</p>
                  <p><img
                      src="https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg"
                      alt="https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg">
                  </p>
                </li>
              </ol>
              <p><em>Hint: the Fibonacci Sequence can help solve this problem.</em></p>
              <hr>
              <h4 class="mark mb-3 p-2">Learn to distinguish when to use, classify the performance, and implement code
                to conduct classic recursive sorting algorithms</h4>
              <h5>Overview</h5>
              <p>Previously, we explored some iterative approaches to sorting the elements in a list or an array.
                However, many of these iterative solutions are not efficient in terms of their runtime or the memory
                required. In this module, we look at ways we can sometimes achieve performance gains by using a
                recursive approach.</p>
              <p><img src="https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg"
                  alt="Uper"></p>
              <h3 id="divide-and-conquer">Divide and Conquer</h3>
              <p>The “Divide and Conquer” (D&amp;C) strategy means solving a recursive problem by:</p>
              <ol>
                <li>Figuring out the base case or the simplest case.</li>
                <li>Dividing the massive problem into increasingly smaller problems until you reach the base case.</li>
              </ol>
              <p>Let’s use a simple example to illustrate D&amp;C.</p>
              <p>Imagine I give you an array of integers.</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>[1, 2, 3, 4, 5]
</code></pre>
                </div>
              </div>
              <p>I ask you to sum all the integers. I specifically ask you to solve this problem recursively.</p>
              <p>Following the steps above, we need first to find the base case. Well, the simplest thing to sum would
                be an array that only contained 1 or 0 integers. In that case, the sum would either be <code
                  class="highlighter-rouge">[]</code> (for an empty array) or the integer itself for an array of 1
                integer. So, our base case is an array of length 1 or 0.</p>
              <p>Now, for step two, we need to move closer to the base by dividing the larger problem into a smaller
                problem. We can do this by restating the original problem like this:</p>
              <div class="language-plaintext highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code>sum([1,2,3,4,5]) = 1 + sum([2,3,4,5])
</code></pre>
                </div>
              </div>
              <p>Let’s visualize how this would play out.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/f9275ff3-345f-46a3-99f3-79225bc00ee2_S2-M2-O4-Sum-Call-Stack-Visualization.gif"
                  alt="https://tk-assets.lambdaschool.com/f9275ff3-345f-46a3-99f3-79225bc00ee2_S2-M2-O4-Sum-Call-Stack-Visualization.gif">
              </p>
              <h3 id="quicksort">Quicksort</h3>
              <h4 id="how-it-works">How It Works</h4>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>Quicksort is another “Divide and Conquer” algorithm. The rules for the simple out-of-place version are:
              </p>
              <ol>
                <li>Choose a pivot.</li>
                <li>Move everything less than the pivot to one side.</li>
                <li>Move everything more than the pivot to the other side.</li>
                <li>Repeat steps 1-3 on the left-hand side and right-hand side of the partition.</li>
              </ol>
              <p>For an illustration of this simple out-of-place version of quicksort, see below:</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/0919779a-f288-4621-9962-2fa41cab5293_S2-M2-O4-Out-Of-Place-Quick-Sort-Animation.gif"
                  alt="https://tk-assets.lambdaschool.com/0919779a-f288-4621-9962-2fa41cab5293_S2-M2-O4-Out-Of-Place-Quick-Sort-Animation.gif">
              </p>
              <h4 id="runtime">Runtime</h4>
              <p><img src="https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg"
                  alt="upeR"></p>
              <h5 id="worst-case">Worst-case</h5>
              <p>The worst-case occurs when the pivot you choose at each step is the smallest or greatest element in the
                list. If that continues happening with each partition, the maximum number of partitions occurs. Here,
                quicksort takes <code class="highlighter-rouge">O(n^2)</code> time.</p>
              <h5 id="average-case">Average-case</h5>
              <p>If the list that you are sorting contains <code class="highlighter-rouge">n</code> distinct elements,
                then quicksort takes <code class="highlighter-rouge">O(n log n)</code> time–assuming that all <code
                  class="highlighter-rouge">n!</code> permutations of <code class="highlighter-rouge">n</code> elements
                are equally probable to occur in your list.</p>
              <h3 id="in-place-quicksort">In-Place Quicksort</h3>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>There is another, more elaborate version of quicksort that sorts the data in-place. The rules for this
                version are:</p>
              <ul>
                <li>If the pivot is on the left.
                  <ul>
                    <li>We compare the pivot with the right element.</li>
                    <li>If the right element is larger than the pivot.
                      <ul>
                        <li>We swap the values of the right element and the pivot.</li>
                        <li>The right element becomes the new pivot.</li>
                        <li>We increment the left index.</li>
                      </ul>
                    </li>
                    <li>If the right element is smaller than the pivot.
                      <ul>
                        <li>We decrement the right index value.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>If the pivot is on the right.
                  <ul>
                    <li>We compare the pivot with the left element.</li>
                    <li>If the pivot value is larger than the left element.
                      <ul>
                        <li>We increment the left index.</li>
                      </ul>
                    </li>
                    <li>If the pivot value is smaller than the left element.
                      <ul>
                        <li>We swap the values of the left element and the pivot.</li>
                        <li>The left element becomes the new pivot.</li>
                        <li>We decrement the right index.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>If pivot, left, and right all point to the same element.
                  <ul>
                    <li>That element is sorted.</li>
                    <li>Create left and right partitions.</li>
                    <li>Set new pivot, left, and right for both partitions starting with the left.</li>
                    <li>Repeat above procedure.</li>
                  </ul>
                </li>
              </ul>
              <p>For an illustration of this in-place quicksort, see below:</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/fee5b497-5a12-4ebb-9721-bbf6bb846de8_S2-M2-O4-In-Place-Quicksort-Animation.gif"
                  alt="https://tk-assets.lambdaschool.com/fee5b497-5a12-4ebb-9721-bbf6bb846de8_S2-M2-O4-In-Place-Quicksort-Animation.gif">
              </p>
              <h3 id="merge-sort">Merge Sort</h3>
              <h4 id="how-it-works-1">How It Works</h4>
              <p>Merge Sort is a recursive algorithm that uses the “Divide and Conquer” strategy outlined above.</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <p>First, the base case is when you have an array with 1 element. Second, to move towards the base case,
                you must repeatedly divide the original collection in half until we reach the base case.</p>
              <p>What is unique about lists or arrays with a single element? In other words, why is that the base case?
                The answer is because <em>they are already sorted!</em> A single element can’t be unsorted.</p>
              <p>Then, we can “merge” these sorted pieces back together.</p>
              <p><img
                  src="https://tk-assets.lambdaschool.com/3af0fec1-d59f-480f-a79a-c91c2c63e476_S2-M2-O4-Merge-Sort-Animation.gif"
                  alt="https://tk-assets.lambdaschool.com/3af0fec1-d59f-480f-a79a-c91c2c63e476_S2-M2-O4-Merge-Sort-Animation.gif">
              </p>
              <h4 id="runtime-complexity">Runtime Complexity</h4>
              <p><img src="https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg"
                  alt="upeR"></p>
              <p>The “divide” part of this algorithm requires us to cut a collection of elements in half until we have
                collections of 1. If our collection contains <code class="highlighter-rouge">n</code> elements, we have
                to perform more halving operations as <code class="highlighter-rouge">n</code> increases in size.
                However, the rate of growth is logarithmic rather than linear. This part of the algorithm has a runtime
                of <code class="highlighter-rouge">O(log(n))</code>.</p>
              <p>The “conquer” (merge) part of this algorithm requires only a single pass through each sorted
                sub-collection, giving it a runtime of <code class="highlighter-rouge">O(n)</code>.</p>
              <p>Since we “divide” and then “conquer”, we can think about the total runtime of merge sort as <code
                  class="highlighter-rouge">O(log(n)) * O(n)</code> or <code class="highlighter-rouge">O(n *
                  log(n))</code>.</p>
              <h5>Follow Along</h5>
              <h3 id="quicksort">Quicksort</h3>
              <p>There are many ways of completing the quicksort stub shown below. Specifically, there are many
                approaches to choosing a pivot. A simple approach is to use the first element in <code
                  class="highlighter-rouge">array</code>. Other approaches include choosing the middle element or even a
                random element.</p>
              <p><img src="https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg"
                  alt="upEr"></p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Base case: arrays with 0 or 1 element are already "sorted"
</span>        <span class="k">return</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Recursive case
</span>        <span class="n">pivot</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Sub-array of all the elements less than the pivot
</span>        <span class="n">less</span> <span class="o">=</span> <span class="p">[</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">]</span>
        <span class="c1"># Sub-array of all the elements greater than the pivot
</span>        <span class="n">greater</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">less</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
</code></pre>
                </div>
              </div>
              <h3 id="merge-sort">Merge Sort</h3>
              <p>When implementing merge sort, we often split the “Divide” and “Conquer” pieces of this algorithm into
                two separate functions to help improve readability. The recursive <code
                  class="highlighter-rouge">merge_sort()</code> handles dividing up the original list or array into a
                left-hand side and right-hand side. At the same time, the <code
                  class="highlighter-rouge">merge_helper()</code> merges two sorted pieces back together into a single
                sorted collection.</p>
              <p><img src="https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg"
                  alt="uPer"></p>
              <div class="language-python highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span> <span class="n">arr</span> <span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">arr</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># recursively call merge_sort() on LHS
</span>        <span class="c1"># recursively call merge_sort() on RHS
</span>        <span class="c1"># merge sorted pieces
</span>
<span class="k">def</span> <span class="nf">merge_helper</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">):</span>
    <span class="n">merged_arr</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># starting at the beginning of `a` and `b`
</span>    <span class="c1"># compare the next value of each
</span>    <span class="c1"># add smallest to `merged_arr`
</span>
    <span class="k">return</span> <span class="n">merged_arr</span>
</code></pre>
                </div>
              </div>
              <p><em>Note: Remember that <code class="highlighter-rouge">Python</code> passes collections by reference,
                  not by value.</em></p>
              <p>We are not showing a completed implementation of the merge sort algorithm here. You will create an
                implementation as a part of the module project.</p>
              <h5>Challenge</h5>
              <ol>
                <li>
                  <p>What is the Big O notation for the following operation:</p>
                  <p><em>Creating a multiplication table with all the elements in an array. If your array is [1, 2, 3],
                      you first multiply every element by 1, then every element by 2, and then every element by 3.</em>
                  </p>
                </li>
                <li>
                  <p>What will the contents of the array below be after each pass of the quicksort algorithm?
                    <em>(assume we choose the first element as the pivot)</em></p>
                  <p><img src="https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png"
                      alt="https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png"></p>
                </li>
                <li>
                  <p>What will the contents of the array below be after each pass of the merge sort algorithm?</p>
                  <p><img src="https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png"
                      alt="https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png"></p>
                </li>
              </ol>
              <hr>
              <h2 class="display-4">
                <a id="project" class="anchor" href="#project" aria-hidden="true"><span
                    class="octicon octicon-link"></span></a>Project</h2>
              <ul class="list-group">
                <li class="list-group-item">
                  <h5><a target="_blank"
                      href="https://github.com/LambdaSchool/cs-module-project-recursive-sorting">Recursive Sorting</a>
                  </h5>
                </li>
              </ul>
              <h2 class="display-4">
                <a id="review" class="anchor" href="#review" aria-hidden="true"><span
                    class="octicon octicon-link"></span></a>Review</h2>
              <h3 class="display-5">Class Recordings</h3>
              <p class="lead">You can use class recordings to help you master the material.</p>
              <div>
                <ul class="list-group list-group-flush">
                  <li class="list-group-item">
                    <strong><a target="_blank" href="https://youtu.be/jbm-eWQYbDI">Recursive Sorting for CS35 w/ Sean
                        Chen</a></strong>
                    <p>Student should be able to identify when a problem is amenable to a recursive solution and use
                      recursion to solve it</p>
                  </li>
                  <li class="list-group-item">
                    <a href="/archive/CS/module/reccRh9h6ccXghfA4">All previous recordings</a>
                  </li>
                </ul>
              </div>
              <h3 class="display-5">Demonstrate Mastery</h3>
              <p>To demonstrate mastery of this module, you need to complete and pass a code review on each of the
                following:</p>
              <ul>
                <li>Objective challenge: <ol>
                    <li>Write a <em>recursive</em> search function that receives as input an array of integers and a
                      target integer value. This function should return <code class="highlighter-rouge">True</code> if
                      the target element exists in the array, and <code class="highlighter-rouge">False</code>
                      otherwise.
                      <ul>
                        <li>What would be the base case(s) we’d have to consider for implementing this function?</li>
                        <li>How should our recursive solution converge on our base case(s)?</li>
                      </ul>
                    </li>
                    <li>In your own words, write out the three rules for recursion and how you can identify when a
                      problem is amenable to using a recursive method.</li>
                  </ol>
                </li>
                <li>Objective challenge: <ol>
                    <li>You are still learning the ins and outs of recursion and suppose you end up making a mistake and
                      writing a recursive function that runs forever. Your computer separates a spot in memory on the
                      call stack for each function call. What ends up happening to the stack when your recursive
                      function keeps running forever?</li>
                    <li>What two operations does a stack have?</li>
                    <li>Where do all function calls go?</li>
                    <li>I am tasking you with tiling a 2” x 16” area of the floor. The tiles you are using are 1” x 2”.
                      How many ways are there to cover the area with tiles? <em>See three possible layouts in the image
                        below.</em>
                      <img
                        src="https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg"
                        alt="https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg">
                    </li>
                  </ol>
                </li>
                <li>Objective challenge: <ol>
                    <li>
                      <p>I place you in the hexagon that is labeled “Start”. I task you with getting to the hexagon that
                        is labeled “End”. Each move, you can only take one step to a neighboring cell, and you must move
                        to the right (closer to the hexagon labeled “End”). How many unique ways can you reach the
                        hexagon labeled “End”?</p>
                      <p><img
                          src="https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg"
                          alt="https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg">
                      </p>
                    </li>
                  </ol>
                  <p><em>Hint: the Fibonacci Sequence can help solve this problem.</em></p>
                </li>
                <li>Objective challenge: <ol>
                    <li>
                      <p>What is the Big O notation for the following operation:</p>
                      <p><em>Creating a multiplication table with all the elements in an array. If your array is [1, 2,
                          3], you first multiply every element by 1, then every element by 2, and then every element by
                          3.</em></p>
                    </li>
                    <li>
                      <p>What will the contents of the array below be after each pass of the quicksort algorithm?
                        <em>(assume we choose the first element as the pivot)</em></p>
                      <p><img
                          src="https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png"
                          alt="https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png">
                      </p>
                    </li>
                    <li>
                      <p>What will the contents of the array below be after each pass of the merge sort algorithm?</p>
                      <p><img
                          src="https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png"
                          alt="https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png">
                      </p>
                    </li>
                  </ol>
                </li>
                <li>Project: Recursive Sorting</li>
              </ul>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80850900-4"></script>
    <script>
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push( arguments );
      }
      gtag( 'js', new Date() );

      gtag( 'config', 'UA-80850900-4' );
    </script>
    <script type="text/javascript">
      function getDomain() {
        const domainName = window.location.hostname.split( '.' )[ 1 ];
        return `${domainName}.com`;
      }
    </script>
    <script src="" integrity="" crossorigin="anonymous"></script>
    <script>
      window.jQuery || document.write( '<script src="/assets/js/vendor/jquery-slim.min.js"><\/script>' )
    </script>
    <script src="/assets/js/vendor/popper.min.js" integrity="" crossorigin="anonymous"></script>
    <script src="/dist/js/bootstrap.min.js" integrity="" crossorigin="anonymous"></script>
    <script src="/assets/js/activate.js"></script>
    <script src="/assets/js/jekyll-search.js" type="text/javascript"></script>
    <script type="text/javascript">
      SimpleJekyllSearch.init( {
        searchInput: document.getElementById( 'search-input' ),
        resultsContainer: document.getElementById( 'results-container' ),
        dataSource: '/search.json',
        searchResultTemplate: '<li class="list-group-item"><a href="{url}" title="Recursive Sorting">{title}</a></li>',
        noResultsText: '',
        limit: 10,
        fuzzy: true,
      } )
    </script>
    <script src="/assets/js/mermaid.min.js"></script>
    <script type="text/javascript">
      if ( window.attachEvent ) {
        window.attachEvent( 'onload', verifySignedIn );
      } else {
        if ( window.onload ) {
          var currentOnLoadFn = window.onload;
          var newOnLoadFn = function ( evt ) {
            currentOnLoadFn( evt );
            verifySignedIn();
          };
          window.onload = newOnLoadFn;
        } else {
          window.onload = verifySignedIn;
        }
      }

      function verifySignedIn() {
        if ( isPagePublic() ) {
          return showPageContents();
        }

        window.__user = null;
        isSignedIn().then( ( user ) => {
          window.__user = user;

          if ( !user.signedIn ) {
            redirectToSignIn();
          } else if ( !user.student && !window.__openToAdmissions ) {
            showUnauthorizedMessage();
          } else {
            showPageContents();
          }
        } );
      }

      function isPagePublic() {
        const openCourses = [
          'and-pre',
          'ds-pre',
          'fsw-pre',
          'help',
          'ios-pre',
        ];

        const openPages = [
          'cs-and',
          'cs-fsw',
          'cs-ios',
          'cr',
          'ds',
          'jx',
          'p4s',
          'ux',
        ];

        const pathParts = window.location.pathname.split( '/' );
        const courseName = pathParts[ 1 ];
        const pageName = pathParts[ pathParts.length - 1 ];

        return openCourses.includes( courseName ) || openPages.includes( pageName );
      }

      function isSignedIn() {
        const isDeployPreview = window.location.hostname.startsWith( 'deploy-preview' ) && window.location.hostname
          .endsWith( 'netlify.com' );

        if ( isDeployPreview ) return Promise.resolve( {
          signedIn: true,
          student: true
        } );

        return fetch( `${getAuthBaseUrl()}/whoami`, {
            credentials: 'include'
          } )
          .then( ( response ) => response.text() )
          .then( ( userAsText ) => userAsText ? JSON.parse( userAsText ) : null )
          .then( ( userData ) => ( {
            signedIn: Boolean( userData ),
            student: Boolean( userData && userData.airtableId ),
            id: userData ? userData.id : null,
            email: userData ? userData.email : null
          } ) )
          .catch( ( error ) => {} );
      }

      function redirectToSignIn() {
        const signInUrl =
          `${getAuthBaseUrl()}/sign-in?redirect=${encodeURIComponent(window.location.href)}&reason=auth_required`
        const redirectMessage = document.querySelector( '#redirect-message' );
        redirectMessage.style.display = "block";
        redirectMessage.innerHTML =
          `<div>You are being redirected to the sign in page. If you aren't redirected automatically, you can use <a href=${signInUrl}>this link</a>.</div>`
        window.location = signInUrl;
      }

      function showPageContents() {
        document.querySelector( '#content-wrapper' ).style.visibility = 'visible';
      }

      function showUnauthorizedMessage() {
        document.querySelector( '#unauthorized-message' ).style.display = 'block';
      }

      function getAuthBaseUrl() {
        const domain = getDomain();
        const authBaseUrl = `https://auth.${domain}`;
        return authBaseUrl;
      }
    </script>
    <script src="/assets/js/docs.min.js"></script>
    <script>
      var MathJax = {
        tex: {
          inlineMath: [
            [ '$$', '$$' ],
            [ '\[', '\])' ]
          ]
        },
        "HTML-CSS": {
          styles: {
            ".MathJax span": {
              color: "#000000"
            }
          }
        }
      }
    </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
    </script>
    <script>
      handleExternalLinks();

      function handleExternalLinks() {
        const domain = getDomain();
        const links = document.querySelectorAll( 'a' );
        return links.forEach( ( link ) => {
          if ( !link.host.includes( domain ) ) link.target = '_blank';
        } )
      };
    </script>
  </div>
</body>

</html>
