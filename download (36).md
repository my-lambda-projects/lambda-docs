<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Testing React

<span class="lead"> </span>

In this module we introduce common techniques used for testing React components.

**At the end of this module, you should be able to:**

- test React components as the props change
- use mocks in web application tests
- test asynchronous API calls that are made in a component

#### Pro Tip

Know your audience.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [Jest Documentation on Testing Asynchronous Code](https://jestjs.io/docs/en/asynchronous)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to test React components as the props change

##### Overview

Today we’re going to continue working with React Testing Library to test rendered DOM elements. In this objective, we will focus on testing data being passed as props, and testing props changes that may happen in a component.

In some cases, when props are updated, you’ll want to run a secondary test on the same component. With our previous knowledge of react testing library, this would have been fairly difficult, but thankfully there is a built in method called `rerender()` that allows us to pretty easily look at a component with new props.

In order to do this we need to add the `rerender` function when setting up our test for use in testing the component **after** the prop has been updated.

Let’s look at an example where we have some component called `PhoneNumber` that the user will update with their phone number. We want to show an error message when the component is empty but pass the test after the user puts in a number between 0 and 10.

    // name test
    test("entering an invalid value shows an error message", () => {
      // pull in testing properties - add rerender and debug
      const { getByLabelText, getByRole, rerender } = render(
        <PhoneNumber />
      );
      const input = getByLabelText(/favorite number/i);
      // update prop
      fireEvent.change(input, { target: { value: "2025550113" } });
      // test component
      expect(getByRole("alert")).toHaveTextContent(/the number is invalid/i);
      // test prop updates
      rerender(<PhoneNumber phoneNumber={"2025550113"} />);
    });

How does this work in practice? In the example above we are interested in a component called `PhoneNumber`. Since the first test is testing the component before the prop updates, the test will fail and show an error message. Once the user inputs their number however, the second test (the rendering) should pass. If you were to run this code in your console that’s exactly what you’d see.

### Assert Content is not Rendered

In some cases, we want to make sure that content is _not_ rendering on the DOM. For example, if a component should show up on click or, really any time after pageload. React testing library isn’t exactly built for this as all `getBy` assertions return an error if they can’t find the thing they’re searching for (if a return is `null`). Luckily there is a workaround here - the assertion called `queryByRoll` (or any `queryBy` assertion), will return `null` instead of an error. This let’s us query for something this _isn’t_ supposed to be on the DOM. It also allows us to use an assertion like `.toBeNull()` or `toBeFalsy()`, and then tests will start passing even when no content is rendered.

    test("entering an invalid value shows an error message", () => {
      // pull in testing properties - add rerender
      // render the component without a prop
      const { getByLabelText, getByRole, queryByRole, rerender } = render(
        <PhoneNumber />
      );
      const input = getByLabelText(/favorite number/i);
      // test component
      expect(getByRole("alert")).toHaveTextContent(/the number is invalid/i);
      // test prop updates by rerendering component with different props
      rerender(<PhoneNumber phoneNumber={"2025550113"} />);
      // assert that the error message is NOT being rendered (optional)
      expect(queryByRoll("alert")).toBeNull();
    });

##### Follow Along

In this section we will continue building tests for dog images app from the previous objective. In this example there is a parent component that is in charge of fetching the data from dog.ceo, and a child component that receives that data as a prop and displays the dog images on the page. For this example, we will render the dog images into a new component after the initial rendering of the page. We need to test if the dog images appear on rerender.

This means we want to test the child component. We will test that it renders a “getting data” message when it is passed an empty array as a prop. Then we will re-render the component and pass down our actual data, to simulate the parent component receiving data from the API and passing that data down to this child component.

_Note that this means we don’t have to test the async function, or even the event that kicked off the API call. We just render what this component looks like when it first mounts with no data, and what it looks like when it receives new props and re-renders._

1.  Create test and pull in relevant matchers from react testing library.

    //import libraries
    import React from "react";
    import { render } from "@testing-library/react";
    import DoggoImages from "./DoggoImages";

    test("renders dog images from API", () => {
    // Render the component with an empty array
    const { getAllByTestId, rerender } = render(<Doggos images={[]} />);

    // Assert that there are no dog images rendered yet
    expect(getAllByTestId(/doggo images/i)).toHaveLength(0);
    });

1.  Update prop by passing a user input. Test updated prop using `rerender`.

    //import libraries
    import React from "react";
    import { render } from "@testing-library/react";
    import DoggoImages from "./DoggoImages";

    test("renders dog images from API", () => {
    const doggoUrls = [
    'url-one.jpg', 'url-two.jpeg', 'url-three.jpg'
    ]
    const { getAllByTestId, rerender } = render(<DoggoImages images={[]} />);

    expect(getAllByTestId(/doggo images/i)).toHaveLength(0);

    // We will rerender the component with our dummy data passed in as the new props
    rerender(<DoggoImages images={doggoUrls} />);

    // Assert that we now have dog images rendering!
    expect(getAllByTestId(/doggo images/i)).toHaveLength(3);
    });

##### Challenge

Find an example of updating props in a previous project. Design a test using `rerender` that will assert one state after the component first renders, and assert a different state after he component renders again with new props.

---

#### Learn to use mocks in web application tests

Unfortunately our functions don’t live in a vacuum, but have entanglements with the outer world, such as dependencies on other modules. Or they might take callbacks as arguments, which creates the interesting problem of how to test that the callbacks were invoked and the correct arguments passed. To handle both these problems we can use Jest’s mock functions.

##### Overview

A function in testing may have inconvenient dependencies on other objects. To isolate the behavior of the function, it’s often desirable to replace the other objects with mocks that simulate the behavior of the real objects. Replacing objects is especially useful if the real objects are impractical to incorporate into the unit test.

Another use of mocks is as “spies” because they let us spy on the behavior of a function that is called by some other code. Mock functions can keep track of calls to the function, as well as the parameters passed in those calls. We can even define an implementation for the mock, but that’s optional. Simpler mocks that implement only enough behavior to execute test code are sometimes called “stubs”.

##### Follow Along

Let’s implement a helper function with an uncomfortable dependency that makes the helper _impure_ (reliant on something outside of its scope) and, therefore, harder to test **(you’ll need to install the `uuid` npm module)**.

       import uuid from "uuid";

       export const makeUser = (firstName, lastName) => {
         return {
           id: uuid(),
           fullName: `${firstName} ${lastName}`
         };
       };

1.  Testing expected output against actual output would be hard, because `uuid()` generates a new, random id each time. We can give it a try, though. Note the use of `.toEqual()` to make our assertion. It compares nested properties of objects, which we need to check here.

        import { makeUser } from "../utils/makeUser";

        test("generates a user with an id and a full name", () => {
          // Arrange
          const expected = { id: "abcde", fullName: "Peter Parker" }; // fishy...

          // Act
          const actual = makeUser("Peter", "Parker");

          // Assert
          expect(actual).toEqual(expected);
        });

    ![alt text](https://tk-assets.lambdaschool.com/6db480a0-84b6-4210-91a2-091475a1c731_ScreenShot2019-04-16at19.33.30.png)

_By the way, this kind of test is called a **unit test** - a test for a single unit of code, like an isolated function like `makeUser`. You’ll learn more about unit testing in the backend unit, but we can see what happening here with the AAA framework._

1.  To get around this problem, we can stub out (create) a fake version of `uuid` that will replace the real one during the execution of the test. Outside of the `test` block, at the top level of the test file, place the following code:

        jest.mock("uuid", () => () => "abcde");

Let’s break it down. As the first argument to `jest.mock()`, we pass the path to the module we want to replace. As the second argument, we pass a callback that _returns_ whatever it is _we want the faked thing to be_. We wish for `uuid` to become a silly stub function that always returns the same string: `uuid() // "abcde"`. Our tests should be passing now!

##### Challenge

There is a way to centralize mocks that are used often (think `uuid`, or `axios`) in external files, so that they are used in test suites without even bothering with imports. Go to the Jest docs and see if you can find out how!

---

#### Learn to test asynchronous API calls that are made in a component

Most real world applications need to deal with asynchronous operations. Adding tests to asynchronous code is challenging as we need to make sure the code has finished executing and the application is stable before running the assertions.

##### Overview

An asynchronous test is a special kind of test that does not complete right away, as it needs to wait for the results of one or more asynchronous operations. When writing asynchronous code, like when dealing with APIs, it’s important to write asynchronous tests because other tests won’t work as you expect.

React testing library has a couple of helper functions for us to write these tests. The `wait` function from react testing library lets us tell the test that we need to wait for the async call to finish before continuing our assertions.

As mentioned before, we will also use the `jest.mock` function to make mocks of the asynchronous functions so we won’t have to wait for the actual call to be made.

In the following tutorial, we’ll walk through an example using API data. Just like we did with non asynchronous tests, we need to import components, render components, simulate an event, and run the test - the difference here is simply a few added functions to make calls asynchronous.

##### Follow Along

Let’s say we have a component that fetches data from the dog.ceo API when the user pushes a “Fetch Doggos” button. The component uses a function called `fetchDoggos` to make the API call. We have pulled this function out of the component and into an `/api` directory in our file structure to make it easier to test. We would write a test for this component following these steps:

**Imports**

As usual, we need to **import the required libraries** for testing. In addition to our normal libraries, we’ll import `wait` to make our function run asynchronously, and we’ll import our component `fetchDoggos` as `mockFetchDoggos` so that we don’t have to wait for the actual call to be made.

- Import the regular `react` and `@testing-library/react` dependencies
- Also import `wait` from rtl
- Import `fetchDoggos` from the `/api` directory, and rename it to `mockFetchDoggos` so we know that it will be mocked - remember that a mock allows us to isolate a function from its dependencies.

  // import libraries

  import React from "react";
  import { render, fireEvent, waitFor } from "@testing-library/react";
  import { fetchDoggos as mockFetchDoggos } from "../api/fetchDoggos";
  import Doggos from "./Doggos";

  // set up test
  test("renders dog images from API", async () => {});

**Mocking the Async Function**

Next we need to **set up the mock**. Like before, we will create the mock outside of the `test` block to mock the fetchDoggos async function. Then, inside the `test` block we will tell the mock function with what data it should resolve. When the component makes the async request using our mocked function, it will resolve quickly with that data.

    // import libraries
    import React from "react";
    import { render, fireEvent, waitFor } from "@testing-library/react";
    import { fetchDoggos as mockFetchDoggos } from "../api/fetchDoggos";
    import Doggos from "./Doggos";

    //create mock *before* setting up test
    jest.mock("../ap/fetchDoggosi");

    // set up test
    test("renders dog images from API", () => {
      //mock resolved results
      mockFetchDoggos.mockResolvedValueOnce({
        message: [
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1023.jpg"
        ]
      });
    });

**Render, Query, and Fire Events**

Render the component, query for the necessary elements, and fire the onClick event with `fireEvent`. This step should look familiar from our first lessons on react testing library as we haven’t added any of the async functionality yet (other than importing `wait`).

    //import libraries
    import React from "react";
    import { render, fireEvent, waitFor } from "@testing-library/react";
    import { fetchDoggos as mockFetchDoggos } from "../api/fetchDoggos";
    import Doggos from "./Doggos";

    //set up test
    jest.mock("../api/fetchDoggos");

    test("renders dog images from API", () => {
      mockFetchDoggos.mockResolvedValueOnce({
        message: [
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1023.jpg"
        ]
      });

      const { getByText } = render(<Doggos />);

      const fetchDoggosButton = getByText(/fetch doggos/i);
      fireEvent.click(fetchDoggosButton);
    });

**Async/Await**

At this point, the async call has been made. We need to tell our test that it is going to handle an async function by adding `async` right after the test name string, and before the callback function. This is using JavaScript’s `async/await` syntax! Basically this will tell the function that it’s going to do an async operation.

    // add async function
    test("renders dog images from API", async () => {
      //mock resolved results
      mockFetchDoggos.mockResolvedValueOnce({
        message: [
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1023.jpg"
        ]
      });

      const { getByText } = render(<Doggos />);

      const fetchDoggosButton = getByText(/fetch doggos/i);
      fireEvent.click(fetchDoggosButton);
    });

**Await and the Wait Function**

Tell the function which async operation it needs to wait for. There are two related parts we need to set up here, then we’ll be able to make our assertion.

- Use the `await` keyword to tell the function we’re awaiting for the async operation to finish
- Use the `wait` function from RTL to wait for RTL to update the DOM so we can query for the dog images
- Write an assertion in the `wait` functions callback function. Note that wait is usually required but certain assertions can work without it, you’ll need to do research on a case by case basis to determine wither or not wait is required.

  test("renders dog images from API", async () => {
  mockFetchDoggos.mockResolvedValueOnce({
  message: [
  "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
  "https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg",
  "https://images.dog.ceo/breeds/hound-afghan/n02088094_1023.jpg"
  ]
  });

  const { getByText, getAllByTestId } = render(<Doggos />);

  const fetchDoggosButton = getByText(/fetch doggos/i);
  fireEvent.click(fetchDoggosButton);
  // add await
  await waitFor(() => expect(getAllByTestId(/doggo-images/i)).toHaveLength(3));
  });

**One Last Assertion**

Finally, we will make sure that the correct function was called by adding an extra assertion, `expect(mockFetchDoggos).toHaveBeenCalledTimes(1);`.

    test("renders dog images from API", async () => {
      mockFetchDoggos.mockResolvedValueOnce({
        message: [
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg",
          "https://images.dog.ceo/breeds/hound-afghan/n02088094_1023.jpg"
        ]
      });

      const { getByText, getAllByTestId } = render(<Doggos />);

      const fetchDoggosButton = getByText(/fetch doggos/i);
      fireEvent.click(fetchDoggosButton);

      // add new assertion
      expect(mockFetchDoggos).toHaveBeenCalledTimes(1);

      await waitFor(() => expect(getAllByTestId(/doggo-images/i)).toHaveLength(3));
    });

##### Challenge

Research on your own how to test async code using `jest-axe` and `toHaveNoViolations` for accessibility.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [React Testing - TV Show](https://github.com/LambdaSchool/React-Testing-TV-Show)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Testing React for Web35 w/Warren Longmire](https://youtu.be/_sPYk32r_r8)**

  Testing React

- [All previous recordings](/archive/WEB3/module/recS9H6qCj0dQe32B)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Find an example of updating props in a previous project. Design a test using `rerender` that will assert one state after the component first renders, and assert a different state after he component renders again with new props.

- Objective challenge:

  There is a way to centralize mocks that are used often (think `uuid`, or `axios`) in external files, so that they are used in test suites without even bothering with imports. Go to the Jest docs and see if you can find out how!

- Objective challenge:

  Research on your own how to test async code using `jest-axe` and `toHaveNoViolations` for accessibility.

- Project: React Testing - TV Show
