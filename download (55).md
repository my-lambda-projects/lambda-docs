

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

-   [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
-   [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

-   [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
-   [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
-   [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
-   [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

-   [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
-   [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
-   [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
-   [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

-   [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
-   [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
-   [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
-   [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

-   [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
-   [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

-   [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
-   [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
-   [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
-   [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

-   [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
-   [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
-   [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
-   [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

-   [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
-   [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
-   [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
-   [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Java Interfaces, Abstract Classes, Lambda Expression

<span class="lead"> </span>

<span id="Interfaces_Abstract_Classes_Lambda_Expressions"></span>

**At the end of this module, you should be able to:**

-   craft and manipulate Collections
-   craft and manipulate ArrayList Collections
-   use and implement interfaces
-   use and implement abstract classes
-   use and implement Lambda Expressions
-   craft and manipulate Arrays Collections (\*\*\* OPTIONAL \*\*\*)
-   craft and manipulate HashMap Collections (\*\*\* OPTIONAL \*\*\*)
-   craft and manipulate HashSet Collections (\*\*\* OPTIONAL \*\*\*)

#### Pro Tip

A quick temper will make a fool of you soon enough.

Bruce Lee

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to craft and manipulate Collections

<span id="Collections_Overview"></span>

##### Overview

A collection is a way of storing a series of related data under one variable name. You “collect” the data under a single variable to make data manipulation easier. Thus you have a “collection” of data under one name.

Which collection you use depends on what you are trying to accomplish. We will be studying 4 different collections:

-   Array
-   ArrayList (the one we will use the most in Java Web Programming)
-   HashMap
-   HashSet

Below is a brief chart comparing the collections we will be studying in class. These collections are the most common in Java Web Programming.

<table><thead><tr class="header"><th>Collection</th><th>Length</th><th>element types</th><th>unique values enforced</th><th>accessed via</th><th>maintains order (sortable)</th></tr></thead><tbody><tr class="odd"><td>Array</td><td>fixed</td><td>single</td><td>no</td><td>index</td><td>yes</td></tr><tr class="even"><td>ArrayList</td><td>variable</td><td>single</td><td>no</td><td>index</td><td>yes</td></tr><tr class="odd"><td>HashMap</td><td>variable</td><td>&lt; key, value &gt; pair</td><td>no</td><td>key value</td><td>no</td></tr><tr class="even"><td>HashSet</td><td>variable</td><td>single</td><td>yes</td><td>value itself</td><td>no</td></tr></tbody></table>

For each collection we will look at:

-   How to declare and initialize the collection
-   Accessing a specific value
-   Adding an element, value
-   Removing an element, value
-   Displaying the values for the collection
-   Sorting the collection if possible
-   Clearing the collection

##### Dig Deeper

-   [Java Collections](https://youtu.be/VvDTro4Shzg)  
    Youtube - Understanding Java Collections
-   [Collections.sort()](https://www.geeksforgeeks.org/collections-sort-java-examples/)  
    GeeksForGeeks Collections.sort() in Java

------------------------------------------------------------------------

#### Learn to craft and manipulate ArrayList Collections

<span id="ArrayList"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

### ArrayLists

Arrays in Java are great except for one issue: they are fixed size. When dealing with data from the web, we don’t know how many elements we are dealing with. We certainly don’t want to reserve 1,000,000 elements for an array that might only use 10. Likewise, we have to make sure we have enough elements in our array to save what we need. ArrayLists to the rescue! ArrayLists are the most common collection we will be using in Java Web Programming. You can create an ArrayList with no elements and let it grow up to whatever the computer can handle.

ArrayLists have the same characteristics as an Array:

-   Fixed data types - Usually we deal with ArrayList of some type of Class. They can also contain primitive types.
-   Order maintained - We can sort and filter ArrayList in a straightforward fashion.

ArrayLists do differ from Arrays in that they can grow and shrink in size. There is performance and memory overhead in dealing with this freedom compared to using arrays of fixed size. The larger the ArrayList, the less impact this overhead has on overall performance. Also, ArrayList collections are not as straightforward to manipulate as Arrays.

ArrayLists are derived from Lists in Java. Often you will see in Java programs a variable being declared as the general type List followed by being initialized with an ArrayList. This is a common practice when using the Spring Framework.

Now let’s see these ArrayList collections in action!

##### Follow Along

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `arraylist`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/arraylist

Now in the `arraylist` directory, use your text editor to create the following code in a file called `Main.java`. Note you do not have to enter the comments! The code is broken into 3 parts.

### Part 1

    package arraylist;

    import java.util.ArrayList;   // the ArrayList requires this import
    import java.util.Collections; // required import for sorting the ArrayList
    import java.util.Comparator;  // required import for sorting the ArrayList in descending order
    import java.util.List;        // the List requires this import

    public class Main
    {
        public static void main(String[] args)
        {
            // Declare a list called cities which takes as its elements Strings
            // and initialize it as an ArrayList with String
            // The String data type for the initialization, the one on the right of the equals sign
            // can be inferred from the String for the declaration, the one on the left.
            // So instead of saying
            // List<String> cities = new ArrayList<String>();
            // we can say
            List<String> cities = new ArrayList<>();

            // add a new String to the ArrayList. ArrayList maintains order,
            // so Lehi is at index 0, Seattle at index 1, San Francisco at index 2, and so on
            cities.add("Lehi");
            cities.add("Seattle");
            cities.add("San Francisco");
            cities.add("Austin");
            cities.add("Denver");
            cities.add("Raleigh");
            cities.add("New York City");

            // adding a value that already exists in the ArrayList is just like adding any other value
            // it goes at the end of the ArrayList
            cities.add("Austin");

            // Displaying the ArrayList. Note that putting the \n at the start of our string to display
            // says to first display a blank line and then display our text. So the following is the same as
            // System.out.println();
            // System.out.println("*** The ArrayList ***")
            System.out.println("\n*** The ArrayList ***");
            System.out.println(cities);

            // To find a particular element in the ArrayList, Use get(index)
            // where index is the index of the element you want.
            // Remember ArrayList are 0 based index, so an ArrayList with 5 elements will have indexes
            // 0, 1, 2, 3, 4
            System.out.println("The element at index 0 is " + cities.get(0));

            // Searching for an index that does not exist in the ArrayList, causes the program to halt
            // with an exception IndexOutOfBounds
            // System.out.println("The element at index 100 is " + cities.get(100));

            // To find if an ArrayList contains a particular value, use contains
            System.out.println();
            System.out.println("The ArrayList contains \"New York City\": " + cities.contains("New York City"));
            System.out.println("The ArrayList contains \"Portland\": " + cities.contains("Portland"));

            // ArrayList have a couple of other usual ways of adding a element
            // set(index, new value) replaces the element at the given index
            // note the \ before the " telling us to display the " not treat them as ending of a string. Treat them as part of the String!
            // This is called escaping the character or just escape character
            System.out.println("\nReplacing element at index 3");
            System.out.println("Original element at index 3: " + cities.get(3));
            cities.set(3, "Portland");
            System.out.println("Replaced element \"Portland\" at index 3: " + cities.get(3));

            // add (index, new value) adds the new element at the given index, pushing all the other elements one index higher
            System.out.println("\nBefore adding element at index 3");
            System.out.println(cities);
            cities.add(3, "Austin");
            System.out.println("After adding \"Austin\" element at index 3");
            System.out.println(cities);

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac arraylist/*.java
    jar cvfe arraylist.jar arraylist.Main arraylist/*.class
    java -jar arraylist.jar

Fix any errors you might encounter and try again.

So we get the following output:

    *** The ArrayList ***
    [Lehi, Seattle, San Francisco, Austin, Denver, Raleigh, New York City, Austin]
    The element at index 0 is Lehi

    The ArrayList contains "New York City": true
    The ArrayList contains "Portland": false

    Replacing element at index 3
    Original element at index 3: Austin
    Replaced element "Portland" at index 3: Portland

    Before adding element at index 3
    [Lehi, Seattle, San Francisco, Portland, Denver, Raleigh, New York City, Austin]
    After adding "Austin" element at index 3
    [Lehi, Seattle, San Francisco, Austin, Portland, Denver, Raleigh, New York City, Austin]

The following shows the execution of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-16.gif)

### Part 2

Add this to the bottom of your Main class:

            // use remove(index) to remove an element. All elements after the one removed are moved one index lower
            cities.remove(3);
            System.out.println("\nRemoved index 3 so the first \"Austin\"");
            // We are looping through the elements in the ArrayList
            // using a For Each loop
            for (String c : cities)
            {
                System.out.println(c);
            }

            // Since ArrayList do not have a fixed size, we must calculate its size using the method size();
            System.out.println("\nSize of the ArrayList is " + cities.size());

            // printing the ArrayList using a standard For Loop
            for (int i = 0; i < cities.size(); i++)
            {
                System.out.println("Index: " + i + " Value: " + cities.get(i));
            }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac arraylist/*.java
    jar cvfe arraylist.jar arraylist.Main arraylist/*.class
    java -jar arraylist.jar

Fix any errors you might encounter and try again.

So we get the following output minus the parts from previous sections:

    Removed index 3 so the first "Austin"
    Lehi
    Seattle
    San Francisco
    Portland
    Denver
    Raleigh
    New York City
    Austin

    Size of the ArrayList is 8
    Index: 0 Value: Lehi
    Index: 1 Value: Seattle
    Index: 2 Value: San Francisco
    Index: 3 Value: Portland
    Index: 4 Value: Denver
    Index: 5 Value: Raleigh
    Index: 6 Value: New York City
    Index: 7 Value: Austin

The following shows the execution of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-17.gif)

### Part 3

Add this to the bottom of your Main class:

            System.out.println("\nSort in Alphabetical Order");
            // Use the Collections.sort(ArrayList) method to sort the ArrayList in ascending order. This actually changes the order of the ArrayList.
            Collections.sort(cities);
            for (int i = 0; i < cities.size(); i++)
            {
                System.out.println("Index: " + i + " Value: " + cities.get(i));
            }

            System.out.println("\nSort in Reverse Alphabetical Order");
            // To sort in descending order, Use the Collections.sort(ArrayList,  Comparator.reverseOrder()) method
            // This actually changes the order of the ArrayList.
            Collections.sort(cities, Comparator.reverseOrder());
            for (int i = 0; i < cities.size(); i++)
            {
                System.out.println("Index: " + i + " Value: " + cities.get(i));
            }

            // To clear the ArrayList use clear()
            // Java would automatically free up the memory allotted to the ArrayList when the ArrayList goes out of scope,
            // so at the end of this method.
            System.out.println("\nThe empty ArrayList");
            cities.clear();
            System.out.println(cities);
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac arraylist/*.java
    jar cvfe arraylist.jar arraylist.Main arraylist/*.class
    java -jar arraylist.jar

Fix any errors you might encounter and try again.

So we get the following output minus the parts from previous sections:

    Sort in Alphabetical Order
    Index: 0 Value: Austin
    Index: 1 Value: Denver
    Index: 2 Value: Lehi
    Index: 3 Value: New York City
    Index: 4 Value: Portland
    Index: 5 Value: Raleigh
    Index: 6 Value: San Francisco
    Index: 7 Value: Seattle

    Sort in Reverse Alphabetical Order
    Index: 0 Value: Seattle
    Index: 1 Value: San Francisco
    Index: 2 Value: Raleigh
    Index: 3 Value: Portland
    Index: 4 Value: New York City
    Index: 5 Value: Lehi
    Index: 6 Value: Denver
    Index: 7 Value: Austin

    The empty ArrayList
    []

The following shows the execution of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-18.gif)

##### Dig Deeper

-   [ArrayList](https://beginnersbook.com/2013/12/java-arraylist/)  
    Beginners Book ArrayList

------------------------------------------------------------------------

#### Learn to use and implement interfaces

<span id="Interfaces"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

**Interfaces** defines a formal way for objects to handle interaction with the rest of the application. Interfaces are a way for the programmer to define what behaviors, methods, an object should have. Any class that **implements** an interface must include an implementation for each method in the interface. Interfaces thus give us a standard list of method headers that MUST be implemented in classes that use the interface. Classes that use the interface can include additional methods but must include the ones from the interface.

For example: We have an interface called **vehicles** where all vehicles move and use fuel.

All classes will use this interface. So all vehicles must move and use fuel but how they move and use fuel varies by vehicle. They can do other things as well!

-   Car is a vehicle
    -   *all vehicles move:* Moves on land with wheels
    -   *use fuel:* Uses gasoline
    -   Says “honk”
-   Airplane is a vehicle
    -   *all vehicles move:* Moves through air on wings
    -   *use fuel:* Uses Jet Fuel
-   Sailboat is a vehicle
    -   *all vehicles move:* Moves through water on a hull
    -   *use fuel:* Uses Wind

For a Java example, let’s say we have the following interface:

    public interface SampleInterface
    {
        void amethod(String parameter);
        int operation(int a, int b);
    }

This is a Java interface:

-   an Interface is a class so its name must start with a capital letter
-   an Interface is a class so its file name must match the interface name
-   the key word **interface** is used in place of **class** to say this class is special. It is an interface
-   interfaces can implement other interfaces and can extend an abstract class.

The interface defines 2 methods:

-   the methods are defined simply with their method header
    -   Thus methods in the interface are considered **abstract** meaning they have no implementation, just the header
    -   The class that implements the interface must provide the body for the method
-   Normally we do not give an access modifier for a method header in an interface
    -   methods default to public

Let’s implement the above interface. Let’s create a class that implements the interface thus giving a body to the method headers from the interface.

    public class ASampleClass implements SampleInterface
    {
        String aStringField;
        int anIntField;

        public ASampleClass(String aStringField, int anIntField)
        {
            this.aStringField = aStringField;
            this.anIntField = anIntField;
        }

        @Override public void amethod(String parameter)
        {
            System.out.println(parameter.toLowerCase());
        }

        @Override public int operation(int a, int b)
        {
            return a + b;
        }

        public void lookAtMe()
        {
            System.out.println("I am a method");
        }
    }

We have a class with two fields that implements both of the methods from the interface. The class also adds its own method.

Now let’s implement another class that implements the interface but in a completely new way:

    public class AnotherClass implements SampleInterface
    {
        @Override public void amethod(String parameter)
        {
            System.out.println(parameter.toLowerCase());
        }

        @Override public int operation(int a, int b)
        {
            return a / b;
        }
    }

Both of the above classes are valid and can be used in the same application!

Note that interfaces:

-   Cannot be used to create objects directly. Other classes must implement them
-   Do not have the body implement methods just give structure
-   Classes implementing interfaces must implement ALL interface methods. Classes can add their own methods as well
-   Interface methods by default are abstract and public
-   The main purpose of interfaces is to provide uniformity of behaviors among a group of classes. These classes all can do the same thing!

##### Follow Along

Let’s create an application that uses interfaces!

If you have not already, create an application called `sampleoop` in your work folder. We are going to create a package called `interfaces`. So you will end up with the directory

    <home dir><work dir>/sampleoop/src/branching

Now in the the `interfaces` directory, use your text editor to create the following code in a file called `Animal.java`

    package interfaces;

    public interface Animal
    {
        void animalSound();
        void sleep();
    }

Create a file called `Pig.java` with the following code:

    package interfaces;

    class Pig implements Animal
    {
        @Override public void animalSound()
        {
            System.out.println("Oink Oink");
        }

        @Override public void sleep()
        {
            System.out.println("ZZZ");
        }
    }

Create a file called `Dog.java` with the following code:

    package interfaces;

    public class Dog implements Animal
    {
        @Override public void animalSound()
        {
            System.out.println("Woof");
        }

        @Override public void sleep()
        {
            System.out.println("Snore...");
        }

        public void eat()
        {
            System.out.println("chomp chomp chomp");
        }
    }

And finally create your `Main.java` file, your main class, with the following code:

    package interfaces;

    public class Main
    {
        public static void main(String[] args)
        {
            Pig myPig = new Pig(); // instantiate a pig object
            Dog myDog = new Dog(); // instantiate a dog object

            myPig.animalSound();
            myPig.sleep();
            // myPig.eat() pig does not know how to eat. Poor pig

            myDog.animalSound();
            myDog.sleep();
            myDog.eat();
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac interfaces/*.java
    jar cvfe interfaces.jar interfaces.Main interfaces/*.class
    java -jar interfaces.jar

Fix any errors you might encounter and try again.

So we get the following output:

    Oink Oink
    ZZZ
    Woof
    Snore...
    chomp chomp chomp

##### Dig Deeper

-   [Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)  
    The Java Tutorials: Interfaces

------------------------------------------------------------------------

#### Learn to use and implement abstract classes

<span id="Abstract_Classes"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

If we have a group of classes that share similar methods and / or fields, using **abstract** classes would make sense. The idea is that our group of classes could inherit from our abstract class, our parent class, all those standard methods or fields. That way, the group of classes could worry about just implementing what is different in each class.

Abstraction is the process of hiding certain details and showing only the essential information to the sub class.

**abstract** is a keyword used for classes and methods:

-   Abstract classes cannot be used to create objects. Abstract classes are used to create uniform subclasses.
    -   These subclass `extends` the abstract class thus inheriting all the fields and methods from the abstract class and still being able to create their own.
    -   A subclass can only `extends` a single abstract class.
-   Abstract methods do not have a body, only a method header.

So why should we use abstract classes?

-   They enforce a common method and field implementation across subclasses.
-   Subclasses can be combined into a single list, like an ArrayList under the parent, abstract class, data type!
-   The abstract classes forces subclasses to have certain fields and implements of methods. Abstract classes do NOT require abstract methods.

Let’s look at a Java example:

    abstract class AnAbstractClass
    {
        protected int anInt = 7;

        public void amethod(String parameter)
        {
            System.out.println("I am a method from " + parameter);
        }
        abstract int operation(int a, int b);
    }

The above is a Java abstract class. Notice that it contains:

-   A field `anInt` that will be known to all subclasses
-   A method `amethod` already defined that can be used directly by all subclasses
-   An abstract method `operation` that subclasses MUST implement

<!-- -->

    public class ASampleClass extends AnAbstractClass
    {
        @Override int operation(int a, int b)
        {
            return a + b + anInt;
        }
    }

Now we have the class `ASampleClass` extending the abstract class including finishing the declaration of the method `operation`. Inside the method `operation`, `ASampleClass` uses the field `anInt` inherited from `AnAbstractClass`!

### Overview Abstract Class vs Interfaces

-   Classes can inherit from multiple interfaces but only a single abstract class
-   Abstract classes can contain fields; interfaces should not
-   Abstract classes can implement methods that get shared across classes; interfaces give method headers but not actual implementations.
-   Java with the Spring Framework uses interfaces much more than abstract classes!

##### Follow Along

Let’s create an application that uses an abstract class!

If you have not already, create an application called `sampleoop` in your work folder. We are going to create a package called `abstraction`. So you will end up with the directory:

    <home dir><work dir>/sampleoop/src/abstraction

Now in the `abstraction` directory, use your text editor to create the following code in a file called `Animal.java`.

    package abstraction;

    abstract class Animal
    {
        int weight = 50;

        abstract void animalSound();

        void sleep()
        {
            System.out.println("ZZZ");
        };

        int getWeight()
        {
            return weight;
        }
    }

Create a file called `Pig.java` with the following code:

    package abstraction;

    public class Pig extends Animal
    {
        // Pig must give the implementation for animalSound
        // the rest of the methods can be used directly
        @Override void animalSound()
        {
            System.out.println("Oink Oink");
        }
    }

And finally create your `Main.java` file, your main class, with the following code:

    package abstraction;

    public class Main
    {
        public static void main(String[] args)
        {
            Pig myPig = new Pig(); // create a pig object
            myPig.animalSound();   // use the animalSound method from the abstract class defined in Pig
            myPig.sleep(); // use the sleep method from the abstract class
            System.out.println("Weight " + myPig.getWeight()); // use the getWeight method from the abstract class!
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac abstraction/*.java
    jar cvfe abstraction.jar abstraction.Main abstraction/*.class
    java -jar abstraction.jar

Fix any errors you might encounter and try again.

So we get the following output:

    Oink Oink
    ZZZ
    Weight 50

##### Dig Deeper

-   [Abstract Class](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)  
    The Java Tutorials: Abstract Methods and Classes

------------------------------------------------------------------------

#### Learn to use and implement Lambda Expressions

<span id="Lambda_Expressions"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

**Lambda Expressions** are anonymous functions similar to arrow functions in JavaScript, although not as robust or as widely used. Lambda Expressions are functions:

-   without a name
-   do not belong to any class
-   may or may not have parameters
-   have no stated return type
-   with syntax of `(parameter list) -> {body; function; statements;}`

### Using a Lambda Expression with 1 parameter: Iterating through a collection

A very common use of Lambda Expressions is to iterate through a collection. So for example if `list` was ArrayList, this lambda expression would display each element of the ArrayList in order. `name` is our parameter in the lambda expression.

    list.forEach (name -> System.out.println (name));

### Using a Lambda Expression with no parameters

No parameters for the lambda expression is shown through the use of `()` to take the place of parameters.

    public interface MyInterface
    {
        int operation ();
    }

    public class Main
    {
        public static void main(String[] args)
        {
            MyInterface myAnswer = () -> 2 * 2;
            System.out.println("Answer: " + myAnswer.operation());
        }
    }

### Using a Lambda Expression with multiple parameters

Note the two parameters in `()`

    public interface MyInterface
    {
        String operation (int num, String msg);
    }

    public class Main
    {
        public static void main(String[] args)
        {
            MyInterface myAnswer = (n, x) -> x + (n * n);
            System.out.println("Answer: " + myAnswer.operation(2, "My Answer "));
        }
    }

### Used when you have a single interface method or abstract method

As shown in the previous two examples, often we use lambda expressions to implement abstract methods. Let’s work through an example together that does just that.

##### Follow Along

By combining an interface and lambda expressions we can easily filter an ArrayList. We will be creating a copy of the ArrayList that contains the items we want. Then we use a lambda expression to print the filtered list!

If you have not already, create an application called `sampleoop` in your work folder. We are going to create a package called `lambdaexpress`. So you will end up with the directory

    <home dir><work dir>/sampleoop/src/lambdaexpress

Create an interface that has one method. It’s one method will take as a parameter an object of the data type we wish to check. The method will be implemented using a lambda expression. Create the file `CheckNumber.java` with the following code

    package lambdaexpress;

    public interface CheckNumber
    {
        boolean test(int testNum);
    }

Now let’s create the `Main.java` file

    package lambdaexpress;

    import java.util.ArrayList;
    import java.util.List;

    public class Main
    {
        public static List<Integer> filterOdds(List<Integer> myList, CheckNumber tester)
        {
            // when we call this, myList becomes numbers from the main method
            // tester becomes the lambda expression num -> ((num % 2) == 0
            // where num is some element in the ArrayList
            List<Integer> filteredList = new ArrayList<>();

            for (Integer n : myList)
            {
                // if the lambda expression returns true, add that element to the new ArrayList
                if (tester.test(n))
                {
                    filteredList.add(n);
                }
            }
            return filteredList;
        }

        public static void main(String[] args)
        {
            List<Integer> numbers = new ArrayList();

            // populate an ArrayList with numbers 0 - 6
            for (int i = 0; i < 7; i++)
            {
                numbers.add(i);
            }

            // Create a new ArrayList from the output of the function filterOdds with parameters
            // our populated ArrayList
            // lambda expression that looks to see if the ArrayList element is divisible by 2
            List<Integer> toPrintList = filterOdds(numbers, num -> ((num % 2) == 0));
            toPrintList.forEach(n -> System.out.println(n));
        }
    }

Our main method:

-   Creates a list of integers 0 through 6.
-   Then we call a function with two parameters: one, the list we just created, the other a lambda expression that will implement the method from the interface we just created.
-   The function loops through the ArrayList. If the lambda expression evaluates to true, that element is added to a temporary list.
-   The temporary list is then returned to the main method.
-   Now the main method displays the returned list using a lambda expression!

To run our code, we go through the following steps, running these commands from the `src` directory.

    javac lambdaexpress/*.java
    jar cvfe lambdaexpress.jar lambdaexpress.Main lambdaexpress/*.class
    java -jar lambdaexpress.jar

Fix any errors you might encounter and try again.

So we get the following output:

    0
    2
    4
    6

##### Dig Deeper

-   [Lambda Expressions](https://www.callicoder.com/java-lambda-expression-tutorial/)  
    Callicoder Introduction to Lambda Expressions
-   [Lambda Expressions](http://tutorials.jenkov.com/java/lambda-expressions.html)  
    Jenkov Lambda Expressions
-   [Lambda Basics](https://javabrains.io/courses/java_lambdabasics/)  
    Javabrains - Java 8 Lambda Basic
-   [Lambda Calculus](https://en.wikipedia.org/wiki/Lambda_calculus)  
    Wikipedia's Lambda Calculus

------------------------------------------------------------------------

#### Learn to craft and manipulate Arrays Collections (\*\*\* OPTIONAL \*\*\*)

<span id="Arrays"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

Java is a strongly typed language. This is especially noticed when working with arrays. When compared to Java, other languages handling of arrays seems like sorcery! In Java, the important characteristics of arrays are:

-   arrays have a fixed length that is created when the array is declared
    -   When the array is created a fixed amount of memory, the size of which cannot change, is reserved for the array.
-   arrays have a single type
    -   when the array is created, you say what data type the array’s elements will contain. Arrays can only contain one type of data and that type of data cannot change for the life of the array.

So what does this mean in practice? Let’s take a look.

##### Follow Along

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `arrays`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/arrays

Now in the `arrays` directory, use your text editor to create the following code in a file called `Main.java`. Note you do not have to enter the comments!

    package arrays;

    import java.util.Random;
    import java.util.Collections;
    import java.util.Arrays;

    public class Main
    {
        public static void main(String[] args)
        {
            // random requires import java.util.Random
            Random rand = new Random();
            System.out.println("*** Array Example ***");
            // create an array that can hold 7 elements of type integers
            // notice the square brackets indicating an array
            int[] ournums = new int[7];

            // initialize the elements in the array with a random integer for each element
            // arrays are 0 indexed so a 7 element array contains elements 0, 1, 2, 3, 4, 5, 6.
            // we are just going to initialize elements 0 through 4
            for (int i = 0; i < 5; i++)
            {
                ournums[i] = rand.nextInt(10);
            }

            // We reference a particular element with the name of the array and the element's id number surrounded by square brackets
            System.out.println("The third element of the array is " + ournums[2]);

            System.out.println();
            System.out.println("Print using a for each loop");
            // to print the elements in the entire array, we will use a special form of the For Loop
            // We are using a For Each loop. This loops through the elements in the array 1 by 1 in order
            // whether those elements have been initialized or not!
            for (int arrElement : ournums)
            {
                System.out.println("Item: " + arrElement);
            }

            System.out.println();
            System.out.println("Print using a regular for loop");
            // array.length returns the number of elements in the array
            // the last element in the array is always 1 less than this number
            // due to the array's index being 0 based
            for (int i = 0; i < ournums.length; i++)
            {
                System.out.println("Array Element " + i + " = " + ournums[i]);
            }
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac arrays/*.java
    jar cvfe arrays.jar arrays.Main arrays/*.class
    java -jar arrays.jar

Fix any errors you might encounter and try again.

So the above code produces the following output:

    *** Array Example ***
    The third element of the array is 3

    Print using a for each loop
    Item: 7
    Item: 1
    Item: 3
    Item: 6
    Item: 7
    Item: 0
    Item: 0

    Print using a regular for loop
    Array Element 0 = 7
    Array Element 1 = 1
    Array Element 2 = 3
    Array Element 3 = 6
    Array Element 4 = 7
    Array Element 5 = 0
    Array Element 6 = 0

The following shows the execution of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-12.gif)

### Another Example

We are still working with the `Main.java` file in the directory `<home dir><work dir>/samplecollectionswithloops/src/arrays`.

Add the following to the end of your Main class:

            System.out.println();
            System.out.println("*** Another Way Example ***");
            // let's handle an array of Strings
            // We can initialize an array using a list of values
            // the size of the array is set as the number of items in the list
            String[] cars = {"Volvo","BMW","Ford","Mazda"};

            // we can find out the length of the array by calling a field in the array
            System.out.println(cars.length);

            // we can access the first element in the array
            System.out.println(cars[0]);

            // we can change the second element in the array
            cars[1]="Honda";

            // we can print the array's pointer
            System.out.println(cars);

            System.out.println("Before sort Element index 2 " + cars[2]);
            // The Arrays class requires the import java.util.Arrays
            // we can sort the elements of the array in ascending order using the Arrays class
            // this actually changes the order of the elements in the array
            Arrays.sort(cars);
            System.out.println("After sort Element index 2 " + cars[2]);

            // The Collections class requires the import java.util.Collections
            // we can sort the elements of the array in descending order using the Arrays and Collections class
            Arrays.sort(cars, Collections.reverseOrder());

            System.out.println();
            System.out.println("Array in descending order");
            // we can print the elements in the array using the Arrays class
            System.out.println(Arrays.toString(cars));

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac arrays/*.java
    jar cvfe arrays.jar arrays.Main arrays/*.class
    java -jar arrays.jar

Fix any errors you might encounter and try again.

So the above code produces the following output, minus output from previous sections:

    *** Another Way Example ***
    4
    Volvo
    [Ljava.lang.String;@73a8dfcc
    Before sort Element index 2 Ford
    After sort Element index 2 Mazda

    Array in descending order
    [Volvo, Mazda, Honda, Ford]

The following shows the execution of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-13.gif)

Arrays are very common in Core Java. In Java Web Programming ArrayLists are the most commonly used collection.

##### Dig Deeper

-   [Arrays](https://codegym.cc/groups/posts/arrays-in-java)  
    Arrays in Java with a good resource list as well

------------------------------------------------------------------------

#### Learn to craft and manipulate HashMap Collections (\*\*\* OPTIONAL \*\*\*)

<span id="HashMap"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

### HashMaps

After ArrayLists, the next most popular collection to use with Java Spring is the HashMap. HashMaps, like other collections, are a group of elements stored under a single variable name. We call each element in a HashMap an **entry** in the HashMap. This entry in the HashMap is a pair of data consisting of:

-   **key** must be unique and is used as the index into the HashMap. We look up things based on keys. It can be any data type but is usually a primitive type or String.
-   **value** can be any valid piece of data. This is the data we want to find when we look up the key.

So we end up with the syntax HashMap(key, value). To declare a HashMap we say:

    Map<String, Integer> ourHashMap = new HashMap<>();

In this case, the key to the HashMap are Strings, the values are Integers. Notice that both the data type for keys and values must be classes. This is why we use the class wrapper `Integer` for the primitive data type `int`.

Notice that HashMaps are a combination of key, value - just like JSON objects have a key, value combination. If you are unclear as to what JSON objects are, no worries, they will be covered soon.

### Sorting HashMaps

HashMaps have a unique issue when wanting to sort them. First they have to be converted to an ArrayList. HashMaps themselves do not maintain order. After converting to the ArrayList, we now have elements in our ArrayList that have multiple data, a key and a value. So which one are we sorting on?

To help us with sorting, we are going to use a **Lambda Expression**. We will be discussing Lambda Expressions in depth later in the course but for now: A Lambda Expression is short cut way to write a function. They are similar to the arrow functions in JavaScript. Some methods can take a function as a parameter. In these cases, Lambda Expressions are the way to go. Sort happens to be one such method. For example, to sort a HashMap that has been put into an ArrayList:

-   given that myList is an ArrayList containing entries for a HashMap
-   use the sort method from ArrayList
-   As the argument, use a Lambda Expression to say how to sort

<!-- -->

    myList.sort(Comparator.comparing(o -> o.getKey().toString()));

In the above example:

-   The parameter is another method, `Comparator.comparing`. This method will actually do the sort for us.
-   `Comparator.comparing` takes a parameter saying what to sort; in our case we want to sort based off of the keys in the entry so we use a getKey().
-   getKey() returns an object. We cannot compare data types of objects so we have to convert that object to a String, the data type of the keys
-   This will sort the ArrayList in ascending order. The original HashMap remains unchanged.

For another example:

     myList.sort(Comparator.comparing(o -> (int) o.getValue(), Comparator.reverseOrder()));

-   The parameter is another method, `Comparator.comparing`. This method will actually do the sort for us.
-   `Comparator.comparing` takes a parameter saying what to sort, in our case we want to sort based off of the value in the entry. We use a getValue()
-   getValue() returns an object. We cannot compare data types of objects so we type caste the object to an `int`, the data type of the value
-   We have added another argument to our Comparator.comparing method, Comparator.reverseOrder(). This will sort the ArrayList in descending order! The original HashMap remains unchanged.

##### Follow Along

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `hashmap`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/hashmap

Now in the the `hashmap` directory, use your text editor to create the following code in a file called `Main.java`. Note: you do not have to enter the comments.

    package hashmap;

    import java.util.ArrayList;  // ArrayList needed for sorting requires this import
    import java.util.Comparator; // When we sort, we use Comparator which requires this import
    import java.util.HashMap;    // HashMap requires this import
    import java.util.List;       // List needed for sorting requires this import
    import java.util.Map;        // Map requires this import

    public class Main
    {
        public static void main(String[] args)
        {
            // Declare a Map called cities with
            // keys being Strings, values being Integers
            // and initialize it as a HashMap with keys as Strings values as Integers
            // The String, Integer type for initialization, the one on the right of the equals sign
            // can be inferred from the String, Integer for the declaration, the one on the left.
            // So instead of saying
            // Map<String, Integer> cities = new HashMap<String, Integer>();
            // we can say
            Map<String, Integer> cities = new HashMap<>();

            // put new key, value pairs into the HashMap
            cities.put("Lehi", 62712);
            cities.put("Seattle", 724745);
            cities.put("San Francisco", 884363);
            cities.put("Austin", 1000000);
            cities.put("Denver",  619968);
            cities.put("Raleigh", 464758);
            cities.put("New York City", 8623000);

            // putting a key that already exists in the HashMap causes the value associated
            // with that key to be replaced with the new sent value!
            cities.put("Austin", 950715);

            // Displaying the HashMap. Note that putting the \n at the start of our string to display
            // says to first display a blank line and then display our text. So the following is the same as
            // System.out.println();
            // System.out.prtinln("*** The HashMap ***")
            System.out.println("\n*** The HashMap ***");
            System.out.println(cities);

            // Determine if the HashMap contains a certain key use containsKey()
            System.out.println("\nHashMap contains Raleigh as a key: " + cities.containsKey("Raleigh"));
            // Determine if the HashMap contains a certain value use containsValue()
            System.out.println("HashMap contains the value 1000000: " + cities.containsValue(1000000));

            // Since HashMaps do not have a fixed size, we must calculate its size using the method size();
            System.out.println("\nSize of the HashMap is " + cities.size());

            // Remove the item from the HashMap based off of a key
            // use remove();
            cities.remove("Seattle");
            cities.remove("Portland"); // Since Portland is not a key, does nothing

            System.out.println("\nHashMap with one Removed");

            // Using a For Each loop, print the key, value pairs in the HashMap
            // We are looping through the entries, elements, in the HashMaps
            // These Entries are part of a set called entrySet
            // Each entry is composed of a key and a value, in our case a String and an Integer
            // HashMap.Entry can determine what key and value data types it needs from the HashMap
            // we are looping through
            for (HashMap.Entry mapElem : cities.entrySet())
            {
                // print() says do not start the next line on a new line
                // so no return at the end of this print statement.
                System.out.print("Key is " + mapElem.getKey());
                System.out.println("   Value is " + mapElem.getValue());
            }

            // Sorting a HashMap directly is not possible.
            // First we must put the data into an ArrayList and then sort the ArrayList
            // We also have to decide whether we want the HashMap sorted by key or by value
            // Let's sort by key first
            // HashMap.Entry can determine the key and value data types from the HashMap we are converting to the ArrayList
            // the Constructor for an ArrayList can take a set as a parameter!
            List<HashMap.Entry> myList = new ArrayList<>(cities.entrySet());

            // To sort by the keys, use the ArrayList sort method which takes a method
            // Comparator.comparing, which takes argument of what to sort!
            myList.sort(Comparator.comparing(o -> o.getKey().toString()));

            System.out.println("\nSorted by Key");
            System.out.println(myList);

            // To sort by the value, use the ArrayList sort method which takes a method
            // Comparator.comparing, which takes arguments of what to sort and
            // the optional argument saying to sort in descending order!
            myList.sort(Comparator.comparing(o -> (int) o.getValue(), Comparator.reverseOrder()));

            System.out.println("\nSort by Value");
            System.out.println(myList);

            // To clear the HashMap use clear()
            // Java would automatically free up the memory allotted to the HashMap when the HashMap goes out of scope,
            // so at the end of this method.
            myList.clear();
            System.out.println("\nThe HashMap Cleared");
            System.out.println(myList);
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac hashmap/*.java
    jar cvfe hashmap.jar hashmap.Main hashmap/*.class
    java -jar hashmap.jar

Fix any errors you might encounter and try again.

So we get the following output:

    *** The HashMap ***
    {San Francisco=884363, New York City=8623000, Seattle=724745, Raleigh=464758, Denver=619968, Austin=950715, Lehi=62712}

    HashMap contains Raleigh as a key: true
    HashMap contains the value 1000000: false

    Size of the HashMap is 7

    HashMap with one Removed
    Key is San Francisco   Value is 884363
    Key is New York City   Value is 8623000
    Key is Raleigh   Value is 464758
    Key is Denver   Value is 619968
    Key is Austin   Value is 950715
    Key is Lehi   Value is 62712

    Sorted by Key
    [Austin=950715, Denver=619968, Lehi=62712, New York City=8623000, Raleigh=464758, San Francisco=884363]

    Sort by Value
    [New York City=8623000, Austin=950715, San Francisco=884363, Denver=619968, Raleigh=464758, Lehi=62712]

    The HashMap Cleared
    {}

The following shows the execution of this code.

![HashMap execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-15.gif)

##### Dig Deeper

-   [HashMaps](https://beginnersbook.com/2013/12/hashmap-in-java-with-example/)  
    Beginners Book HashMaps
-   [Iterate over a Map](https://www.baeldung.com/java-iterate-map)  
    Baeldung Iterate over a Map in Java
-   [HashMap.put](https://www.geeksforgeeks.org/hashmap-put-method-in-java/)  
    GeeksForGeeks HashMap.put Method in Java
-   [HashMap.containsKey](https://www.geeksforgeeks.org/hashmap-containskey-method-in-java/)  
    GeeksForGeeks HashMap.containsKey() Method in Java

------------------------------------------------------------------------

#### Learn to craft and manipulate HashSet Collections (\*\*\* OPTIONAL \*\*\*)

<span id="HashSet"></span>

##### Overview

### Software Needed

-   Java Development Kit (JDK) - at least version 11
-   Text Editor

### HashSets

HashSets contain a collection of values. These values can be of primitive types or Classes. However, HashSets force the values to be unique. Our main use of HashSets will be to create unique lists of things. When you are adding elements to a HashSet, if the HashSet already contains the element, nothing happens. The program just goes on executing, ignoring the add statement. This is very useful when we need to generate, for example, a unique random list of names. We can randomly generate the names, add them to a HashSet and if by chance we generate a duplicate, adding to the HashSet is simply ignored.

HashSets do not maintain order. Java maintains the set in whatever order is most efficient. So to sort a HashSet, we must first convert it to an ArrayList.

HashSets are derived from Sets in Java. Often you will see in Java programs a variable being declared as the general type Set followed by being initialized with a HashSet. This is a common practice when using the Spring Framework.

##### Follow Along

If you have not already, create an application called `samplecollectionswithloops` in your work folder. We are going to create a package called `hashset`. So you will end up with the directory:

    <home dir><work dir>/samplecollectionswithloops/src/hashset

Now in the the `hashset` directory, use your text editor to create the following code in a file called `Main.java`. Note: you do not have to enter the comments.

    package hashset;

    import java.util.ArrayList;   // ArrayList needed for sorting requires this import
    import java.util.HashSet;     // HashSet requires this import
    import java.util.Iterator;    // Iterator needing for looping through the HashSet requires this import
    import java.util.List;        // List needed for sorting requires this import
    import java.util.Set;         // Set requires this import
    import java.util.Collections; // needed to sort the ArrayList

    public class Main
    {
        public static void main(String[] args)
        {
            // Declare a Set called H with String elements
            // and initialize it as a HashSet with String elements.
            // The String element type for initialization, the one on the right of the equals sign
            // can be inferred from the String element type for the declaration, the one on the left.
            // So instead of saying
            // Set<String> h = new HashSet<String>();
            // we say
            Set<String> h = new HashSet<>();

            // Add elements to HashSet using add()
            h.add("Lehi");
            h.add("Seattle");
            h.add("San Francisco");
            h.add("Austin");
            h.add("Denver");
            h.add("Raleigh");
            h.add("New York City");
            h.add("Austin"); // trying to add a duplicate just gets ignored

            // Displaying the HashSet. Note that putting the \n at the start of our string to display
            // says to first display a blank line and then display our text. So the following is the same as
            // System.out.println();
            // System.out.prtinln("*** The HashSet ***")
            System.out.println("\n*** The HashSet ***");
            System.out.println(h);

            // Determine if the HashSet contains a certain value use the contains()
            System.out.println("\nHashSet contains Raleigh or not: " + h.contains("Raleigh"));

            // Since HashSets do not have a fixed size, we must calculate its size using the method size();
            System.out.println("\nSize of the HastSet: " + h.size());

            // Remove items from a HashSet remove()
            // The items is not in the HashSet, the remove gets ignored
            h.remove("Seattle");
            h.remove("Portland");
            System.out.println("\nHashSet with one Removed");

            // Print iterating over the HashSet. This allows you to interact with each element
            // in the HashSet. Here we just print it but you could do other statements as well!
            // Notice the Iterator we create contains the same element type as the HashSet
            // DO NOT change the HashSet during the loop. This can cause issues!
            Iterator<String> i = h.iterator();
            // while there is still another element
            while (i.hasNext())
            {
                // Read the next available element in the HashSet and advance the loop one element
                // Since temp is being declare in the body of this while loop, temp is only in scope
                // during the execution of the body of the while loop. Each time the while loop
                // executes the body, temp has be recreated
                String temp = i.next();
                System.out.println(temp);
            }

            // To sort a HashSet, first convert it to an ArrayList and then sort the ArrayList.
            // This does not change the actual HashSet
            // The ArrayList constructor can take a parameter of type set!
            List<String> hlist = new ArrayList<>(h);

            System.out.println("\nThe Sorted HashSet");
            Collections.sort(hlist);
            System.out.println(hlist);

            // To clear the HashSet use clear()
            // Java would automatically free up the memory allotted to the HashSet when the HashSet goes out of scope,
            // so at the end of this method.
            h.clear();
            System.out.println("\nThe HashSet Cleared");
            System.out.println(h);
        }
    }

To run our code, we go through the following steps, running these commands from the `src` directory:

    javac hashset/*.java
    jar cvfe hashset.jar hashset.Main hashset/*.class
    java -jar hashset.jar

Fix any errors you might encounter and try again.

So we get the following output:

    *** The HashSet ***
    [San Francisco, New York City, Seattle, Raleigh, Denver, Austin, Lehi]

    HashSet contains Raleigh or not: true

    Size of the HastSet: 7

    HashSet with one Removed
    San Francisco
    New York City
    Raleigh
    Denver
    Austin
    Lehi

    The Sorted HashSet
    [Austin, Denver, Lehi, New York City, Raleigh, San Francisco]

    The HashSet Cleared
    []

The following shows the execution or flow of this code.

![Array execution](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2010%20-%20WEB%20Java%20Fundamentals/Module%202%20-%20JX%20Java%20-%20II%20Language%20Fundamentals/assets/JX-SP10-M2-14.gif)

##### Dig Deeper

-   [HashSet](https://www.javatpoint.com/working-of-hashset-in-java)  
    Working of HashSet in Java

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### java-transportation

With this project, we will discover some unique object oriented constructs, interfaces and abstract classes, and discuss Lambda Express - a way in Java to pass a function as a parameter.

[GitHub Repo](https://github.com/LambdaSchool/java-transportation.git)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Animal Kingdom](https://github.com/LambdaSchool/java-AnimalKingdom.git)

    This project will help you practice using interfaces, abstract classes, inheritance, and Lambda expressions in Java.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Abstract Classes, Interfaces, Lambda Expressions for WEB33 with John Mitchell](https://youtu.be/3mFJWXBh_YI)**
-   [All previous recordings](/archive/WEB4Java/module/rec6Hrk77HupYeoN5)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Guided Project: java-transportation
-   Project: Animal Kingdom
