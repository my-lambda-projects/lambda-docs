<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

- [Python Basics](/cs/module/recHNgXTaBpnn052p/)
- [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
- [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
- [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

- [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
- [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
- [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
- [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

- [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
- [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
- [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
- [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

- [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
- [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
- [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
- [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

- [Python Basics](/cs/module/recHNgXTaBpnn052p/)
- [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
- [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
- [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

- [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
- [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
- [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
- [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

- [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
- [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
- [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
- [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

- [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
- [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
- [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
- [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

- [Prepare](#prepare)
- [Learn](#learn)
- [Review](#review)

# Problem Solving

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- name and describe the details of each step of Lambda's Problem-Solving Framework (U.P.E.R)
- effectively ask for help by giving the expected vs. experienced behavior, explaining what specific actions they've taken so far, and providing all relevant information and code

#### Pro Tip

No problem can withstand the assault of sustained thinking.

Voltaire

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=16Rja_aziWU), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=yVygkK2mTIY), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to name and describe the details of each step of Lambda's Problem-Solving Framework (U.P.E.R)

##### Overview

Many times, both as you are working through the Computer Science curriculum and when you are on the job, you will find yourself faced with large, challenging problems. There are strategies we can use to break these problems down into more manageable pieces.

> “The single most important skill for a computer scientist is problem-solving. Problem-solving means the ability to formulate problems, think creatively about solutions, and express a solution clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity to practice problem-solving skills.” Think Python, 2nd Edition, by Allen B. Downey (O’Reilly). Copyright 2016 Allen Downey, 978-1-4919-3936-9.

Every problem, large or small, can be broken into smaller chunks. Logically, if you can take a seemingly unsolvable problem and break it into smaller, more manageable chunks, once you’ve finished solving each piece of the problem, you’ll have conquered the whole thing!

Throughout the Computer Science curriculum, we will reference and draw from the Lambda Problem Solving Framework, sometimes referred to as **UPER**. This framework is a step-by-step process:

1.  **U**nderstand
2.  **P**lan
3.  **E**xecute
4.  **R**eflect

Almost all problems are a series of sub-problems. You will use the steps of **U.P.E.R** on the primary outer problem and the inner, individual sub-problems.

### **1. Understand**

Before doing anything else, make sure you understand precisely what the problem is asking. A helpful starting point could be transcribing the technical description of the problem into your own words.

#### **Questions**

Here is a list of starter questions that might come up during this step:

- _What are the inputs your code receives?_
  - _What is the range of the input?_
  - _How big can the input be (how much data)?_
- _What are the outputs your code produces?_
  - _What is the range of the output?_
  - _How big can the output be (how much data)?_
- _How performant must the code be?_
- _Is there anything missing from the task description that needs to be clarified?_
- _What assumptions are you making?_
  - _Does anyone else on the team need to validate these assumptions?_

#### **Actions**

The most important thing you can **do** during this stage of the process is to **ask questions**! Be as specific as you can when you ask questions. Be clear and concise with your questions by using unambiguous language and only including necessary details.

Don’t be afraid of this part of the process—enjoy it! Look at the problem as a curiosity to be explored, not just something there to torment you. Feeling frustrated and afraid won’t help you at work or in an interview. Remember, problem-solving is the fun part, so enjoy it!

One approach is to identify the smaller components that make up the larger problem. If you get stuck in understanding, break the larger problem into smaller sub-problems. Then, apply this framework against each of the smaller sub-problems until you solve the larger problem.

Try to digest the problem and comprehend it by rewriting the problem in your own words. If you had to describe it to someone else, how would you do it?

Diagram how the data flows through the problem. Think about each stage of the journey for the data. What will happen to it as it travels from one step to another?

Think like a villain. What inputs would break your program?

Where is the description of the problem incomplete? If you cannot get answers on something that the specifications leave unclear, make an educated guess, and document your assumptions and decision.

You are done with this step when you can explain this problem to someone who has never seen it. Your explanation should be thorough enough for the person to skip the “Understand” step and start planning right away.

### **2. Plan**

This step is where you will ask, “_what steps will I take to solve the problem_?” You will take your description of the problem and transform it into a complete, actionable plan to solve that problem. If you realize you still don’t truly understand the problem while planning, return to **Understand** until you resolve the ambiguity. If you have not yet completed **Understand**, you will end up planning to solve the wrong problem! When interviewing, you must do this step aloud!

Remember, you aren’t coding during this step unless it’s a small piece of throwaway code to test a hypothesis. It would be best if you wrote pseudocode during this step, however.

#### **Questions**

- _Do you know the answer to a similar problem that has comparable inputs and outputs?_
  - _Does this problem remind you an anything else?_
  - _Can you bring that knowledge to bear here?_
- _Does my plan meet the performance requirements?_
  - _What’s the time complexity?_
  - _What’s the space complexity?_
  - _How big can my input data be?_
- _Can sorting the input data ahead of time lead to any improvements in time complexity?_
  - _Does recursion help?_
  - _Is the problem made up of identical subproblems?_
  - _Can you state the problem with itself in its definition?_
- _Think like a villain. Does your plan cover the edge cases?_

#### **Actions**

Solve the problem like a human. If you’re sorting something, imagine your task as a pile of blocks that you need to sort by hand. Break down the steps you take into small enough pieces for a computer to understand. Approach the problem from many angles.

Get a brute-force solution as quickly as possible. Even if it’s not performant enough, it can lead you toward better solutions.

Come up with as many plans of attack as you can. Choose the best one that satisfies performance needs.

Try to solve a simpler version of the problem. If the input is a 2D array, can you solve it for a 1D array? If you need to count the number of ways to eat cookies 1, 2, or 3 at a time, first try to solve it for the number of ways you could eat two at a time, or even one at a time. The solution to the more straightforward problem can lead to insights on the more complex problem.

List the nouns and verbs in the problem description. Map each one to an algorithm, process, data structure, object, method, function, etc.

“Perfect” can be the enemy of “good.” Even if your initial workable solution isn’t performant enough, you can iterate later. “Premature optimization is the root of all evil.”

You know that you completed this step when you have pseudocode that’s detailed enough to convert to real code. It would be best if you also were convinced the pseudocode represents a legitimate working solution.

### **3. Execute**

This step is where you take your plan and convert it to actual working code. This step isn’t easy, but it’s much easier if you’ve done an excellent job with the “Understand” and “Plan” steps above. If you find shortcomings in your plan while implementing the solution, return to the “Plan” phase until you resolve the ambiguity. If you have not yet completed the “Plan” step, you will spend far longer on the “Execute” step than you have to.

#### **Questions**

- _Think like a villain. Does your implementation handle all inputs?_
- _What is the best way to split this code into separate functions or classes?_
- _Does this functionality already exist?_
  - _Are there built-in libraries I can leverage?_
  - _Are there third-party libraries I can leverage?_

#### **Actions**

Convert your pseudocode and outlines into actual code. Don’t Repeat Yourself (DRY): Remove redundant code as you write it.

Document code as you write it. Header blocks should contain information on how someone should use the code. Comment only when necessary; where possible, write code clearly enough that comments aren’t needed. If comments help clarify or summarize a piece of code to a reader, definitely add comments.

If you write code that’s hackish or kludgy, fix it. If you don’t have time to fix it, comment it, explain why you couldn’t do it “the right way” (time constraints, etc.), and what you need to do to make it right.

You know this step is complete when your solution works on good data, it doesn’t fail on flawed data or edge cases, and the program passes all of the tests.

### **4. Reflect**

The primary question you are dealing with during this step is — “is this implementation as good as I can make it?” Would I be proud to show my code to another programmer?

#### **Questions**

- _Does your solution work in all cases?_
  - _Main case?_
  - _Edge cases?_
- _Is the solution performant enough?_
- _Is the code documented?_
- _In retrospect, what would you do differently? What will you do differently next time?_
  - _What went right?_
  - _What went wrong?_

#### **Actions**

Adding documentation is a necessary action during this step. It would be best if you documented any future changes you plan on making. You should document any code sections that you will need to make more performant if the data size increases.

Another critical action to take during this step is to remove any redundant or unnecessary code. Also, depending on your time constraints, it’s likely that you might have some hackish code that you’d like to improve in the future when time allows. Make sure to document any ideas or plans on how you might do so.

You know that this step is complete when your code is adequately refactored and exhaustively documented.

##### Follow Along

Let’s use the _[dining philosophers problem](https://en.wikipedia.org/wiki/Dining_philosophers_problem)_ as an example problem to use our Problem Solving Framework on. Here’s a short description of the problem:

> Five silent philosophers sit at a round table with bowls of noodles. One chopstick is placed between each pair of adjacent philosophers.
>
> Each philosopher must alternately think and eat. However, a philosopher can only eat noodles when they have both left and right chopsticks. Each chopstick can be held by only one philosopher and so a philosopher can use the chopstick only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.
>
> Eating is not limited by the remaining amounts of noodles or stomach space; an infinite supply and an infinite demand are assumed.
>
> The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e. each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.

### **1. Understand**

On the surface, this seems like a straightforward problem — however, some approaches will lead to problematic results.

Here are some critical pieces of information from the question we should highlight:

- there are **5** philosophers
- there are **2 states** (eating, thinking)
- there is precisely 1 chopstick in between each pair of philosophers (5 total)
- BOTH chopsticks are required to transition from thinking to eating

Some essential questions to ask here include _“When should philosophers pick up a chopstick?”_ and _“When should philosophers put down a chopstick?”_

Remember that you want to establish if there are any restrictions or limitations you need to consider before you work on a solution.

### **2. Plan**

Let’s create a solution written as a set of rules that defines how philosophers should interact with chopsticks in a manner that will allow them to transition between _eating_ and _thinking_.

1.  philosopher is eating (2 chopsticks)
2.  philosopher finishes eating and sets down chopsticks
3.  philosopher is thinking (0 chopsticks)
4.  philosopher sees his/her neighbor set down chopsticks & picks them up
5.  repeat steps 1-4

### **3. Execute**

We could break down the general plan above into a few specific rules.

- eat for a set amount of time once they are holding both chopsticks
- put down the right chopstick
- put down the left chopstick
- pick up the left chopstick as soon as it becomes available
- pick up the right chopstick as soon as it becomes available
- repeat

However, this solution will NOT always work.

### **4. Reflect**

The above solution has the potential to create a situation known in Computer Science as **deadlock**. A deadlock means that two processes are stuck in an eternal state of waiting. If neither has two chopsticks, they cannot eat. But they also won’t put down chopsticks they’re holding (because they haven’t eaten yet). We need to revise the rules about when philosophers should pick up / put down chopsticks to eliminate this possibility.

##### Challenge

For everyone to eat, there are some situations in which philosophers _should_ pick up a chopstick and some cases in which they _should NOT_ (because another philosopher needs to use it).

Write a better solution to the dining philosophers problem so that deadlock does NOT occur.

##### Dig Deeper

- <https://www.interviewcake.com/tricks-for-getting-unstuck-programming-interview?course=fc1&section=interview-tips>

---

#### Learn to effectively ask for help by giving the expected vs. experienced behavior, explaining what specific actions they've taken so far, and providing all relevant information and code

##### Overview

The necessary action when asking a question is to imagine that you are trying to answer your question. Because you are deep in your problem’s weeds, it’s easy to forget that the person who answers your question does not have all the context. We should keep this general rule in mind — it’s the overarching rule for all the details we go into next.

### Search and Research

Before you do anything else, search for a solution to your problem on your own. One thing you should start doing is keeping track of all your research when solving a problem. One easy way to do this is to have a browser window represent a specific search for a solution, and each open tab represents an attempt at solving it. Keeping track of your research is vital because it’s helpful to provide examples of similar questions or similar problems and explain why those didn’t answer your specific problem or question. It also helps the person answering your question avoid pointing you toward resources you’ve already explored, and lets them know that you’ve already put in the work.

### Introduce the Problem

The first thing you do when you ask a question￼￼￼￼ is to introduce the problem. The first paragraph of your written question should serve as an executive summary of the problem. All the following paragraphs should fill in the details of the problem.

An important thing to include in your problem introduction is a precise explanation of how you encountered the problem. Write about the difficulties that kept you from solving it. Describe what you already tried and include the results of the research you’ve done.

You should also provide as much detail about the context as possible. For instance, include the language version, the platform version, the operating system, the database type, specific IDE, and any web server information. You should also include your particular constraints. For example, you may not be allowed to use feature A or B that would provide an obvious solution. If you have an odd constraint, it may also help explain why you have that constraint.

### Help Others Reproduce the Problem

One thing to remember is that not all questions benefit from including code. However, if you include code, definitely do not just copy in your entire program! By having irrelevant details, you make your question much harder to answer and decrease the chances of someone helping you.

Here are some guidelines for when to include code in your question.

### **Minimal**

Include just enough code to allow others to reproduce your specific problem.￼￼ One way to do this is to restart from scratch. Do not include snippets of your entire program. Instead, create a new program, but only add what’s necessary to recreate the problem.

If you aren’t exactly sure where the problem code is, one way to find it is by removing code chunks one at a time until the problem disappears — then add back the last part. This way, you can deduce that the last piece of code you added back is likely the source of your problem.

Be careful not to remove too much code, either. Keep your question brief, but maintain enough context for clarity.

### Complete

Make sure you include all the portions of the code needed to reproduce the problem. It would be best if you assumed that the person who is answering your question would not write any code to reproduce your issue. Again, remember, do not use images of code—those trying to help you need direct access to the code you include in your question.

### Reproducible

When you include your code, it’s also important to tell the reader exactly what you expect the behavior to be. Be sure to show the reader the exact wording of the error message you encountered (if there was one). It’s also crucial to double-check that your included example reproduces the problem.

One other thing you can do is create a live example on a site like sqlfiddle.com or jsbin.com. If you do, make sure you also include a copy of your code in your question. Not everyone will utilize the link to the live example.

And to reiterate, do not post images of any code, data, or error messages—reserve images for things like rendering bugs—things that are impossible to describe accurately with just text.

### Proofread

Don’t send a question you haven’t proofread. When you post your question, you should have already read and reread it, taking care to follow all the best practices and making sure your question makes sense. It would be best if you imagined that you’re coming to your question fresh, with no other context but the question itself. You want to make your question as easy for someone to answer as possible. Remember, the reader is likely choosing between several questions they could answer. You want your question to stand out as something concise and approachable. Don’t forget to double-check your spelling, grammar, and formatting. Keep it as straightforward as you can; you’re not writing a novel.

### Respond to Feedback

As feedback and responses to your question begin coming in, respond as quickly as possible. You’ll likely receive clarifying questions, and your readers need that clarification to help you.

##### Follow Along

Now let’s look at an example of a question posted to Stack Overflow and analyze it to see if it follows the best practices outlined above.

[The question](https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops):

![](https://camo.githubusercontent.com/9be35d94fd27e59fc716b00942c22b5b3438a99a/68747470733a2f2f746b2d6173736574732e6c616d6264617363686f6f6c2e636f6d2f64383031393630662d626530662d346633362d383634612d3564626666616435306631635f53637265656e53686f74323032302d30332d33306174332e31352e3330504d2e706e67)

The first thing to notice is that the post has a short but descriptive title that adequately summarizes the question.

> Accessing the index in ‘for’ loops?

Next, did the questioner provide any additional context or proof of the research they’ve done so far? It doesn’t look like it. They could improve the question by including what they tried and the resources they explored.

The questioner did an excellent job of introducing the question and including code that shows what they are trying to do. In this case, they did not need to include experience vs. expected behavior; they just needed to have the expected behavior. By clearly stating what the desired result was, it helped the person answering to respond appropriately.

The code they included is a minimal and complete example, allowing someone to reproduce the problem quickly. The questioner left out irrelevant details and code that would’ve distracted from the primary question. They also included an example of what the desired output would be, which is helpful.

It appears the questioner proofread their question beforehand as it does not contain any glaring spelling, grammar, or formatting problems. However, we could critique this example for including a redundant sentence at the end. Instead of including that sentence, they might have rephrased the first sentence of the question to be more precise.

##### Challenge

1.  Choose a real-world example from a recent problem/challenge. Use the guidelines and process outlined above to ask for help in your cohort-specific help channel.
2.  Identify an unanswered question in your cohort-specific help channel. Do your best to provide a helpful response to that question.
3.  Find an example of a **bad** question on Stack Overflow. Analyze the question using the guidelines above and write a short response explaining _why_ you believe it is a **bad** question.
4.  Find an example of a **good** question on Stack Overflow. Analyze the question using the guidelines above and write a short response explaining _why_ you believe it is a **good** question.

##### Dig Deeper

- [Stack Overflow: How Do I Ask a Good Question?](https://stackoverflow.com/help/how-to-ask)
- [Writing the Perfect Question](https://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/)
- [How to Ask Questions the Smart Way](http://catb.org/esr/faqs/smart-questions.html)
- [How to Debug Small Programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/)

---

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[CSPT15 Problem Solving w/Tom Tarpey](https://youtu.be/I-CBduH1q3E)**

  Lecture 10/29/2020

- [All previous recordings](/archive/cs/module/recagU9ihCuMePtbx)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  For everyone to eat, there are some situations in which philosophers _should_ pick up a chopstick and some cases in which they _should NOT_ (because another philosopher needs to use it).

  Write a better solution to the dining philosophers problem so that deadlock does NOT occur.

- Objective challenge:
  1.  Choose a real-world example from a recent problem/challenge. Use the guidelines and process outlined above to ask for help in your cohort-specific help channel.
  2.  Identify an unanswered question in your cohort-specific help channel. Do your best to provide a helpful response to that question.
  3.  Find an example of a **bad** question on Stack Overflow. Analyze the question using the guidelines above and write a short response explaining _why_ you believe it is a **bad** question.
  4.  Find an example of a **good** question on Stack Overflow. Analyze the question using the guidelines above and write a short response explaining _why_ you believe it is a **good** question.
