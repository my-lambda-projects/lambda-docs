

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Express Middleware

<span class="lead"> </span>

Express is a minimalist framework. It doesn’t provide everything out of the box, but using middleware we can add extra functionality to our application. Middleware provide a way to extend the features provided by the Express framework.

They are implemented as small functions that handle one aspect of our application. Tasks like **authentication** and **logging** are commonly handled by middleware. Another benefit of Middleware is that it provides an easy way to add modularity to our code.

On this module we’ll cover:

-   the what, why and how of Middleware.
-   different types of Express Middleware.
-   how to create Custom Middleware.
-   error handling middleware.

**At the end of this module, you should be able to:**

-   explain what middleware is and the different types
-   write custom middleware
-   write error handling middleware

#### Pro Tip

Treat everyone with as much respect and integrity as you wish to be treated with.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=EE8CId1FK_Q), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=7aHJz4SJT4Y), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=ItY7Ddzr8jA), or enable JavaScript if it is disabled in your browser.

-   [Middleware explained](https://expressjs.com/en/guide/writing-middleware.html)

    straight from the Expressjs.com docs

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what middleware is and the different types

We can use Express Middleware to add features to Express. It is the biggest part of Express, **most of the code we write, including route handlers, is middleware under the hood**.

We can think of middleware as array of functions that get executed in the order they are introduced into the server code.

Express middleware is compatible with *connect middleware*. Connect is a web application framework for Node.js that only provides the middleware layer.

Since `Connect` has been around for longer, it has a rich ecosystem of modules and we can take advantage of that. If you can’t find an Express Middleware package with the functionality you want, try searching for a Connect Middleware module instead.

##### Overview

There are different types of middleware; for our purposes, we’ll group them into:

-   Built-in middleware.
-   Third-party middleware.
-   Custom middleware.

**Built-in middleware** is included with Express, but not added to the application automatically. Like the other types, we need to opt-in to using it in our application.

We saw an example of built-in middleware when we added support for parsing JSON content out of the request body using `server.use(express.json());`.

All types of middleware work in the same way. We tell Express about the middleware we want to *turn on* for our application by making a call to `.use()` on our server and passing `.use()` the piece of middleware we want to apply. This line must come after the server has been created by calling `express()`.

**Third-party middleware** are npm modules that we can install and then import into our applications using `require()`. There are thousands of middleware modules we can use, no need to write our own in most cases.

Some popular middleware modules are:

-   [morgan](https://www.npmjs.com/package/morgan).

-   [cors](https://www.npmjs.com/package/cors).

-   [helmet](https://www.npmjs.com/package/helmet).

-   add morgan to solution, *require* it `const logger = require('morgan');`

-   add a new `server.use(logger('short))` before our other use. Show console.

**Custom middleware** are functions we write to perform certain tasks. We’ll learn more about how to write and use them in the next section.

##### Follow Along

One thing that is not immediately obvious is that **route handlers are middleware**. Let’s see this in action.

In our current implementation, if a client visits a non-existent endpoint, they will get a default message when a resource is not found on the server. In the case of a browser, its *Cannot Get /urlWeTriedToAccess*. This is a poor user experience. **Please code along** as we write a request handler that responds with a custom message for invalid URLs.

    function(req, res) {
      res.status(404).send("Ain't nobody got time for that!");
    };

This code is not complete yet, but you can see that it is, in fact, a request handler function, we know because *the homies* (req and res) are there.

Now let’s just *use* it as if it was middleware:

    server.use(function(req, res) {
      res.status(404).send("Ain't nobody got time for that!");
    });

Almost there, the last step is adding this status **after each route handler**, so that if the preceding middleware or route handlers (which happen to be middleware also) do not respond to the request, then this will become our *catch-all* and respond with the correct HTTP status code and a helpful message.

Now, requests to a non-existent endpoints will result in better experience for our clients.

##### Challenge

Write a paragraph (or two) explaining what Express middleware is and what you’d use it for when writing Web APIs.

When done send your explanation to your PM on Slack.

##### Dig Deeper

-   [cors middleware](https://www.npmjs.com/package/cors)  
    Third party middleware to make it easy to configure CORS in a Node.js application
-   [helmet middleware](https://www.npmjs.com/package/helmet)  
    Third party middleware for configuring security headers in a Node.js application
-   [morgan middleware](https://www.npmjs.com/package/morgan)  
    Third party middleware for logging in Node.js applications

------------------------------------------------------------------------

#### Learn to write custom middleware

We can write our own `Custom Middleware` to add functionality needed by our applications that is not included by Express.

This is a powerful feature that makes it really easy to extend the Express framework without the need to modify it’s source code.

We’ll see some examples of the two types of custom middleware that we’ll call *regular* middleware and *error handling* middleware.

##### Overview

Writing `custom middleware` is a two-step process:

Write a function that will receive three or four arguments. Add it to the `middleware queue`.

Let’s tackle the first part with an example. We’ll write middleware that logs information about every request that comes into our server. We’ll be displaying the information in the console window to keep things simple.

    function logger(req, res, next) {
      console.log(
        `[${new Date().toISOString()}] ${req.method} to ${req.url} from ${req.get(
          'Origin'
        )}`
      );

      next();
    }

We can see that a middleware function takes **three parameters**, the `request` and `response` objects, and a third parameter that is a `function that points to the next middleware` in the queue. By convention, we name the third parameter `next`. Please stick to that convention in your code.

Any middleware in the queue CAN modify both the request and response objects, but it’s NOT required. In this case, we are not making changes to either.

Any middleware in the queue can stop the request and send a response back to the client. When that happens, the rest of the middleware, including the route handlers, will not work. We’ll see an example of this in the code-along section.

Calling `next()` signals to Express that the middleware has finished, and it should call the next middleware function. **If next() is not called and a response is not sent back to the client, the request will hang, and clients will get a timeout error**, so make sure to always call `next()` or use one of the methods that send a response back like `res.send()` or `res.json()`.

Now let’s add our shiny middleware to the queue! Right after `server.use(express.json());` add the following line.

    server.use(logger);

Hitting any of our endpoints will display some information about the request in the console.

Congratulations, you know how to write custom middleware for Express!

##### Follow Along

Any middleware in the queue can stop the request and send a response back to the client. When that happens, the rest of the middleware, including the route handlers, will not be executed. Let’s see this in action by writing our very own authentication middleware, but first, a bit of a story (any similarity to an actual story is a pure coincidence).

Imagine you’re next to a lake where a dangerous creature dwells, and it is moving towards you with ill intentions. Luckily, next to you is a sealed door that leads to safety, unfortunately, to open the door you need to provide the right password. Let’s implement the API for that.

Start by defining a function that shows our current predicament at the console as the application loads.

    function atGate(req, res, next) {
      console.log('At the gate, about to be eaten`);

      next();
    }

Then add it as the first middleware in the queue.

    server.use(atGate);

This is what’s called global or application-wide middleware. It applies to every endpoint in our server. Accessing any route in our server should display the message on the console.

Now let’s add the authentication middleware that only grants access if we hit the correct route; picking any other route is futile, so be careful!

    function auth(req, res, next) {
      if (req.url === '/mellon') {
        next();
      } else {
        res.send('You shall not pass!');
      }
    }

Now let’s add a route handler that leads to safety:

    server.get('/mellon', auth, (req, res) => {
      console.log('Gate opening...');
      console.log('Inside and safe');
      res.send('Welcome Traveler!');
    });

What’s new here is that we are adding our middleware as the second parameter and the route handler as the third. Using middleware this way is what we call **local middleware** or route middleware. It just means we are using middleware locally and only applies to the endpoint where it’s added.

##### Challenge

Write a piece of middleware that responds with the message, “Balance is the key, making things even is the secret to success.” It should send an HTTP Status Code 403 (Forbidden) when the client makes a request, and when the seconds value in the server clock is odd. Otherwise, let the request flow through the rest of the middleware queue.

So if a client makes any request and the server clock is at 11:10:11 or 11:10:13 the request is rejected, but at 11:10:12, or 11:10:14 is not.

##### Dig Deeper

-   [express.json](https://expressjs.com/en/api.html#express.json)  
    The documentation for how to use express.json to format your requests in Node/express

------------------------------------------------------------------------

#### Learn to write error handling middleware

There are two types of middleware in Express that we’ll call *regular* middleware and *error handling* middleware.

We have seen and worked with *regular middleware*. It is the middleware used when the application is working normally, but what happens when there is an error? That’s when *error handling middleware* comes into action and all *regular middleware* is turned off.

In this section we’ll cover how to write *error handling middleware* and how it works.

##### Overview

When our application encounters an error in the middle of executing middleware (remember route handlers are also middleware) code, we can **choose** to hand over control to *error handling middleware* by calling `next()` with one argument. It is an unspoken convention to make that argument be an error object like this: `next(new Error("error message"))`.

This type of middleware takes four arguments: `error`, `req`, `res`, and `next`. We pass the first argument when calling `next(new Error('error message here'))`. When the error handling code is finished, we can choose to end the request or call next without arguments to continue to the next *regular middleware*.

Error handling middleware CAN be placed anywhere in the stack, but it makes the most sense to place it at the end. If the intention is for middleware to handle errors that may occur elsewhere in the queue, then it needs to run after the rest of the middleware has run.

##### Follow Along

Let’s see this error-handling middleware in code. First, let’s write an endpoint that sends a file to the client in response to a `GET` request to the `/download` endpoint.

    const express = require('express');
    const path = require('path');

    const server = express();

    server.get('/download', (req, res) => {
      const filePath = path.join(__dirname, 'index.html');
      res.sendFile(filePath);
    });

    server.listen(5000);

If we run our server and make a `GET` request to `/download`, the server will crash since there is no `index.html` file to send. We need to rewrite our endpoint and take advantage of the fact that `res.sendFile` supports passing a callback function as a second argument. This callback function will run after the file is sent, or if there is an error in the process of sending the file.

    // note we added the third parameter here: next
    server.get('/download', (req, res, next) => {
      const filePath = path.join(__dirname, 'index.html');
      res.sendFile(filePath, err => {
        // if there is an error the callback function will get an error as it's first argument
        if (err) {
          // we could handle the error here or pass it down to error-handling middleware like so:
          next(err); // call the next error-handling middleware in the queue
        } else {
          console.log('File sent successfully');
        }
      });
    });

Now let’s go add error-handling middleware to our server. We can create the middleware function and then `use` it like any other middleware, or we can do it inline. Below an example of `using` it inline.

    server.use((err, req, res, next) => {
      console.error(err);

      res
        .status(500)
        .json({ message: 'There was an error performing the required operation' });
    });

This middleware will only get called if any other middleware or route handler **that comes before** it has called `next()` with an argument like in the `/download` endpoint above.

The complete code for our server now look like so:

    const express = require('express');
    const path = require('path');

    const server = express();

    server.get('/download', (req, res, next) => {
      const filePath = path.join(__dirname, 'index.html');
      res.sendFile(filePath, err => {
        // if there is an error the callback function will get an error as it's first argument
        if (err) {
          // we could handle the error here or pass it down to error-handling middleware like so:
          next(err); // call the next error-handling middleware in the queue
        } else {
          console.log('File sent successfully');
        }
      });
    });

    server.use((err, req, res, next) => {
      console.error(err);

      res
        .status(500)
        .json({ message: 'There was an error performing the required operation' });
    });

    server.listen(5000);

Open your browser and visit <http://localhost:5000/download>, and the error message coming from our error-handling middleware should display.

##### Challenge

Write a piece of middleware that accepts an object with two properties: `errorCode` and `errorMessage`. Your middleware should respond with different messages based on the `errorCode` provided. If the error code is `1404` return HTTP status code 404 and a `not found` message, if the code is `1500` return a *500* status code and a generic error message.

##### Dig Deeper

-   [Error handling middleware](https://nemethgergely.com/error-handling-express-async-await/)  
    An article on error handling using middleware.

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node API 3 Guided Project Starter Code

[GitHub Repo](https://github.com/LambdaSchool/node-api3-guided)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Node API 3 Project](https://github.com/LambdaSchool/node-api3-project)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Express Middleware for Web PT 18 w/ Jason Maurer](https://youtu.be/7MAoEoyVtkA)**

    Express is a minimalist framework. It doesn’t provide everything out of the box, but using middleware we can add extra functionality to our application. Middleware provide a way to extend the features provided by the Express framework. They are implemented as small functions that handle one aspect of our application. Tasks like authentication and logging are commonly handled by middleware. Another benefit of Middleware is that it provides an easy way to add modularity to our code.

-   [All previous recordings](/archive/FSW/module/recCJjYFEz0i5O5p5)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Write a paragraph (or two) explaining what Express middleware is and what you’d use it for when writing Web APIs.

    When done send your explanation to your PM on Slack.

-   Objective challenge:

    Write a piece of middleware that responds with the message, “Balance is the key, making things even is the secret to success.” It should send an HTTP Status Code 403 (Forbidden) when the client makes a request, and when the seconds value in the server clock is odd. Otherwise, let the request flow through the rest of the middleware queue.

    So if a client makes any request and the server clock is at 11:10:11 or 11:10:13 the request is rejected, but at 11:10:12, or 11:10:14 is not.

-   Objective challenge:

    Write a piece of middleware that accepts an object with two properties: `errorCode` and `errorMessage`. Your middleware should respond with different messages based on the `errorCode` provided. If the error code is `1404` return HTTP status code 404 and a `not found` message, if the code is `1500` return a *500* status code and a generic error message.

-   Guided Project: Node API 3 Guided Project Starter Code

-   Project: Node API 3 Project
