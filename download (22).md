<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Component Side Effects

<span class="lead"> </span>

Side effects in web apps are very common. It’s important to understand what side effects are so we can handle them properly in our components.

**At the end of this module, you should be able to:**

- explain what side effects are in React components
- demonstrate how to sync side effects with state and props using the effect hook
- fetch data from an API using the effect hook
- demonstrate how to clean up side effects in the effect hook

#### Pro Tip

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=M5yZxpyub48), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=7oCm8Ih-ZCA), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=jMa1nnILdNM), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=rCtq5zvWI0Y), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what side effects are in React components

Side effects in web apps are very common. It’s important to understand what side effects are so we can handle them properly in our components.

##### Overview

What are “side effects”? A side effect is anything that affects something outside the scope of the function being executed. Fetching data from an API, timers, logging, and manually manipulating the DOM are all examples of side effects. There are two categories of side effects in React components - those that don’t require cleanup and those that do require cleanup. We will discuss effects which require cleanup later in this module.

A React component without side effects is called a pure component. A component is considered pure if it always renders the same output for the same state and props. Similarly, a side effect is something that can cause a component to return a different output for the same state and props. Pure components don’t have any side effects. React offers us tools for managing side effects so we can avoid bugs and inconsistencies in our app. The effect hook (`useEffect()`) is one of those.

### The Effect Hook

The effect hook tells React that a component needs to run, or execute, some side effect. This hook takes in two parameters. The first is a callback function where we can run the side effect. Let’s take a look at an effect hook that is handling a `console.log` side effect:

    useEffect(() => {
      console.log("Hello from the effect hook!");
    });

Used inside the component, puts the effect function inside the component’s function scope. This gives it access to state, props, and local variables. So we could also do something like this:

    useEffect(() => {
      console.log(props.someProp, stateValueOne);
    });

Here are some basic examples of other common side effects we might see in React Components:

    // Making API calls
    const [user, setUser] = useState();
    const [error, setError] = useState();
    useEffect(() => {
      fetchUserData(userId)
        .then(res => setUser(res.data.user))
        .catch(err => setError(err.response.message));
    });

    // Manipulating the DOM
    const [count, setCount] = useState();
    useEffect(() => {
      document.title = `Count is: ${count}`;
    });

    useEffect(() => {
      console.log("The component has mounted.");
    }, []);

---

#### Learn to demonstrate how to sync side effects with state and props using the effect hook

There are many times when we may only want a side effect to run when certain data changes. Learning how to sync the effect hook with changes in our state or props is essential to handling side effects in the most efficient manner.

##### Overview

In the examples we saw above, the effect hooks used were not synced with any particular pieces of data. Because of that, each of those hooks would run every single time a piece of state or a prop changed. With a lot of side effects, this would be somewhat concerning from a performance standpoint. Or, in the worst-case scenarios, where a side effect causes the state to change, we would find ourselves in an infinite loop and eventually crash our browser 😳.

Luckily we can sync our side effects with state and props changes. We do this by passing in a dependency array as the second argument to the effect hook. Note that this argument is optional. If we don’t pass in an array after the callback function, the effect will fire after every change. Let’s take a look at a data fetch that sets state in our component.

    const [user, setUser] = useState();
    const [error, setError] = useState();
    useEffect(() => {
      fetchUserData(props.userId)
        .then(res => setUser(res.data.user))
        .catch(err => setError(err.response.message));
    });

When this effect fires, it calls either `setUser` or `setError`. That means that one of those pieces of state will change, which would, in turn, cause the effect to fire again, causing the state to change, firing the effect again, and placing us in an infinite loop!

If you look closely at the effect hook, you’ll notice that this effect also relies on another piece of data. That is `props.userId`. As we think about the component that this hook would be in, we can imagine that we only want this effect to fire if that `userId` prop changes, right? We definitely don’t want it to fire if `user` or `error` change! So, that means that we want this effect to sync up with `props.userId` only - nothing else. Let’s go ahead and add a dependency array argument with that particular dependency in the array.

    const [user, setUser] = useState();
    const [error, setError] = useState();
    useEffect(() => {
      fetchUserData(props.userId)
        .then(res => setUser(res.data.user))
        .catch(err => setError(err.response.message));
    }, [props.userId]); // Dependency array added

Now this effect will fire when and only when `props.userId` changes!

But wait, wouldn’t we want this effect to fire when the component first mounts? Yes, definitely. Even with a dependency array added to the effect hook, it will fire when the component mounts, and then only fire when the given dependencies change.

This brings up one last thought. How can we add an effect to our component that we only want to fire off once as the component mounts, and not any other times during the life of the component? Essentially, we would want to tell the effect hook to not synchronize that particular effect with any state/props changes, right? We can solve this by adding the dependency array to the effect hook, but leaving it blank. Let’s set up an effect hook that runs a data fetch side effect that we don’t want to sync with any state/props changes.

    const [data, setData] = useState();
    const [error, setError] = useState();
    useEffect(() => {
      getInitialData()
        .then(res => setData(res.data))
        .catch(err => setError(err.response));
    }, []);

### Summary

Using a dependency array as the second argument in the effect hook, we can tell it with which state or props the effect should be synced. This is a handy guide to use as you begin the build the mental model for this principle:

> … the question is “with which state and props does this effect synchronize with”

    useEffect(fn); // all state and props
    useEffect(fn, []); // no state or props
    useEffect(fn, [these, states, props]);

---

#### Learn to fetch data from an API using the effect hook

A common use case for the Effect Hook is fetching data. Fetching data from an API depends on the API as an external resource, and so it is a side effect. Because of this, we put our axios call inside the effect function.

##### Overview

Now that we know how to sync effects with data, and we know how to avoid infinite loops, let’s take a more in-depth look at fetching data using an effect hook. There are a couple of possible situations we want to look at when fetching data in a component. First is writing an effect that is not synced with any state or props so that it only fetches data once as the component mounts. Next, is writing an effect that makes an API call that could fire again during the life of the component, depending on a piece of state or a prop.

##### Follow Along

#### Fetching Data when a Component Mounts

Let’s fetch a random dog image to render when this component mounts. We’ll do this using the “dogs” API. Open a new sandbox and follow along.

The first thing we’ll do is get our `App` component ready with some state and the proper JSX:

    function App() {
      // Initialize state to hold the image URL
      const [dogPic, setDogPic] = useState("");

      return (
        <div className="App">
          <h1>We Love Puppers</h1>
          <img src={dogPic} alt="a random dog" />
        </div>
      );
    }

Next, we’ll add the effect hook (minus the data fetch logic) with an empty dependency array.

    function App() {
      // Initialize state to hold the image URL
      const [dogPic, setDogPic] = useState("");
      useEffect(() => {}, []); // Not synced with any data, so this effect only fires once

      return (
        <div className="App">
          <h1>We Love Puppers</h1>
          <img src={dogPic} alt="a random dog" />
        </div>
      );
    }

Now we can add the fetch logic. We’ll use Axios here as we’ve previously learned.

    function App() {
      // Initialize state to hold the image URL
      const [dogPic, setDogPic] = useState("");
      useEffect(() => {
        // This axios GET request will return a single image
        axios
          .get("https://dog.ceo/api/breeds/image/random")
          // Which we then set to state
          .then(res => setDogPic(res.data.message))
          // Always include error handling
          .catch(err => console.log(err));
      }, []);

      return (
        <div className="App">
          <h1>We Love Puppers</h1>
          <img src={dogPic} alt="a random dog" />
        </div>
      );
    }

See a working example of the completed example [here](https://codesandbox.io/s/affectionate-chaplygin-9p27c).

### Fetching Data Multiple Times with Synced Effect Hooks

Often, we will want to make the same fetch call multiple times during the life of a component, all based on when certain data changes. It can be tempting to write a function outside of the effect hook that calls an API, then call that function from the effect hook during the mounting stage, and then subsequently call it from a handler function later. Like this:

      const [data, setData] = useState();
      const [query, setQuery] = useState("react");

      // This effect will only fire once when the component mounts
      useEffect(() => {
        fetchData(); // calls an external function that is dependent on state or props ⚠️
      }, []);

      // external function that relies on (or is dependent on) query
      const fetchData = () => {
        axios.get("some/api/endpoint/" + query)
          .then(res => setData(res.data));
      }

      const handleChange = e => {
        setQuery(e.target.value)
        fetchData(); // calls same external function after setting query
      }

      return (
        <>
          <input value={query} onChange={handleChange} />
          ...
        </>
      );
    }

This is not safe, as the effect hook calls `fetchData` which relies on `query`. According to the [React docs](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)

> It’s difficult to remember which props or state are used by functions outside of the effect. This is why usually you’ll want to declare functions needed by an effect inside of it. Then it’s easy to see what values from the component scope that effect depends on.

Let’s put the `fetchData` function inside the effect hook, and sync the hook with `query`:

      const [data, setData] = useState();
      const [query, setQuery] = useState("react");

      // This effect will fire when the component mounts, AND each time "query" is updated! ✅
      useEffect(() => {
        const fetchData = () => {
          axios.get("some/api/endpoint/" + query)
            .then(res => setData(res.data));
        }

        fetchData(); // calls an external function
      }, [query]);


      const handleChange = e => {
        setQuery(e.target.value)
      }

      return (
        <>
          <input value={query} onChange={handleChange} />
          ...
        </>
      );
    }

So, to examine this more closely, we will fetch data from the algolia API based on a query string typed into an input. Again, open a new sandbox to follow along.

To start out, we will have our state and JSX ready.

    function App() {
      const [data, setData] = useState({ hits: [] });
      const [query, setQuery] = useState("react");

      return (
        <>
          <input value={query} onChange={e => setQuery(e.target.value)} />
          <ul>
            {data.hits.map(item => (
              <li key={item.objectID}>
                <a href={item.url}>{item.title}</a>
              </li>
            ))}
          </ul>
        </>
      );
    }

Next, we will add the effect hook, synchronizing the hook to the `query` state, tied into the input.

    function App() {
      const [data, setData] = useState({ hits: [] });
      const [query, setQuery] = useState("react");

      useEffect(() => {}, [query]); // when query changes, fire this effect again

      return (
        <>
          <input value={query} onChange={e => setQuery(e.target.value)} />
          <ul>
            {data.hits.map(item => (
              <li key={item.objectID}>
                <a href={item.url}>{item.title}</a>
              </li>
            ))}
          </ul>
        </>
      );
    }

Finally, we will add the fetch logic.

    function App() {
      const [data, setData] = useState({ hits: [] });
      const [query, setQuery] = useState("react");

      useEffect(() => {
        const fetchData = () => {
          axios
            .get("https://hn.algolia.com/api/v1/search?query=" + query)
            .then(res => setData(result.data));
        };

        fetchData();
      }, [query]);

      return (
        <>
          <input value={query} onChange={e => setQuery(e.target.value)} />
          <ul>
            {data.hits.map(item => (
              <li key={item.objectID}>
                <a href={item.url}>{item.title}</a>
              </li>
            ))}
          </ul>
        </>
      );
    }

See the final sandbox [here](https://codesandbox.io/s/xenodochial-field-h4rfd).

---

#### Learn to demonstrate how to clean up side effects in the effect hook

Network requests, manual DOM manipulations, and logging are some examples of effects that do not require cleanup. In other words, these effects can run and will not cause problems if the component mounts, unmounts, and remounts again. Other effects, however, will continue to execute, even if the component unmounts. Imagine that you write an effect function for a component that doesn’t get cleaned up, then your user navigates back and forth to the component ten times. You now have 10 effect functions all running the same effect over and over again. You’ve increased the power and memory needed to run that function 10x’s! Ahhh! That does not sound good, right? It’s not! This is what we call a _memory leak_.

##### Overview

Perhaps you’ve created a subscription to a chat API to give a live chat functionality to your app. Or, more simply, you’ve added an event listener to the DOM. These are both functions that need to be “cleaned up” when the component is unmounting, so we don’t cause an unnecessary memory leak. Thankfully, the Effect Hook has a built-in way to handle cleanups.

To clean up an effect, we return a function from the effect hook’s callback function, like this:

    useEffect(() => {
      // We write our desired effect as before.
      console.log("The Effect Hook has run.");
      // Returning a function will tell React that you want this
      // code to run when the component unmounts or re-renders
      return () => console.log("The Effect Hook has been cleaned up.");
    });

The returned function is called when the component is unmounting, giving us a place to clean up subscriptions and event listeners.

##### Follow Along

Let’s add an event listener to a function that listens for the mouse position. When the mouse moves, the event listener will update some state with the new mouse position, and the component will render the mouse position state to the DOM. Follow along in a new sandbox.

    const App = () => {
      const [position, setPosition] = useState({ x: 0, y: 0 });

      useEffect(() => {}, []); // We only want to create the event listener once, so this effect will only fire when the component mounts

      return (
        <div>
          {position.x}:{position.y}
        </div>
      );
    };

Now add the event listener with the event listener’s callback function.

    const App = () => {
      const [position, setPosition] = useState({ x: 0, y: 0 });

      useEffect(() => {
        // Add an event listener
        const setFromEvent = e => setPosition({ x: e.clientX, y: e.clientY });
        window.addEventListener("mousemove", setFromEvent);
      }, []);

      return (
        <div>
          {position.x}:{position.y}
        </div>
      );
    };

Finally, return a function from the effect hook to clean up the event listener.

    const App = () => {
      const [position, setPosition] = useState({ x: 0, y: 0 });

      useEffect(() => {
        const setFromEvent = e => setPosition({ x: e.clientX, y: e.clientY });
        window.addEventListener("mousemove", setFromEvent);

        // the function returned here will remove, or "clean up", the event listener
        return () => {
          window.removeEventListener("mousemove", setFromEvent);
        };
      }, []);

      return (
        <div>
          {position.x}:{position.y}
        </div>
      );
    };

See a working example of the completed example [here](https://codesandbox.io/s/long-hill-fg79j).

##### Challenge

Try this out again, but this time with the `resize` event listener. That listener will listen for the browser to change size. So if you set your state with `window.innerHeight` and `window.innerWidth`, then listen for the resizing event to happen and update your state with those same properties, you should be able to render the browser size continuously.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [NASA Photo of the Day](https://github.com/LambdaSchool/nasa-photo-of-the-day)

  Build an app that consumes the NASA API to fetch the Astronomy Photo of the Day. Display the photo and other info on the DOM.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Components Side Effects for WebPT22 w/Ben Schinn](https://youtu.be/T2wgHRkHa6k)**

  Side effects in web apps are very common. It’s important to understand what side effects are so we can handle them properly in our components.

- [All previous recordings](/archive/FSW/module/recKe8PW6ZMwjL1Qg)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Try this out again, but this time with the `resize` event listener. That listener will listen for the browser to change size. So if you set your state with `window.innerHeight` and `window.innerWidth`, then listen for the resizing event to happen and update your state with those same properties, you should be able to render the browser size continuously.

- Project: NASA Photo of the Day
