Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

- [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
- [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
- [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
- [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

- [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
- [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
- [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
- [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

- [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
- [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
- [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
- [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

- [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
- [React Router II](/webannex/module/recYkF1FDilIedmwX/)
- [Form Management](/webannex/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

- [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
- [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
- [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
- [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

- [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
- [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
- [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
- [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

- [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
- [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
- [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
- [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

- [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
- [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
- [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
- [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

- [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
- [React Router II](/webannex/module/recYkF1FDilIedmwX/)
- [Form Management](/webannex/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

- [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
- [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
- [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
- [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Advanced Form Management

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- control forms and form inputs (checkbox, dropdown) in custom forms
- validate user input in forms
- make POST requests to pass data collected from a form to a database

#### Pro Tip

When talking about your journey, don’t focus on things you don’t know yet, focus on what you’ve learned and how quickly.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to control forms and form inputs (checkbox, dropdown) in custom forms

Forms can have many types of inputs, including: radio buttons, check boxes, passwords, file uploads, and more. We want to be able to include all types of inputs in forms to ensure we’re collecting the best data possible.

##### Overview

Until this point we’ve been working primarily with text inputs. Of course, forms can have many types of inputs, including: radio buttons, check boxes, passwords, file uploads, and more. You can view a full list of form input types [here](https://www.w3schools.com/html/html_form_input_types.asp).

Some of input types provide an additional challenge when trying to control forms.

### Checkboxes

#### Set-default

Just like with text inputs you can change the default values of checkboxes from not checked to `checked`. Similarly you can specify a value that

In the example below the box would be checked by default like so:

    <input type="checkbox" name="nameOfChoice" value="1" checked>

Without the `checked` argument, it would look more like this:

    <input type="checkbox" name="nameOfChoice" value="yes">

Here we also changed the value from the number `1` to the string `yes`, but that doesn’t actually change anything for the user, it simply specifies what should be added to the form object.

#### Control Inputs

That brings us to our next point, controlling inputs. Controlling inputs for checkboxes, buttons, and other non-text fields can be funky. If you want non-default values when a field is checked you need to specify them in form setup and this often requires some additional logic.

The following example would create a checkbox that, when checked, would equal `true` and would `handleInputChange` like you learned earlier. We will learn to control the state when we talk about form validation.

    <label>
        Check This Box:
        <input
            name="isGoing"
            type="checkbox"
            checked={true}
            onChange={handleInputChange} />
    </label>

### Dropdown

Dropdown menus are really important for gathering mass data because they insure data quality. This is done with the `<select>` element. Between the `<select>` tags, you’ll place all of the options you want to have in the dropdown menu.

    <form>
      <select id="friends" name="friends">
        <option value="Ross">
        <option value="Rachel">
        <option value="Monica">
        <option value="Phoebe">
        <option value="Chandler">
        <option value="Joey">
      </select>
    </form>

##### Follow Along

Let’s build out a form to gather user information with radio buttons, a checklist, and a dropdown. These are some common data types you might work with in your time as a web developer.

1.  **Set up form.** Using our knowledge from the “form management” module, we’ll first set up a basic form with a single text input, Name.

    return (
    <div className="App">
    {console.log(name)}
    <form>
    <label>
    Name:
    <input type="text" onChange={event => handleChange(event)} />
    </label>
    <button onSubmit={() => handleSubmit()}>Submit!</button>
    </form>
    </div>
    );
    }

    export default App;

1.  **Add Radio Buttons**. Next, we’ll add radio buttons. If we wanted to gather categorical data, like an age range, we might use radio buttons. To make radio buttons all we need to do is add `input` elements with the type `"radio"`. These are, by default, inline elements, so they’ll render nicely in a row.

     <p> Age Range: </p>
              <label>
                13-18
                <input type="radio" onChange={event => handleChange(event)} />
                19-24
                <input type="radio" onChange={event => handleChange(event)} />
                25-39
                <input type="radio" onChange={event => handleChange(event)} />
                40+
                <input type="radio" onChange={event => handleChange(event)} />
                </label>

1.  **Add Dropdown**. Another way to gather categorical data is through a dropdown. Let’s add one here to ask which state the user lives in. For illustration purposes, we’ll only add 5 states, but you could easily use an array and `.map` method to add all 50 states.

    <form>
      <select id="states" name="states>
        <option value="Alabama" />
        <option value="Alaska" />
        <option value="Arizona" />
        <option value="Arkansas" />
        <option value="Colorado" />
      </select>
    </form>

1.  **Add a checklist.** Last but not least let’s play around with a checklist. Checklists are a great way to gather boolean data. For these we simply change the input value to `"checkbox"`. We also need to consider what a check means and set up our form accordingly. In the example below, when the box is checked we update the state of “RSVP” to “yes”,

    <label>
        RSVP:
        <input
            name="isGoing"
            type="checkbox"
            checked={false}
            onChange={handleInputChange} />
    </label>

##### Challenge

Add a non-text field to a project from the form management lessons.

---

#### Learn to validate user input in forms

As our users start typing into our beautiful form we’ve created, they will very often type in the wrong data into the wrong field. Or maybe they will not format the data correctly (think setting up strong passwords, or even typing in a phone number or email). We want to give our users the best user experience by giving them informed feedback when they’ve filled out our form incorrectly. This is done with form validation.

##### Overview

You know when you try to make your password “password” and the form tells you to chose a stronger password? That’s called validation. There are many ways to validate input before you submit the form to a server or other service and they’re all really useful for insuring the quality of data.

One common strategy is to compare the input string to a regular expression model of expected characters and handle the input based on the results of the comparison.

Another popular method is to have a library such as `Yup` handle the validation for us - yup has built in methods to deal with email addresses, passwords, strings, numbers, and more. You can read the full documentation [here](https://github.com/jquense/yup).

### Validating a String

Before we move into the follow along tutorial, lets look at how we could use Yup to validate if an input was a string. This is in a lot of ways the “Hello World” of form validation.

First, you’ll need to install yup with `npm install --save yup`.

Then, we simply declare a schema with `let schema = yup.string();` and test our schema on a new line with `await schema.isValid('hello world');`. This would return “true” since ‘hello world’ is a string.

### Validating a Form

Form validation is slightly more complicated but it follows the same logical pattern. First we declare a schema, then we validate data.

In a forms app, the schema defines what the form looks like. It is kind of like a form outline, telling yup what the existing fields are and how they should be validated. We’ll walk through this process below.

You can always chose to use additional helper libraries, like Formik, to validate forms, but for learning purposes it is best to understand the validation process with just Yup.

##### Follow Along

We’ll start with a Yup login form consisting of an email and password field.

    import React from "react";

    // Basic submit event handler and console.log to confirm form submitted
      const formSubmit = e => {
        e.preventDefault();
        console.log("submitted");
      };

    // Create state for the form values. We will want to update state later on, but for now... empty strings!
      const [formState, setFormState] = useState({
        name: "",
        email: "",
        website: "",
        password: ""
      });

    // Define form elements: email, password and terms/conditions

    function LoginForm() {
      return (
        <form>
          <label htmlFor="emailInput">
            Name
            <input id="emailInput" type="email" name="email" placeholder="Email" />
          </label>
          <label htmlFor="passwordInput">
            Password
            <input id="passwordInput" type="password" name="password" placeholder="Password" />
          </label>
          <label htmlFor="termsInput">
            Do you agree to the terms and conditions?
            <input id="termsInput" type="checkbox" name="terms" />
          </label>
          <button>Submit!</button>
        </form>
      );

To start the validation process, add Yup as a dependency and import it into the component file. In the command line we’ll type:

    npm install --save yup

and in our file:

    import * as Yup from "yup";
    // You may see this as (import Yup from 'yup') in some tutorials, the above method seems less buggy

Next we will define our schema - which is basically a description of what each named field is supposed to look like so that Yup can pass or fail the input. Give it a shape of all the elements in your form. Depending on what you’re trying to validate you give it strings, checkboxes, etc. That might look like so:

    const formSchema = Yup.object().shape({
      email: Yup
        .string()
        .email("Must be a valid email address.")
        .required("Must include email address."),
      password: Yup
        .string()
        .min(6, "Passwords must be at least 6 characters long.")
        .required("Password is Required")
      terms: Yup
        .boolean()
        .oneOf([true], "You must accept Terms and Conditions")
        // required isn't required for checkboxes.
    });

The `formSchema` is a lot like a `propType` definition because you need to tell Yup what shape the data is supposed to take.

The customization part is pretty straightforward. For the `email` field, Yup is looking for a string that looks like an email-pattern, and you need to have this field (it’s `required`).

The `password` schema shows that you expect a string with a minimum of 6 characters. Additionally, the user shouldn’t be able to submit the form without a password.

There are tons of options available in a schema. Look up how to use this powerful tool [here](https://github.com/jquense/yup).

Next up, we’ll create state for the form values. Just like earlier, this is the initial state values for each input in the form.

Next up, state for error messages.

      // State for the error messages
      const [errors, setErrors] = useState({
        email: "",
        password: "",
        terms: ""
      });

We’re going to change the state of the button so that when we’re filling out the form it won’t be able to submit until the validation passes. The forms will submit even if the validation is failing, we’re using the button’s state to disable the button. Ultimately though, the form state still controls wither or not the form can be submitted.

      /* Each time the form value state is updated, check to see if it is valid per our schema.
      This will allow us to enable/disable the submit button.*/
      useEffect(() => {
        /* We pass the entire state into the entire schema, no need to use reach here.
        We want to make sure it is all valid before we allow a user to submit
        isValid comes from Yup directly */
        formSchema.isValid(formState).then(valid => {
          setButtonDisabled(!valid);
        });
      }, [formState]);

The last thing we need to do before validating the form is set up an event handler called `inputChange` and pass in the event parameter. React uses it’s own event system (known as a “synthetic event”). These events are meant to look like normal DOM events, and in the majority of cases we can use them in the same way. However, there are some small inconsistencies. One of those differences is the fact that we can not use the React event object in an asynchronous way on its own. If you plan on using the event object in a callback or a promise resolution you will need to call `.persist()` on your event object before you use it. If you are interested in learning more about why this is the case (it’s actually performance related and a good thing!) you can read about it [here](https://reactjs.org/docs/events.html#event-pooling). Otherwise, just remember to use event.persist() and you will be good.

      const inputChange = e => {
        /* e.persist allows us to use the synthetic event in an async manner.
        We need to be able to use it after the form validation */
        e.persist();

Finally, lets set up our validation. This is probably the trickiest part of form validation. Here, our synthetic event handler holding the forms input data will be tested against our schema from before. Then, we’ll use some conditional logic with `.then` and `.catch` to display error messages or not, and to change the state.

        // yup.reach will allow us to "reach" into the schema and test only one part.
        // We give reach the schema as the first argument, and the key we want to test as the second.
        yup
          .reach(formSchema, e.target.name)
          //we can then run validate using the value
          .validate(e.target.value)
          // if the validation is successful, we can clear the error message
          .then(valid => {
            setErrors({
              ...errors,
              [e.target.name]: ""
            });
          })
          /* if the validation is unsuccessful, we can set the error message to the message
            returned from yup (that we created in our schema) */
          .catch(err => {
            setErrors({
              ...errors,
              [e.target.name]: err.errors[0]
            });
          });

        // Wether or not our validation was successful, we will still set the state to the new value as the user is typing
        setFormState({
          ...formState,
          [e.target.name]: e.target.value
        });
      };

When validation isn’t successful we need to display an error message to the user, letting them know how to fix the problem. For an email that is less than 6 characters, for example, we might want to display “Email must be more than 6 characters.” For this, we’ll **return to our form HTML** and add error messages. Note that the conditional logic below is implemented with the ES6 ternary operator syntax, where a condition is listed with a `?` and we use `:` to separate the conditions like: `condition ? exprIfTrue : exprIfFalse`. You can read more about ternary operators [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator).

    function LoginForm() {
      return (
        <form>
          <label htmlFor="email">
          <input type="email" name="email" placeholder="Email" />
          />
                {errors.email.length > 0 ? (<p className="error">{errors.email}</p>) : null}
          <label htmlFor="password">
          <input type="password" name="password" placeholder="Password" />
          {errors.password.length > 6 ? (<p className="error">{errors.email}</p>) : null}
           <label htmlFor="terms">
            Do you agree to the terms and conditions?
          <input type="checkbox">
          <button>Submit!</button>
          />
        </form>
      );
    }

Next, we will show you how to actually DO something with this beautiful form data in the form of a POST request!

##### Challenge

Add validation to any test field from your Form Management module guided project or challenges.

---

#### Learn to make POST requests to pass data collected from a form to a database

Making elegant and excellent forms is an important skill as a developer, but we have to do something with our data once our users submit it to us. Typically, this is handled by submitting the data from the form to a database. This allows us to persist our data and access it later for use in the application to make our users’ experience better.

##### Overview

When our client applications need to work with data from a server and database, we transmit that data back-and-forth using [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP). This is a protocol that allows communication between web browsers and web servers.

You’ve previously learned how to use a `GET` request, but we’re going to take it a step further today by submitting data to a web server. Within the HTTP protocol, a `POST` request is a [HTTP Request Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). To be precise, it is the method that allows us to “post” (or create) information on a web server. When a user makes a `POST` request, they are adding data to the server’s database.

We’ll look at some examples of how to make a `POST` request by extending the functionality of the form that we built above.

To make our `POST` request to our database, we’re going to bring in [axios](https://www.npmjs.com/package/axios), a promise-based library that makes it easy for us to transmit data to-and-from our web server.

First, we need to install our `axios` dependency. We can do that using npm:

    npm install axios

Now we can write a post request anywhere in our component. Let’s look at the code we’ll write to do this.

First, here’s what an `axios` call looks like for `POST` request:

    const sentData = { data: "Hello World!" };

    axios
      .post("https://yourdatabaseurlgoeshere.com", sentData)
      .then(res => {
        console.log(res.data); // Data was created successfully and logs to console
      })
      .catch(err => {
        console.log(err); // There was an error creating the data and logs to console
      });

Notice that we are calling the `axios` library but using a `.post()` call instead of a `.get()` after it. We then follow that up with a URL passed in as an argument. Unlike the `.get()` requests that you’ve done before, we also pass in the data that we want to send to our web server as the second argument. In this example, the data that we’re sending is our `sentData` variable, which is an object. This would be sent to our web server.

The promise created by `axios` will then resolve into a successful response or reject with an error. We’re using `console.log()`s here, but you will typically write logic inside of `.then()` and `.catch()` that may include:

1.  Setting data into state in your component
2.  Alerting the user to an error
3.  Use the new data to create side effects in your component(s) that modify the interface for your user in some way

For instance, a `POST` request, such as the one above, might return a response (or `res`) like the following:

    {
      error: false,
      data: { data: "Hello World!" },
      message: "Your data was successfully created."
    }

This is just a rough example, and every server works differently. You will need to initially `console.log()` the server’s response to find out what kind of data you’re receiving back in your response. This is super important - always console log the server’s response!

##### Follow Along

Let’s take a look at how we would integrate this `POST` request into our Yup form. In particular, notice what we’re doing in our `handleSubmit` function down towards the bottom:

1.  **Create a new state called `setPost`**. This will be where we’re going to store data on a valid form submit. Once we have the data we’ll work to `console.log` it and display it to the screen.

    // new state to set our post request too. So we can console.log and see it.
    const [post, setPost] = useState([]);

    useEffect(() => {
    formSchema.isValid(formState).then(valid => {
    // console.log(valid);
    setButtonDisabled(!valid);
    });
    }, [formState]);

1.  **Post to a database from `req, res`**. Inside of our form submit event handler, we’re going to add a `post` request with `axios` and update formState. Once form state is filled out, this posts all of the input information to `setPost`.

For all of our examples together we are going to make use of the `reqres` API. This API allows us to make real POST requests to a real server and get real responses. Until you learn to set up your own backend in Unit 4, this will be a powerful development tool. The post to `https://reqres.in/api/users` accomplishes that.

    // this handles what happens when we submit the form. We want to prevent the default
      //form submission from the browser and control what happens when we submit.
      const formSubmit = e => {
        e.preventDefault();
        console.log("submitted!");
        axios
          .post("https://reqres.in/api/users", formState)
          .then(res => {
            setPost(res.data); // get just the form data from the REST api
            console.log("success", res);
          })
          .catch(err => console.log(err.response));
      };

1.  **Display Data**. For our purposes, we’ll just display data to the DOM, instead of doing something with it on a server. For that we will use `JSON.stringify` to display our data in both the DOM and the console.

    /_ displaying our post request data _/
    <pre>{JSON.stringify(post, null, 2)}</pre>

In this example, our axios call to `https://reqres.in/api/users` now runs whenever we submit the form and run the `handleSubmit` function. Our form now takes in user data and, when the user clicks the “submit” button, it will `POST` the user’s data to the webserver.

This `POST` functionality will be reused innumerable times throughout your developer journey, so it will pay to get a handle on how you do post requests now. For further review, feel free to read through the official documentation from [axios](https://github.com/axios/axios).

##### Challenge

Go review your `GET` requests in previous homework assignments and think about how you convert them over to a `POST` request. What code would you change? How would you send your data over HTTP once you’ve converted them? What code do you need to re-write to make this happen? How do your new `POST` requests differ from your old `GET` requests?

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [User Onboarding](https://github.com/LambdaSchool/User-Onboarding)

  Create a form to allow new users to sign up for your service.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Advanced Form Management for WEBPT21 w/ Emily Seibert](https://youtu.be/Awa4TsDfTgM)**

  Advanced Form Management

- [All previous recordings](/archive/FSW/module/recKK5C7wV0WiECfr)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Add a non-text field to a project from the form management lessons.

- Objective challenge:

  Add validation to any test field from your Form Management module guided project or challenges.

- Objective challenge:

  Go review your `GET` requests in previous homework assignments and think about how you convert them over to a `POST` request. What code would you change? How would you send your data over HTTP once you’ve converted them? What code do you need to re-write to make this happen? How do your new `POST` requests differ from your old `GET` requests?

- Project: User Onboarding
