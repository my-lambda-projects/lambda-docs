

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

-   [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
-   [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
-   [Components I](/web2/module/rec847sNXZX9CVDNl/)
-   [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

-   [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
-   [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
-   [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
-   [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

-   [React Router](/web2/module/recd7jGy7tfVkcFlX/)
-   [Form Management](/web2/module/rect081xiYT2cfxGF/)
-   [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
-   [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

-   [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
-   [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
-   [Components I](/web2/module/rec847sNXZX9CVDNl/)
-   [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

-   [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
-   [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
-   [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
-   [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

-   [React Router](/web2/module/recd7jGy7tfVkcFlX/)
-   [Form Management](/web2/module/rect081xiYT2cfxGF/)
-   [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
-   [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# Components II

<span class="lead"> </span>

Now that we have some understanding of what a component is, we can learn to utilize asynchronous JavaScript and Promises to make HTTP requests and get data from a server.

**At the end of this module, you should be able to:**

-   understand and utilize asynchronous Javascript and Promises
-   understand HTTP requests and get data from a server using axios
-   iterate over a list of data received from a server, creating a set of components and adding them to the DOM

#### Pro Tip

Life is a marathon, not a sprint.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=7I3TeN2Sj1k), or enable JavaScript if it is disabled in your browser.

-   [Data Attributes in HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)

    Learn how to read and update data attributes in HTML

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to understand and utilize asynchronous Javascript and Promises

Data attributes give developers another way to hook into the DOM without having to use classes and IDs as a unique way to make selections.

##### Overview

### Asynchronous code

In JavaScript we have the concept of ‘asynchronous’ code. This simply means code that does not run instantly in line. Perhaps the code needs to wait a moment, wait for something to happen, or in the case we will explore today, wait until data comes back from a server. Using asynchronous code can be challenging at first because we need to be able to recognize which code will be asynchronous and which will run instantly. Take the following example, which will run instantly and which will wait to run?

    setTimeout( () => {
        console.log('Hello!');
    }, 1000);

    console.log('Over here!');

Even if you have never seen `setTimeout` before, you probably realized that it will wait a moment to run, where console.log will run instantly. If you run this code in your console you should see `Over here!` print first because setTimeout will wait 1 second (1000 ms) to run.

Asynchronous code is everywhere in Javascript. It is an important concept to begin to understand.

### Promises

We have a few different ways to approach asynchronous code, in the last example we saw the use of callbacks (which you already understand). Other concepts are `async/await` and `Promises`. Today we will be using Promises.

Promises are a design pattern for use when handling asynchronous code in JavaScript. We use them as an alternative to nesting multiple callbacks. You may have heard of a problem called `callback` hell. Promises are a way to avoid this problem.

Implementing promises is not something you’ll need to do very often, especially in front end development. However, understanding how they work under the hood will help you deal with them, for example when requesting data from web servers.

Learning how to handle promises is pretty straight forward. In fact, on a `Promise` object there are really only two methods that we need to use to handle promises `then` and `catch`. For what we’re trying to accomplish in terms of transferring data between our apps and some server somewhere, we will actually be using what is called a `Promise Library`. I want to ensure that you understand that the built in `Promise` object you’re about to see, is **NOT** a promise library, rather it is a feature built into the JavaScript language as of ES6. Now, let’s dig in.

Consider the following code and what it is doing here.

    let time = 0;
    const timeMachine = () => {
      return setTimeout(() => {
        return time += 1000;
      }, 1000);
    };

    timeMachine();
    console.log(time); --> OUTPUTS: 0;

What we have seen here is that at some point in time, the setTimeout function (1 second later) will actually end up manipulating the `time` variable. However, when we `console.log` time we get `0`. The reason for this, is because of the way the `time` variable is defined. It is happening inside of a `setTimeout` block, which waits 1000ms to actually do its thing. This is an important concept to grasp here. *Even though we’ve manipulated the data, we don’t have access to the data that was manipulated quite yet*. In a nutshell this is asynchronous JavaScript.

Ok, so the problem, is that we’re expecting `time` to be equal to `1000` by the time we want to work with it. One way we can solve this is by using Promises. Before we do that let’s figure out what a `promise` is first.

Straight from MDN:

> *A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action’s eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.*

Simply put, a Promise is just that, a promise from the object that it will let us know when it has completed (or errored) what we have asked it to do. A promise can exist in one of three states:

-   `Pending`: a state where the promise is neither rejected nor fulfilled. (this is the state it is in when we first call it)
-   `Fulfilled`: a state where *all’s well* and a resolved value can be used by our code.
-   `Rejected`: a state where *something went wrong* and there is an error that needs to be dealt with.

If the promise succeeds, it will return the value as a parameter into a callback passed into `.then()`. If the promise fails, the callback passed into the `.catch()` runs, taking an error as its argument.

##### Follow Along

Ok that’s a lot of words, now lets see some code.

-   Reminder, we *are* building our own promise here, although you will *not* need to do this on your own today.
        let time = 0;
        const timeMachine = () => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve((time += 1000));
          }, 1000);
        });
        };

Notice here that we’ve now wrapped our `setTimeout` function in a `new Promise` and we’re resolving the addition of the `time += 1000` and passing that resolved result. This allows us to do what we call `promise chaining` when we invoke our `timeMachine` function. Remember that every promise ships with `then and catch` methods and we can use those methods to either receive a `resolved promise` or a `rejected promise`. Lets find out how!

    timeMachine()
        .then(newTime => {
           console.log(newTime); --> OUTPUTS: 1000 
        });

Ok, in the above code, the `thenified` timeMachine invocation is now receiving a callback itself, (this is how all promise chains should look) with some item being received as a parameter. We can chain multiple `thens` together. Inside of each `then` block when/if we return something new, we can be directed into a new `then` block which is really neat. Or maybe we’re `resolving` more than one process, and we want to see the next result in the next `then` block. Lets manipulate the data in the `.then` block we have now, and see what happens when we use another `then`.

    timeMachine()
      .then(newTime => {
        const myTime = newTime / 1000;
        return `${myTime} seconds have passed`;
      })
      .then(newString => {
        console.log(newString); --> OUTPUTS ​​​​​"1 seconds have passed​​​​​"
      });

In our first `then` block we are manipulating the time that is originally being resolved by the `Promise` and then sequentially returning it with some text concatenated onto the time. Because we are returning a value from our first `then` statement, we can now chain on another `then`. And thus we have achieved some promise chaining. This isn’t a terribly useful program at this point. But we’re about to see some power.

Now lets make another function that we can use to return yet another promise. This is where some of the `then chaining` starts to really come in handy. We’re going to have to refactor our code, ONLY where we’re calling `timeMachine`. The function we’re going to write is called `parseTime` and it will receive a `ms` milliseconds parameter that we can use to reject a promise in the future.

    const parseTime = ms => {
      return new Promise((resolve, reject) => {
        const timeString = time / 1000;
        resolve(`${timeString} seconds have passed`);
      });
    };

Ok! Now we’ve offloaded some work from our `then` block into a function that resolves a promise. We can now use it like above, but this time, when we call our `timeMachine` function we’ll pass this `parseTime` function as an argument to our first `then` block.

    timeMachine()
      .then(parseTime)
      .then(timePassed => {
        console.log(timePassed); --> OUTPUTS: "1 seconds have passed​​​​​"
      });

We’ve effectively achieved the same thing, but now we’re chaining promises and their resolves together. This is Promise chaining. Now the last thing we need to cover is a `rejected promise` because up until now all the things have just… worked. That is not the case in the real world, so because of that, we need to learn how to handle rejections. Lets tweak our `parseTime` function so that we can reject a promise instead of resolving a promise that is, if a certain condition matches.

    const parseTime = ms => {
      return new Promise((resolve, reject) => {
        const timeString = time / 1000;
        if (ms > 999) {
          resolve(`${timeString} seconds have passed`);
        } else {
          reject(new Error(`ms is less than 1 second promise rejected!`));
        }
      });
    };

Here’s what’s going to be sweet, when this function actually runs, ms will be 1000. So our condition will resolve the promise, but lets remember where we’re actually using this function.. it’s within a `then` block on the resolve of another promise. If we tweak our `timeMachine` function to resolve under `1000 ms`, we’ll get a rejection. So lets change the `timeMachine` function in such a way that breaks our promise chain so that we can deal with it.

    resolve((time += 999));

Now we should hit our condition, and our promise will then be rejected. So we have a `catch` block for this purpose.

    timeMachine()
      .then(parseTime)
      .then(timePassed => {
        console.log(timePassed); --> OUTPUT: DOES NOT RUN
      })
      .catch(err => {
        console.log(err); --> OUTPUT: ​​​​​[Error: ms is less than 1 second promise rejected!]​​​​​
      });

And that is that! We have successfully built out a promise chain that allows us to see the benefit of writing them in the first place. So now, when you’re dealing with Promises in the future, the `.then` and `.catch` won’t be all that scary! That last part is the part to remember. HOW we handle promises is what is important for us in the future. Not HOW we implement them. We will be using Axios for that and we’re going to teach you what that is soon.

##### Challenge

Using the time machine example you just built, build one more function from scratch that returns a `Promise` that has a setTimeout inside it. In the `.then()` console.log what is resolved from inside the setTimeout.

------------------------------------------------------------------------

#### Learn to understand HTTP requests and get data from a server using axios

Often when building a website or application we need dynamic data. This data is usually stored on a server. We can request data from a server and display it on our site. In this objective we will learn how to request data using HTTP and a library called `axios`.

##### Overview

### HTTP

HTTP is a *network protocol*, a set of rules that govern the way web clients, like a browser, communicate with web servers over the internet.

We, as developers, need to know what HTTP Methods are and how they are used to perform CRUD (Create, Read, Update, Delete) operations on server resources and what HTTP status codes are and what they are used for.

`HTTP Methods` provide a common *language* or nomenclature that the client can use to let the server know what operation it wants to perform.

When a client needs to ask a server for information it should do a GET request specifying a URL that points to the desired resource.

A POST request is used to ask the server to add or *create* new resources.

The method used by the client to ask the server to make changes to specific resources is PUT.

To remove or delete data from the server the client needs to send a DELETE request.

We will see examples of how to use those methods from our React Applications.

`HTTP Status Codes` are used to indicate if a *request* has been successful or not and **why**. The server will set the status code for all responses sent to the client.

### axios

`axios` is a Javascript library. It is used to send HTTP requests to servers. It is *not* necessary to do this, but it makes things much easier. Because all server requests are asynchronous, `axios` uses Promises. Once you get the basic pattern down, `axios` is incredibly easy to use.

To read more you can check out the documentation here: [https://github.com/axios/axiosn](https://github.com/axios/axios)

In this lesson we are only going to concern ourselves with the HTTP GET request, this will allow us to ask a server for data.

We need to start by including some code in our HTML file, this will essentially download axios and allow us to use it in our own javascript file.

We will put the following line in the `head` section of our HTML:

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

Now that we have access to the axios library in our Javascript file we can start to use it. For now we will just use it to request data from a server when we load the page, although we could request that data based on user interaction, or anything really.

`axios` is an object containing many methods, `.get` being one of them. It takes a string as its first argument. This string is the url of the resource we are requesting:

    axios.get(url)

axios.get will return a Promise to us. This tells us that it is busy getting the data and will return in a moment. As with all promises, we will use `.then` and `.catch` to deal with the data.

    axios.get('http://serverlocation.com/data')
        .then( response => {
            // deal with the response data in here
        })
        .catch( err => {
            // deal with the error in here
        })

------------------------------------------------------------------------

#### Learn to iterate over a list of data received from a server, creating a set of components and adding them to the DOM

Once we have the ability to get dynamic data from a server, we can now put all of the pieces together and create dynamic components based on the data received.

##### Overview

Putting everything together we can now build a component function, request dynamic data from a server, build components based on that data, and add those components to the DOM.

Let’s see it in action:

First we will build our component creator function:

    function buttonCreator(buttonTitle){
        let newButton = document.createElement('button');
        newButton.textContent = buttonTitle;
        newButton.classList.add('button');
        
        return newButton;
    }

Next, let’s grab some data. Once we receieve the data we will map over it and create components out of it. Then we can add it to the DOM:

-   One important thing to note is that the data that comes back from the server will be formatted differently for every server. It is good practice to either read the documentation of the server you are using, or inspect the data yourself before attempting to use it. In this example the `response` object will have a key on it called `data` that key will have a value of an array with a list of strings.

    axios.get('http://fakeserver.com/data')
        .then( response => {
            // Remember response is an object, response.data is an array.
            response.data.forEach( item => {
                let button = buttonCreator(item);
                parent.appendChild(button);
            })
        })
        .catch( error => {
            console.log("Error:", err);
        })

And there you have it! We have retrieved data, created new components based on that data, and added them to the DOM!

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Github User Card](https://github.com/LambdaSchool/github-usercard)

    Request data from the Github API and create a component based on the data you get back.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Components II for WebPT22 w/Ben Schinn](https://youtu.be/f_NKm--PjBk)**

    Now that we have some understanding of what a component is, we can learn to utilize asynchronous JavaScript and Promises to make HTTP requests and get data from a server.

-   [All previous recordings](/archive/FSW/module/recd6kDKS6eMapSRq)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Using the time machine example you just built, build one more function from scratch that returns a `Promise` that has a setTimeout inside it. In the `.then()` console.log what is resolved from inside the setTimeout.

-   Project: Github User Card
