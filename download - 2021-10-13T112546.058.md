Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Computer Architecture: Basics, Number Bases

<span class="lead"> </span>

In this module, we will learn the basics of how a computer is constructed and functions. Additionally we’ll practice manipulating numbers in binary and hexadecimal.

The week-long project is an implementation of an emulator for the LS-8 computer.

**At the end of this module, you should be able to:**

- describe the functional components of a CPU
- convert between and understand decimal, binary, and hexadecimal

#### Pro Tip

Keep in mind that anything you put on social media reflects your brand. Consider what is important for you to say and for other people to hear you say, and use this to shape a social media presence that is both professional and authentic to you.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Ae6zRhgMatc), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=umwSs9fNegY), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe the functional components of a CPU

Part of demystifying the black box that is the computer involves learning what the individual components are within it, the composition of those components, and the communication links between them.

We’ll investigate the basics of computers from the ground up. We’ll learn about common boolean operations in hardware, and how components work together to make computation possible.

##### Overview

We’ll walk through several definitions and diagrams of how computers are constructed, including:

- what a CPU word is
- how RAM works
- how different parts of the CPU communicate
- what a CPU instruction is
- what a CPU register is
- what the CPU clock represents
- what the system bus is and what size it is
- how the CPU provides concurrency

##### Follow Along

- **CPU word**: The natural size of a piece of data with which the CPU can interact. Usually written down in the bit “size” of the CPU, i.e., “This is a 64-bit CPU.”

The CPU can quickly perform math and other operations on data of its word size.

It can also work with other size data, though it might not be as speedy about it.

- **Random Access Memory (RAM)**: Your computer needs a place to keep track of variables to run your code. RAM is where these variables are stored.

One way to conceptualize your RAM is like a large bookcase with billions and billions of shelves. Each shelf has a number (like the index of an array). The number of a shelf is called an address. Each shelf in RAM can hold 8 bits (1 byte).

The middleman between your computer’s processor and RAM is the Memory Controller. The Memory Controller can directly access any address in RAM. It can jump between addresses 1 and 10,000 exceptionally quickly.

Your processor also has a series of caches where it can store a copy of the things it has recently accessed in RAM. If your processor asks for the contents of address 500, the memory controller will also send along the contents of the nearby addresses. That way, if the processor requests the contents of address 500, 501, 502, and 503, it will only have to access RAM on the first request, and the nearby addresses can be accessed from the even faster cache. This fact explains why even though the memory controller has direct access to every address in RAM, reading from sequential memory is still quicker than jumping around to different addresses.

- **CPU instruction**: A byte or sequence of bytes in RAM that the computer knows how to interpret and perform actions based on.

There are instructions to do math, like `ADD` and `SUB`, instructions for comparing values like `CMP`, instructions for jumping to other parts of memory like `JMP`, and many more.

The exact instruction names and values vary depending on architecture.

- **CPU register**: The CPU has a fixed, small number of special storage locations built-in. Usually, there are 16 or 32 of these, and they have set names, such as `R0`, `R1`, `R2`, and so on. (Details vary by architecture.)

Think of them like variables you have at your disposal to use with the various instructions.

- **CPU clock**: When they say your CPU is 3.2 GHz, this is what they are referencing. It’s the number of times per second the CPU does some processing.

Each time the clock cycles, the CPU does a bit more work.

Some instructions take one clock cycle to complete, but others might take several.

- **System bus**: A collection of wires on the motherboard between the CPU, memory, and peripherals.

  - The memory bus connects the CPU to RAM.
  - The I/O bus connects the CPU to peripherals.
  - The control bus allows the CPU to precisely say what it wants to do on the bus, e.g., read or write a word or byte.

- **Concurrency** and **Parallelism**: The CPU can do multiple things at once through a variety of mechanisms, including having multiple cores, or other features such as _pipelining_ or _hyperthreading_ (both out of scope for us.)

Additionally, by using interrupts, a single CPU can execute one program for a while (like 50 ms), and then switch to running another program for a while. While not true parallelism, this is how modern operating systems appear to do so much at once.

##### Challenge

- How long does it take the number of transistors on a CPU to double? What is the common name for this rule of thumb?
- Why are registers necessary? Why not just use RAM?
- Why is cache useful?
- What is a CPU word?
- What is the system bus and how wide is it?
- Describe the pins that are on a CPU chip
- What is a CPU instruction?

---

#### Learn to convert between and understand decimal, binary, and hexadecimal

All major programming languages allow the user a method for converting between different number bases. Some number bases are more convenient to use and easier to understand than others in specific circumstances.

Being able to use binary, decimal, and hex effectively in an important skill that can speed development, and help programmers understand existing code and systems that use those number bases.

##### Overview

We’ll see how number bases work, how to count in them, and how to convert between bases.

##### Follow Along

#### On Numbers

It’s important to understand that when you have 12 apples on the table, it’s still the same number of apples regardless of whether or not you say there are “12 apples” (decimal), or “C apples” (hexadecimal), or “1100 apples” (binary).

The _count_ of the number of items doesn’t change just because we refer to it in a numbering system of a different _base_.

In fact, the only place the numbering system matters is when we write down the number someplace (e.g. print it on the screen or write it in source code, etc.). And remember that when you do write it down, the _count_ of what the number refers to remains the same regardless of the base you choose to write it down in.

Re-read the last paragraph for good measure and keep it in mind in the following review.

#### On Bases

The _base_ of a numbering system refers to how many digits the numbering system has. _Decimal_ numbers like we’re used to have 10 digits: 0 through 9. Decimal numbers are _base-10_.

Similarly, _binary_ numbers have two digits: 0 and 1. Binary is _base-2_.

And _hexadecimal_ had 16 digits: 0-9 then A-F. It’s _base-16_.

Rarely you might come across _octal_; it’s _base-8_. (In Unix when you issue a command like `chmod 755` or `chmod 644`, those numbers are octal.)

These different bases have different ways of being represented in JavaScript:

    // All of these represent the number of apples on the table:

    let numA = 12;     // decimal
    let numB = 0xC;    // hexadecimal, leading 0x
    let numC = 0b1100; // binary, leading 0b

    numA === numB === numC; // TRUE!

#### On Binary

In decimal, we have 10 digits, 0-9. Multi-digit numbers have the 1’s place, the 10’s place, and the 100’s place, etc.

E.g. 123 has `1` in the 100’s place, `2` in the 10’s place, and `3` in the 1’s place.

In binary, we only have two digits, 0-1. Multi-digit numbers have the 1’s place, the 2’s place, the 4’s place, the 8’s place, the 16’s place, etc.

It’s convenient, as a developer, to have this sequence of powers of two memorized at least up to 1024:

    1 2 4 8 16 32 64 128 256 512 1024
    2048 4096 8192 16384 32768 65536

These are all powers of 2. 2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8, etc.

Computers find it convenient to represent numbers in base 2 for a variety of reasons. One is that it’s easy to represent as a voltage on a wire: 0 volts is a `0` and 5 volts (or whatever) is a `1`. Another is that you can do boolean logic with `0` being `FALSE` and `1` being `TRUE`.

> _There are 10 kinds of people in the world: those who understand binary and those who don’t._

#### Convert Binary to Decimal

##### In JavaScript:

    // Binary constants:

    let myBinary = 0b101; // 101 binary is 5 decimal

    // Converting a binary string to a Number

    let myValue1 = Number('0b101');

    // or

    let myValue2 = parseInt('101', 2); // base 2

    // All these print 5:
    console.log(myBinary); // 5
    console.log(myValue1); // 5
    console.log(myValue2); // 5

##### By hand:

    +------ 8's place
    |+----- 4's place
    ||+---- 2's place
    |||+--- 1's place
    ||||
    1010

The above example has one 8, zero 4s, one 2, and zero 1s. That is, it has one 8 and one 2. One 8 and one 2 is 10, `8+2=10`, so:

`1010` binary == `10` decimal.

#### Convert Decimal to Binary

##### In Javascript

    // Decimal constants (just like normal)

    const val = 123;

    // Converting a decimal to a binary string

    const binVal = val.toString(2); // convert to base 2 number string

    console.log(`${val} decimal is ${binVal} in binary`);

Note that the result is a string. This makes sense because you already had the number in `val` as a `Number` type; the only other way to represent it is as a `string`.

##### By Hand

This one’s a little trickier, since you have to work the binary-to-decimal conversion backwards.

Example: convert `123` decimal into binary. You have to come up with sum of the powers of two that add up to it.

Start with the highest power of two that’s lower than the number: 64. We know we have zero 128s in the number, because it’s only 123. But there must be a 64 in there.

So let’s put a 1 in the 64s place:

    1xxxxxx     All the x's are unknown

Now we compute `123-64` because we’ve taken the 64 out of there. `123-64=59`. So let’s go to the next power of two down: 32.

59 has a 32 in it, so that must be a 1 in the 32’s place, as well:

    11xxxxx     All the x's are unknown

Then we compute `59-32=27` and go down to the next power of two: 16. There’s one 16 in 27, so that’s a 1 in the 16s place:

    111xxxx     All the x's are unknown

Then we compute `27-16=11` and do the next power of two: 8. There’s 1 8 in 11, so that’s 1, too:

    1111xxx     All the x's are unknown

Then we compute `11-8=3` and do the next power of two: 4. There are zero 4s in

1.  so that’s a 0 for a change:

    11110xx All the x’s are unknown

We’re still at 3 decimal, but we drop to the next power of two: 2. There is one 2 in 3, so that’s a 1:

    111101x     All the x's are unknown

And we compute `3-2=1`, and drop to the last power of two: 1. There is one 1 in 1, so that’s a 1:

    1111011 binary is 123 decimal

#### Hexadecimal

Hex is a base-16 numbering system. It has 6 more digits than decimal (which is base 10). These 6 digits, which come after 9, are A, B, C, D, E, and F.

Counting to decimal 16 in hexadecimal goes like this:

    0 1 2 3 4 5 6 7 8 9 A B C D E F 10

You might have already seen hexadecimal numbers in CSS colors, such as `#ccff00`.

### Converting Binary to Hex

Fortunately, since 16 and 2 are powers of two, there are an even number of binary bits per hex digit: 4 bits per hex digit.

So if we have a 1-byte number, like `01101100`, we split it in segments of 4 bits and convert each of those to a hex digit. It might be more convenient to convert do decimal first for numbers over 9 decimal.

    00111100

split into sequences of 4 bits.

    0011 1100

convert to hex (or decimal then hex, if more convenient):

    0011 1100
     3    C      (C hex == 12 decimal == 1100 binary)

So `0b00111100` is equivalent to `0x3c`. (Hex constants are written with a leading `0x` in JS, C, and many other languages.)

Converting hex to binary is the same in reverse. 4 bits per hex digit.

##### Challenge

- Count to `0x20` in hex

- What is `0x2F` in binary?

- Convert `0b11011` to decimal

- What is `0b11100111` in hex?

- What is `27` in binary?

- Write a program that outputs a value in binary. Hint: `>>` and `&`

##### Dig Deeper

- [Ars Technica: Gangnam Style overflows INT_MAX, forces YouTube to go 64-bit](https://arstechnica.com/information-technology/2014/12/gangnam-style-overflows-int_max-forces-youtube-to-go-64-bit/)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [LS-8 Emulator Multiply](https://github.com/LambdaSchool/Computer-Architecture)

  ##### Step 0: IMPORTANT: inventory what is here!

  - Make a list of files here.
  - Write a short 3-10-word description of what each file does.
  - Note what has been implemented, and what hasn’t.
  - Read this whole file.
  - Skim the spec.

  ##### Step 1: Add the constructor to `cpu.py`

  Add list properties to the `CPU` class to hold 256 bytes of memory and 8 general-purpose registers.

  > Hint: you can make a list of a certain numeber of zeros with this syntax:
  >
  >     x = [0] * 25  # x is a list of 25 zeroes

  Also add properties for any internal registers you need, e.g. `PC`.

  Later on, you might do further initialization here, e.g. setting the initial value of the stack pointer.

  ##### Step 2: Add RAM functions

  In `CPU`, add method `ram_read()` and `ram_write()` that access the RAM inside the `CPU` object.

  `ram_read()` should accept the address to read and return the value stored there.

  `raw_write()` should accept a value to write, and the address to write it to.

  > Inside the CPU, there are two internal registers used for memory operations: the _Memory Address Register_ (MAR) and the _Memory Data Register_ (MDR). The MAR contains the address that is being read or written to. The MDR contains the data that was read or the data to write. You don’t need to add the MAR or MDR to your `CPU` class, but they would make handy paramter names for `ram_read()` and `ram_write()`, if you wanted.

  We’ll make use of these helper function later.

  Later on, you might do further initialization here, e.g. setting the initial value of the stack pointer.

  ##### Step 3: Implement the core of `CPU`’s `run()` method

  This is the workhorse function of the entire processor. It’s the most difficult part to write.

  It needs to read the memory address that’s stored in register `PC`, and store that result in `IR`, the _Instruction Register_. This can just be a local variable in `run()`.

  Some instructions requires up to the next two bytes of data _after_ the `PC` in memory to perform operations on. Sometimes the byte value is a register number, other times it’s a constant value (in the case of `LDI`). Using `ram_read()`, read the bytes at `PC+1` and `PC+2` from RAM into variables `operand_a` and `operand_b` in case the instruction needs them.

  Then, depending on the value of the opcode, perform the actions needed for the instruction per the LS-8 spec. Maybe an `if-elif` cascade…? There are other options, too.

  After running code for any particular instruction, the `PC` needs to be updated to point to the next instruction for the next iteration of the loop in `run()`. The number of bytes an instruction uses can be determined from the two high bits (bits 6-7) of the instruction opcode. See the LS-8 spec for details.

  ##### Step 4: Implement the `HLT` instruction handler

  Add the `HLT` instruction define to `cpu.h`.

  In `run()` in your switch, exit the loop if a `HLT` instruction is encountered, regardless of whether or not there are more lines of code in the LS-8 program you loaded.

  We can consider `HLT` to be similar to Python’s `exit()` in that we stop whatever we are doing, wherever we are.

  ##### Step 5: Add the `LDI` instruction

  This instruction sets a specified register to a specified value.

  See the LS-8 spec for the details of what this instructions does and its opcode value.

  ##### Step 6: Add the `PRN` instruction

  This is a very similar process to adding `LDI`, but the handler is simpler. See the LS-8 spec.

  _At this point, you should be able to run the program and have it print `8` to the console!_

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Computer Architecture: Basic Number Bases for CSPT8 w/Artem Litchmanov](https://youtu.be/9Pyi64vlqgQ)**

  Basic Number Bases

- [All previous recordings](/archive/CS/module/recsuJbrrFgbFUCRX)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:
  - How long does it take the number of transistors on a CPU to double? What is the common name for this rule of thumb?
  - Why are registers necessary? Why not just use RAM?
  - Why is cache useful?
  - What is a CPU word?
  - What is the system bus and how wide is it?
  - Describe the pins that are on a CPU chip
  - What is a CPU instruction?
- Objective challenge:

  - Count to `0x20` in hex

  - What is `0x2F` in binary?

  - Convert `0b11011` to decimal

  - What is `0b11100111` in hex?

  - What is `27` in binary?

  - Write a program that outputs a value in binary. Hint: `>>` and `&`

- Project: LS-8 Emulator Multiply
