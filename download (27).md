<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# cypress.io

<span class="lead"> </span>

In this module you will learn about testing. Writing good, quality code isn’t possible without tests. It’s simply too difficult to catch every error on your own. In your careers, you’ll be expected to write and understand different types of testing in order to speed up your work flow, prevent bugs, and integrate systems.

The visual testing application, cypress, is a great place to start learning about testing principles in general.

**At the end of this module, you should be able to:**

- define what end-to-end testing is and explain its importance
- use the Cypress GUI to write tests and interact with Elements
- use Cypress to test controlled input
- run all tests in without any UI

#### Pro Tip

Listen to and learn from the opinions of others. Diverse ideas lead to a better all-around solution.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=dr10Z-HpsCQ), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=VvLocgtCQnY), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to define what end-to-end testing is and explain its importance

##### Overview

Writing good, quality code isn’t possible without tests. It’s simply too difficult to catch every error on your own. In your careers, you’ll be expected to write and understand different types of testing in order to speed up your work flow, prevent bugs, and integrate systems. There are four types of tests JavaScript developers write and the tests work together to help diagnose problems.

It’s worth noting that these designations are really just words developers use to communicate their ideas—there aren’t major syntactical differences between different types of tests like there are with frameworks or languages. Instead, the classifications have more to do with scope, cost, and speed. In short, all testing, in all forms, simply automates manual processes. We’ll examine each of these types below, and focus on End to End (E2E) testing in our lesson today.

### Static

Static tests catch typos and errors as you write your code. If you have any type of debugging software in your IDE, it is running static tests.

### Unit

Unit testing verifies that individual, isolated parts of your code (like functions) work as expected. For example, unit testing can verify that a return is of a certain type or that a particular string or image is rendered on a page.

### Integration

Integration testing works to test several units at one time - verifying that they work together as expected. For example, if you have a function that relies on the output of another function, you might write an integration test to confirm that they’re working together as expected. For example, you might simulate a user action to enter login credentials and submit a form, then _verify_ that the submission links a user to a new page. Here, you’re not testing the full app, but not testing just one function, either.

### End to End

As you might imagine, end to end testing looks at the entire user experience, from… end to end. End to end testing basically asks “can a user accomplish an action?”. End to end tests focus on UI and mimic how a user might interact with an app, simulating real events like button clicks, scrolls, form submits, and the like. You can picture end to end tests like imaginary friends, who use your app and point out all the non-intuitive parts, or bugs that a user would encounter while using your website.

In this module we’ll focus on end to end testing using a tool called cypress. Eventually, only ~10% of the tests you run will be end to end tests. Given their visual nature, and focus on UI, E2E tests are a great place to start if you’re new to testing.

### Arrange, Act, Assert

All testing, of all kinds uses the framework “arrange, act, assert” where a test is written to do the following.

1.  **Arrange** - Set up a webpage, form input, etc.
2.  **Act** - Simulate a user action, like a button click or form input.
3.  **Assert** - Verify that the simulated user action resulted in the expected output.

##### Follow Along

Consider the examples below and classify each as `End to End` or `other` type of testing.

### Example 1

> A test that loads a web page and simulates user sign up, log in, and navigation processes.

This is an example of an end to end test because it simulates an entire user experience.

### Example 2

> A tool that debugs a js file, highlighting locations that are missing semi-colons, parentheses, and other syntax.

This is _not_ an example of E2E testing, even though it focuses on a whole file, because it works at the static-test level to catch typos and errors as you write code.

### Example 3

> A test which mimics a user filling out a registration form to verify that the user can submit a username and password on a button click.

This is a tricky one because it’s one of those places where the line between integration testing and unit testing is blurry. It’s important to remember that all of these tests are important in their own way. There is a different tool for every job, and a different test for every code. As Kent Dobbs says, “All I’m interested in is whether I’m confident that when I ship my changes, my code satisfies the business requirements.” This confidence, ultimately, is the end goal.

##### Challenge

Think of an example from your experience where writing an end to end test would have been helpful in your development process. Write a sentence or two explaining how you see testing being useful in this situation and send it to your TL.

##### Dig Deeper

- [Highly Recommended: Unit vs. E2E tests](https://kentcdodds.com/blog/unit-vs-integration-vs-e2e-tests)

---

#### Learn to use the Cypress GUI to write tests and interact with Elements

##### Overview

Cypress is an awesome testing tool for unit, integration, and E2E tests. Coincidentally it is also great for learning, thanks to its visual, guided user interface (GUI). Like React, Cypress is written in a way that is easy to understand, using English language functions like `visit(url)` and `fire(event)` that make syntactic coding easier.

In traditional end to end testing, developers have to use and chose from a variety of frameworks, assertion libraries, wrappers, and more. Cypress was designed as an “all-in-one” testing framework where tests can be written in a single language (JavaScript) and run graphically in a browser.

In this objective we’ll focus on creating simple tests and interacting with browser elements through the cypress GUI.

### Install and Run Cypress

Before we start to use Cypress in a project we can install and open Cypress in terminal to view some example tests.

We can install Cypress with the following command in terminal:

    npm install --save-dev cypress

Once it’s been installed we can open Cypress with this command:

    npx cypress open

Opening Cypress for the first time you’ll see a list of example tests. We recommend you run though these examples on your own by clicking `Run all specs`.

When you do this you will visually see user simulations animated on a webpage in your browser as the tests are run. On the left hand side you can view test names and pass/fail icons while on the right you can view simulated user `actions` (remember our arrange/act/assert framework!).

![cypress GUI](https://i.imgur.com/J7kTDax.gif)

While it is maybe somewhat interesting to watch these tests run, our goal here is to write and run our own tests. In order to do that, we’ll practice by creating some really simple tests within an existing project folder.

### Testing structure

Syntactically, testing in Cypress looks something like this: Every test will start with a `describe` higher order function, and will accept a test as a callback function. Within the callback function there will be some `it` statement, as well as actions and assertions. We’ll get into those more in the next objective. Here, we’ll use simple `expect` assertions and `visit` actions which work exactly as you’d expect!

`cy.visit()` will simulate a user visiting a page.

`expect()` will verify if some expectation is met. (More on both below.)

    describe('Name Test', function () {

        it('Explain what it does', function() {

            // actions and assertions go here
        })
    })

### Interacting with elements

Just like we can inspect elements in a browser, we can use the selector playground to show the code needed to interact with certain elements.

![selector playground](https://i.imgur.com/kfbNxpv.gif)

When we go to write more useful tests, we’ll use this often to grab components on a page.

We’ll walk through the specifics of these steps during the tutorial portion of this objective, but the basic flow of Cypress testing follows the same `Arrange, Assert, Act` framework that you learned above.

##### Follow Along

### We do

For the next few objectives we’ll be working inside of your most recent `fun bus` project directory.

#### Set up Project

1.  Install cypress locally with `npm install --save-dev cypress`. You’ll notice 5k+ changes to your working directory in git but this is just Cypress installing all of its dependencies.
2.  Since there is no `package.json` file in our fun bus example, we’ll need to create one. Then, we’ll add the following code to our new file:

    { "scripts":
    { "cypress:open": "cypress open"
    };
    }

3.  Run `npm run e2e` in terminal which will create a cypress.json file and a cypress folder within your website directory. Inside the cypress folder you’ll find four more folders, including the example files we looked at earlier.
4.  To write our own tests we’ll need to create a new test file. You can call it anything you want but best practices suggest that the file name should match the function of the test. In this case, the file name would be `sample_test.js`.
5.  From the cypress GUI, click on the file `sample_test.js` to run in browser. ![Screen Shot 2020-02-24 at 11.41.00 AM](https://i.imgur.com/y8GUutK.png)
6.  At this point you should see the `No tests found` error message as well as the default blank page. We would need to tell Cypress to load a page in order to see our actual html displayed. ![No Tests Found](https://i.imgur.com/B2as22i.png)

### My First Test

Now, let’s return to that `sample_test.js` file and write a very basic test. For set up purposes we can write a test called `My First Test` and check to see if true equals true; this will always pass.

    //arrange
    describe('My First Test', function () {
    //act
        it('Does not do much', function() {
    //assert
            expect(true).to.equal(true);
        })
    })

### My Second Test

Until this point we’ve been running tests on the default blank page. If we want to run tests on our own `index.html` file, we need to add the action `visit` into the `// act` portion of our test.

1.  In order to do this we’ll need to add a base URL to cypress.json file. You should use the format “http://localhost:8080/” such that the addition looks something like the below. Note that you can visit a URL without setting the baseURL, but then you would need the full file path in `cy.visit()`. That said, using `localhost:8080` is considered a best practice because it prevents an annoying automatic default refresh that happens under the hood.

    {
    "baseUrl":"http://localhost:8080/"
    }

1.  Now that a baseUrl exists, you can run a second test to load your index.html page with `cy.visit()`.

    describe('My Second Test', function () {
    //Arrange
    it('Visits a new site', function() {
    // Act
    cy.visit("index.html");
    })
    })

The example below shows what these tests will look like if successful for our favorite example, the fun bus.

![Screen Shot 2020-02-24 at 11.50.50 AM](https://i.imgur.com/vHNvyOj.png)

These might seem boring, but you’ve just practiced with important syntax and testing principles. We’ll write more complicated tests in the next section.

##### Challenge

Set up Cypress testing in a module challenge of your choosing. Run two tests:

1\) to confirm that `true === true`. 2) to confirm that your index.html file will load locally.

##### Dig Deeper

- [Cypress.io](https://www.cypress.io/)
- [Cypress Documentation](https://docs.cypress.io/guides/overview/why-cypress.html#In-a-nutshell)

---

#### Learn to use Cypress to test controlled input

##### Overview

### Interacting with Elements

The tests covered in the previous objectives are basically the simplest possible tests we can run. More practically, we’ll want to test how a user interacts with the webpage such that we don’t have to manually click around a page looking for bugs. To do that, we’ll use a variety of cypress actions and assertions.

#### Actions

We will primarily use Cypress to test wither or not user actions give the returns we expect them to. Actions in Cypress (or any testing library) are designed to simulate user actions like a click event, a double click event, a scroll, or a checked box which are all things we’ve been working with in this unit.

#### Visibility

Another important test we’ll run is visibility, which are tests to check whether or not an element is hidden. Visibility tests can be chained with the actions above to see how elements appear and disappear depending on user actions.

In addition to actionability and visibility, Cypress allows us to test scrolling, covering, Readonly, animations, and more. You can view a full list of actions and read more about them in the [Cypress documentation](https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Actionability).

### Best Practices

The following cheat sheet of best targeting elements is taken directly from the Cypress documentation. It is rare to get this kind of best practice guidance directly from the developers of a language; it gives us insight into the best way to write our tests.

<table><thead><tr class="header"><th>Selector</th><th>Recommended</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>cy.get(‘button’).click()</td><td>❌Never</td><td>Worst - too generic, no context.</td></tr><tr class="even"><td>cy.get(‘.btn.btn-large’).click()</td><td>❌Never</td><td>Bad. Coupled to styling. Highly subject to change.</td></tr><tr class="odd"><td>cy.get(‘#main’).click()</td><td>⚠️Sparingly</td><td>Better. But still coupled to styling or JS event listeners.</td></tr><tr class="even"><td>cy.get(‘[name=submission]’).click()</td><td>⚠️Sparingly</td><td>Coupled to the name attribute which has HTML semantics.</td></tr><tr class="odd"><td>cy.contains(‘Submit’).click()</td><td>✅Depends</td><td>Much better. But still coupled to text content that may change.</td></tr><tr class="even"><td>cy.get(‘[data-cy=submit]’).click()</td><td>✅Always</td><td>Best. Isolated from all changes.</td></tr></tbody></table>

### Assertions

After we set up the simulated user actions we will want to test that some expectation has been met: text has rendered on the page, a new page has loaded, etc. We’ll do this using assertions.

The most common assertion is`.should()`: we’ll assert that some element _should_ contain some content or do a specific thing. Since Cypress code syntax is English-like, let’s look at an example which tests that a link navigates to a new page.

    describe('Link Navigation', function() {
      it('Asserts that the words instagram.com link to instagram.com', function() {
        cy.visit('index.html')

        cy.contains('Instagram.com').click()

        // Should be on a new URL which includes '/commands/actions'
        cy.url().should('include', 'instagram.com/')

We saw `.contains()` in the example above. This will check if the selected element contains some specified content (like text or an image). Contains is a little tricky because it can also be used in either the `assertion` or `action` phase of your test. Contain can be used in place of id selectors to select elements based on text. For example, you could use `cy.contains('submit').click()` to simulate a user clicking a submit button, or `cy.contains('Instagram.com')` to grab any element containing the text Instagram.com, as we did above. We’ll use contains as an assertion below.

##### Follow Along

Let’s write a real test to actually test DOM elements.

1.  **Arrange** - First, we need to set up our test with a name and function declaration. As covered in the previous objectives, this is where we describe what the test will do.

    describe('Header Text', function() {
    it('Checks if header text exists', function () { })
    })

1.  **Act** - Next we need to act. Our action here will simply be loading up the page with `cy.visit()`.

    describe('Header Text', function() {
    it('Checks if header text exists', function () {
    cy.visit("index.html");
    })
    })

1.  **Assert** - Finally, we’ll grab the header element of interest and assert that it contains the text “Fun Bus” with `cy.get('.logo-heading').contains('Fun Bus');`.

    describe('Header Text', function() {
    it('Checks if header text exists', function () {
    cy.visit("index.html");
    cy.get('.logo-heading').contains('Fun Bus');
    })
    })

### Failing Test

A test will fail when the expectation, or assertion, is false. In our example above, if the logo-heading file doesn’t contain the given text, the test would fail. To illustrate how these work, we could change the `.contains()` text to “Fun Bus!” and, as expected, the test would time out because it can’t find what it’s looking for.

    //Test will fail because header text does not contain the full string

    describe('Header Text', function() {
        it('Checks if header text exists', function () {
            cy.visit("index.html");
            cy.get('.logo-heading').contains('Fun Bus!');

        })
    })

![Screen Shot 2020-02-24 at 12.46.39 PM](https://i.imgur.com/yjINQg6.png)

##### Challenge

Write a test on your chosen module challenge using an assertion that we did **not** cover above - get inspired in the documentation [here](https://docs.cypress.io/guides/references/assertions.html#Chai).

---

#### Learn to run all tests in without any UI

##### Overview

Cypress’ GUI is great, but sometimes its nice to be able to run tests right in the console, without having to navigate away from your code editor. When making small changes this can be especially useful.

Thankfully, cypress tests can be run straight from the terminal with `npx cypress run` + `filename`.

### Cypress run

`cypress run` is the command to run all cypress tests. By default, this command will run all tests, including the example tests. There are a plethora of options that we can add in order to tailor the command to our needs. A full list of these options can be found in the documentation, but the most important for us is `--spec`.

#### `--spec`

`--spec` or `-s` will _specify_ which tests to run. So, `npx cypress run --spec "cypress/integration/sample_test.js"` will run only the tests in the `sample_test.js` file.

You can specify multiple files by separating filenames with a `,` all inside of the quotation marks.

### Other Commands

The `cypress run` command is by far the most commonly utilized but `cypress open`, `cypress verify`, `cypress version` and `cypress cache` are all accepted as valid.

<table><thead><tr class="header"><th>command</th><th>purpose</th></tr></thead><tbody><tr class="odd"><td>open</td><td>Opens the Cypress Test Runner in interactive mode.</td></tr><tr class="even"><td>verify</td><td>Verify that Cypress is installed correctly and is executable.</td></tr><tr class="odd"><td>version</td><td>returns package version and binary version for debugging (rarely used)</td></tr><tr class="even"><td>cache</td><td>view or clear cache</td></tr></tbody></table>

##### Follow Along

All we need to do in order to run tests on our fun bus page is use the command `npx cypress run --spec "cypress/integration/sample_test.js"`

![CLI tests](https://i.imgur.com/3RZCcRr.gif)

##### Challenge

Run the tests you created in previous objectives in terminal.

##### Dig Deeper

- [Cypress CLI Documentation](https://docs.cypress.io/guides/guides/command-line.html#How-to-run-commands)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Cypress Testing](https://github.com/LambdaSchool/Cypress-Testing)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Cypress.io for WebPT22 w/Keiran Kozlowski](https://youtu.be/MbjiVqdf0FI)**

  In this module you will learn about testing. Writing good, quality code isn’t possible without tests. It’s simply too difficult to catch every error on your own. In your careers, you’ll be expected to write and understand different types of testing in order to speed up your work flow, prevent bugs, and integrate systems. The visual testing application, cypress, is a great place to start learning about testing principles in general.

- [All previous recordings](/archive/WEB2/module/recduYpjgZBQaQM8X)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Think of an example from your experience where writing an end to end test would have been helpful in your development process. Write a sentence or two explaining how you see testing being useful in this situation and send it to your TL.

- Objective challenge:

  Set up Cypress testing in a module challenge of your choosing. Run two tests:

  1\) to confirm that `true === true`. 2) to confirm that your index.html file will load locally.

- Objective challenge:

  Write a test on your chosen module challenge using an assertion that we did **not** cover above - get inspired in the documentation [here](https://docs.cypress.io/guides/references/assertions.html#Chai).

- Objective challenge:

  Run the tests you created in previous objectives in terminal.

- Project: Cypress Testing
