

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Introduction to Relational Databases

<span class="lead"> </span>

The modern world runs on data. Our every day life is dependent on the data in our devices.The places we shop, the work that we do, all of it is data-driven. Computers and devices that do anything useful have some type of data persistence.

Out of all the technologies used to save and retrieve that data, Relational Databases is king. Learning how relational databases work and how to write `Structured Query Language (SQL)` to communicate with **Relational Database Management Systems** is a well sought out skill by companies of all sizes and a great tool to have in your arsenal.

On this lecture we will cover the following topics:

-   Introduction to Relational Databases
-   The basics of Structured Query Language (SQL)
-   Select, Insert, Update, and Delete queries in SQL
-   Setup for Knex.js
-   Select, Insert, Update, and Delete queries using Knex

**At the end of this module, you should be able to:**

-   explain what a Relational Database is and its core components
-   explain what SQL is and its advantages
-   query, insert, and modify data in SQL
-   write database queries using knex.js

#### Pro Tip

Life is a marathon, not a sprint.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=cd7Yio-D7qM), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=h-migT0FtvU), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Q-7hlnXK1gU), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=OFLPJfCNAS0), or enable JavaScript if it is disabled in your browser.

-   [Overview of SQL](https://www.w3schools.com/sql/default.asp)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what a Relational Database is and its core components

Databases are everywhere. They drive all businesses and our own lives. The contact list in your mobile device, the appointments on your calendar, be it a pen and paper calendar or a digital one in your computer or other electronic devices. That’s right! A database can be analog, it doesn’t have to be digital.

In this section we’ll learn what databases are with special attention to electronic databases.

##### Overview

A database is **a collection of data organized for easy retrieval and manipulation**. We’re concerned only with digital databases, those that run on computers or other electronic devices.

Digital databases have been around since the 1960s. Relational databases, those which store “related” data, are the oldest and most common type of database in use today.

### Data Persistence

A database is often necessary because our application or code requires **data persistence**. This term refers to data that is infrequently accessed and not likely to be modified. In less technical terms, the data is going to be safely stored and remain untouched unless intentionally modified.

A familiar example of non-persistent data would be JS objects and arrays, which reset each time the code runs.

### Relational Databases

In relational databases, the data is stored in tabular format grouped into rows and columns (similar to spreadsheets). A collection of **rows** is called a **table**. Each row represents a single record in the table and is made up of one or more **columns**.

These kinds of databases are called relational because a *relation* is a mathematical idea that is equivalent to a table. So relational databases are databases that store their data in tables.

##### Tables

-   Tables organize data in rows and columns.
-   Each row on a table represents one distinct record.
-   Each column represents a field or attribute that is common to all records.
-   Fields should have a descriptive name and a data type appropriate for the attribute it represents.
-   Tables usually have more rows than columns
-   Tables have primary keys that uniquely identify each row.
-   Foreign keys represent the relationships with other tables.

##### Follow Along

Follow along as we use W3School’s SQL Try it to explore tables, rows, and columns.

##### Challenge

Use the internet to research two other types of databases (non-relational) and write a short paragraph for each describing how they are different from relational databases. Send the response to your TL on slack.

##### Dig Deeper

-   [SQL Tutorial](https://www.w3resource.com/sql/tutorials.php)  

------------------------------------------------------------------------

#### Learn to explain what SQL is and its advantages

Structured Query Language is the standard language used to manage databases and the data within them. It is the de facto way to interact with a database.

As a query language, SQL is optimized for the sole purpose of querying data. This means not only optimization in writing queries, but optimization in terms of retrieving data, which is critical in the modern world of big data.

##### Overview

SQL is a standard language, which means that it almost certainly be supported, no matter how your database is managed. That said, be aware the SQL language can vary depending on database management tools. This lesson focuses on a set of core commands that never change. Learning the standard commands is an excellent introduction since the knowledge transfers between database products.

##### Follow Along

The syntax for SQL is English-like and requires fewer symbols than programming languages like C, Java, and JavaScript. It is declarative and concise, which means there is a lot less to learn to use it effectively.

When learning SQL it is helpful to understand that each command is designed for a different purpose. If we classify the commands by purpose we’ll end up with the following sub-categories of SQL:

-   **Data Definition Language (DDL)**: used to modify database objects. Some examples are: `CREATE TABLE`, `ALTER TABLE` , and `DROP TABLE`.
-   **Data Manipulation Language (DML)**: used to manipulate the data stored in the database. Some examples are: `INSERT`, `UPDATE` , and `DELETE`.
-   **Data Query Language (DQL)**: used to ask questions about the data stored in the database. The most commonly used SQL command by far is `SELECT`, and it falls in this category.
-   **Data Control Language (DCL)**: used to manage database security and user’s access to data. This falls into the realm of Database Administrators. Some examples are `GRANT` and `REVOKE`.
-   **Transaction Control Commands**: used for managing groups of statements that must execute as a unit or not execute at all. Examples are `COMMIT` and `ROLLBACK`.

As a developer, you’ll need to get familiar with DDL and become proficient using DML an DQL. This lesson will cover only DML and DQL commands.

##### Challenge

Imagine that you have been contracted to work with a dataset of 10 million entries. The client needs a tool to filter through this data for fast retrieval. They are foolishly insisting you use javascript to perform these operations.

Write a 1 paragraph explanation of why SQL would be a better tool. Use language that a non-technical person would understand. Do any research necessary to support your argument.

Send this to your PM when it is complete.

------------------------------------------------------------------------

#### Learn to query, insert, and modify data in SQL

Four critical SQL commands are **SELECT**, **INSERT**, **UPDATE**, and **DELETE**. This commands allow for basic querying, inserting, and modifying of data. As well, they are the SQL commands necessary for performing CRUD operations on the database level.

##### Overview

The four SQL operations covered in this section will allow a user to **query**, **insert**, and **modify** a database table.

A **query** is a SQL statement used to retrieve data from a database. The command used to write queries is `SELECT`, and it is one of the most used SQL commands.

The basic syntax for a `SELECT` statement is this:

    select <selection> from <table name>;

To see all the fields on a table we can use a `*` as the `selection`.

    select * from employees;

The preceding statement would show all the records and all the columns for each record for the table employees.

To pick the fields we want to see, we list them separated by commas.

    select first_name, last_name, salary from employees;

The return of that statement would hold all records from the listed fields.

We can extend the capabilities of the `SELECT` command using `clauses` for things like filtering, sorting, pagination, and more.

It is possible to query multiple tables in a single query, but in this section, we only perform queries on a single table. That will be covered in another section.

To **insert** new data into a table, we’ll use the `INSERT` command. The basic syntax for an `INSERT` statement is this:

    insert into <table name> (<selection>) values (<values>)

Using this formula we can specify which values will be inserted into which fields like so:

    insert into Customers (Country, CustomerName, ContactName, Address, City, PostalCode)
    values ('USA', 'Lambda School', 'Austen Allred', '1 Lambda Court', 'Provo', '84601');

**Modifying** a database consists of updating and removing records. For these operations, we’ll use `UPDATE`, and `DELETE` commands, respectively.

The basic syntax for an `UPDATE` statement is:

    update <table name> set <field> = <value> where <condition>;

The basic syntax for a `DELETE` statement is:

    delete from <table name> where <condition>;

##### Follow Along

### Filtering results using WHERE clause

When querying a database, by default, the result will be every entry in the given table. However, often, we are looking for a specific record or a set of records that meets certain criteria.

A where clause can help in both cases.

Here’s an example where we might only want to find customers living in Berlin.

    select City, CustomerName, ContactName
    from Customers
    where City = 'Berlin'

We can also chain together where clauses using `OR` and `AND` to limit our results further.

The following query includes only records that match both criteria.

    select City, CustomerName, ContactName
    from Customers
    where Country = 'France' and City = 'Paris'

And this query includes records that match either criteria.

    select City, CustomerName, ContactName
    from Customers
    where Country = 'France' or City = 'Paris'

These operators can be combined and grouped with parentheses to add complex selection logic. They behave similarly to what you’re used to in programming languages.

You can read more about SQLite operators from [this website](https://www.w3resource.com/sqlite/operators.php).

To select a single record, we can use a `WHERE` statement with a uniquely identifying field, like an id:

    select * from Customers
    where CustomerId=3;

Other comparison operators also work in `WHERE` conditions, such a &gt;, &lt;, &lt;=, &gt;=.

    select * from employees where salary >= 50000

### Ordering results using the ORDER BY clause.

Query results are shown in the same order the data was inserted. To control how the data is sorted, we can use the `ORDER BY` clause; let’s see an example.

    -- sorts the results first by salary in descending order, then by last name in ascending order
    select * from employees order by salary desc, last_name;

We can pass a list of field names to `order by` and optionally choose `asc` or `desc` for the sort direction. The default is `asc`, so it doesn’t need to be specified.

Some SQL engines also support using field abbreviations when sorting.

    select name, salary, department from employees order by 3, 2 desc;

In this case, the results are sorted by department in ascending order first and then by salary in descending order. The numbers refer to the position of the fields in the *selection* portion of the query, so 1 would be *name*, 2 would be *salary* and so on.

Note that the `WHERE` clause should come after the `FROM` clause. The `ORDER BY` clause always goes last.

    select * from employees where salary > 50000 order by last_name;

### Limiting results using the LIMIT clause.

When we wish to see only a limited number of records, we can use a `LIMIT` clause.

The following returns the first 10 records in the products table:

    select * from products
    limit 10

`LIMIT` clauses are often used in conjunction with `ORDER BY`. The following shows us the 5 cheapest products:

    select * from products
    order by price desc
    limit 5

### Inserting data using INSERT

An insert statement adds a new record in the database. All non-null fields must be listed out in the same order as their values. Note that some fields, like ids and timestamps, may be auto-generated and do not need to be included in an `INSERT` statement.

    -- we can add fields in any order, the values need to be in the same ordinal position
    -- the id will be assigned automatically
      insert into Customers (Country, CustomerName, ContactName, Address, City, PostalCode)
      values ('USA', 'Lambda School', 'Austen Allred', '1 Lambda Court', 'Provo', '84601');

The values in an insert statement must not violate any restrictions and constraints that the database has in place, such as expected datatypes. We will learn more about constraints and schema design in a later section.

### Modifying recording using UPDATE

When modifying a record, we identify a single record or a set of records to update using a `WHERE` clause. Then we can set the new value(s) in place.

    update Customers
    set City = 'Silicon Valley', Country = 'USA'
    where CustomerName = 'Lambda School'

Technically the `WHERE` clause is not required, but leaving it off would result in every record within the table receiving the update.

#### Removing records using DELETE

When removing a record or set of records, we need only identify which record(s) to remove using a `WHERE` clause:

    delete from Customers
    where CustomerName = 'Lambda School`;

Once again, the `WHERE` clause is not required, but leaving it off would remove every record in the table, so it’s very important.

##### Challenge

Write queries for the following requirements:

-   List the products but only show the product id and the product name.
-   List the employees sorted by the last name in ascending order.
-   Add a new record in the category table
-   Come up with a more creative name for the product “tofu” and update it in the database.
-   Delete a single record for the “employees” table.

------------------------------------------------------------------------

#### Learn to write database queries using knex.js

We’ll be exploring the **query builder** library of **knex.js**. **knex** allows us to write sql commands using javascript. In this section, we’ll be exploring the basic set up of the library as well as writing the queries for **CRUD** operations on a single resource.

##### Overview

While raw SQL is a critical baseline skill, Node developers generally use an **ORM** or **query builder** to write database commands in a backend codebase. Both **ORMs** and **query builders** are JavaScript libraries that allow us to interface with the database using a JavaScript version of the SQL language.

For example, instead of a raw SQL select:

    SELECT * FROM users;

We could use a query builder to write the same logic in JavaScript:

    db.select('*').from('users');

**Query builders** are lightweight and easy to get off the ground, whereas **ORMs** use an object-oriented model and can provide more heavy lifting within their rigid structure.

Within this sprint, we will use a **query builder** called [knex.js](https://knexjs.org/).

##### Follow Along

### Knex Setup

To use Knex in a repository, we’ll need to add two libraries:

    npm install knex sqlite3

`knex` is our query builder library, and `sqlite3` allows us to interface with a `sqlite` database. We’ll learn more about `sqlite` and other **database management systems** in the following module. For now, just know that you need both libraries.

Next, we use Knex to set up a config file:

    const knex = require('knex');

    const config = {
      client: 'sqlite3',
      connection: {
        filename: './data/posts.db3',
      },
      useNullAsDefault: true,
    };

    module.exports = knex(config);

To use the query builder elsewhere in our code, we need to call `knex` and pass in a `config` object. We’ll be discussing Knex configuration more in a future module, but for now, all we only need the `client`, `connection`, and `useNullAsDefault` keys as shown above. The `filename` should point towards the pre-existing database file which can be recognized by the `.db3` extension.

**GOTCHA**: The file path to the database should be with respect to the **root** of the repo, not the configuration file itself.

Once Knex is configured, we can import the above config file anywhere in our codebase to access the database.

    const db = require('../data/db-config.js);

The `db` object provides methods that allow us to begin building queries.

### SELECT using Knex

In Knex, the equivalent of `SELECT * FROM users` is:

    db.select('*').from('users');

There’s a simpler way to write the same command:

    db('users');

Using this, we could write a `GET` endpoint.

    router.get('/api/users', (req, res) => {
      db('users')
      .then(users => {
        res.json(users);
      }) 
      .catch (err => {
        res.status(500).json({ message: 'Failed to get users' });
      });
    });

**NOTE**: All Knex queries return promises.

Knex also allows for a where clause. In Knex, we could write `SELECT * FROM users WHERE id=1` as

    db('users').where({ id: 1 });

This method will resolve to an array containing a single entry like so: `[{ id: 1, name: 'bill' }]`.

Using this, we might add a `GET` endpoint where a specific user:

    server.get('api/users/:id', (req, res) => {
      const { id } = req.params;

      db('users').where({ id })
      .then(users => {
        // we must check the length to find our if our user exists
        if (users.length) {
          res.json(users);
        } else {
          res.status(404).json({ message: 'Could not find user with given id.' })
       })
      .catch (err => {
        res.status(500).json({ message: 'Failed to get user' });
      });
    });

### INSERT using Knex

In Knex, the equivalent of `INSERT INTO users (name, age) VALUES ('Eva', 32)` is:

    db('users').insert({ name: 'Eva', age: 32 });

The insert method in Knex will resolve to an array containing the newly created id for that user like so: `[3]`.

#### UPDATE using Knex

In knex, the equivalent of `UPDATE users SET name='Ava', age=33 WHERE id=3;` is:

    db('users').where({ id: 3 })
    .update({name: 'Ava', age: 33 });

Note that the `where` method comes before `update`, unlike in SQL.

Update will resolve to a count of rows updated.

### DELETE using Knex

In Knex, the equivalent of `DELETE FROM users WHERE age=33;` is:

    db('users').where({ age: 33}).del();

Once again, the `where` must come before the `del`. This method will resolve to a count of records removed.

##### Challenge

Pick a challenge or guided project from the previous sprint. First, find where Knex is configured. Then find where the Knex queries are written.

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node DB 1 Guided Project

[GitHub Repo](https://github.com/LambdaSchool/node-db1-guided)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Node DB 1 Project](https://github.com/LambdaSchool/node-db1-project)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Introduction to Relational Databases for Web PT 18 with Jason Maurer](https://youtu.be/kQ-bMUtw4d4)**

    The modern world runs on data. Our every day life is dependent on the data in our devices.The places we shop, the work that we do, all of it is data-driven. Computers and devices that do anything useful have some type of data persistence. Out of all the technologies used to save and retrieve that data, Relational Databases is king. Learning how relational databases work and how to write Structured Query Language (SQL) to communicate with Relational Database Management Systems is a well sought out skill by companies of all sizes and a great tool to have in your arsenal.

-   [All previous recordings](/archive/FSW/module/recFG7SqlSCAB8iU7)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Use the internet to research two other types of databases (non-relational) and write a short paragraph for each describing how they are different from relational databases. Send the response to your TL on slack.

-   Objective challenge:

    Imagine that you have been contracted to work with a dataset of 10 million entries. The client needs a tool to filter through this data for fast retrieval. They are foolishly insisting you use javascript to perform these operations.

    Write a 1 paragraph explanation of why SQL would be a better tool. Use language that a non-technical person would understand. Do any research necessary to support your argument.

    Send this to your PM when it is complete.

-   Objective challenge:

    Write queries for the following requirements:

    -   List the products but only show the product id and the product name.
    -   List the employees sorted by the last name in ascending order.
    -   Add a new record in the category table
    -   Come up with a more creative name for the product “tofu” and update it in the database.
    -   Delete a single record for the “employees” table.

-   Objective challenge:

    Pick a challenge or guided project from the previous sprint. First, find where Knex is configured. Then find where the Knex queries are written.

-   Guided Project: Node DB 1 Guided Project

-   Project: Node DB 1 Project
