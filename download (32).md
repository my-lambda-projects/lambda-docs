<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# The Reducer Pattern

<span class="lead"> </span>

The difficulties of storing and efficiently performing logic on data within components becomes more and more apparent as the amount of data increases. Consequently, as components grow and deal with larger sets of data, the storing and transportation of state across the entire application increasingly becomes more and more cumbersome as well. Reducers offer one possible way to address this problem within the component. At the level of the application, an elegant combination of the Context API with reducers provides one possible way that React developers can manage global state.

**At the end of this module, you should be able to:**

- explain what immutability is in programming and demonstrate its benefits
- describe reducer functions
- employ the \`useReducer\` hook to manage state in a component

#### Pro Tip

We all build on the work of others.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=EY8lIHdBA-w), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what immutability is in programming and demonstrate its benefits

Redux is built on the programming principle of immutability. This means that the Redux store cannot be mutated, which will save us from running into more bugs and weird side effects, and will make it easier to reason about our code.

##### Overview

Mutable objects are objects whose state is allowed to change over time. An immutable value is the exact opposite – after it has been created, it can never change. There are some real benefits from making your state immutable. We won’t go over all the benefits here, but a couple we will talk about are predictability and mutation tracking.

#### Predictability

Mutation hides change, which can create (unexpected) side effects. This can lead to some nasty bugs in our code. When we enforce immutability, we can keep our application architecture and mental model simple, which makes it easier to reason about the application. Simply put, it is very easy to predict how the state object will change based on certain actions/events. Without immutability, our state object can be changed or updated in unpredictable ways, causing weird behavior and/or bugs.

#### Mutation Tracking

Immutability makes it really easy to see if anything has changed. For example when we change the state in Redux, our components props will update. We can check our previous props against our new props to know what change occurred, and know how to handle those changes. If a user adds a task to the todo list, the `TodoList` component will update since it is receiving new props. But what if we want to run an animation on the new todo? We can’t just run it on every render because it would run when the user toggles a task to complete, or deletes a task. Since Redux state management is immutable, we can track the changes that happen on the state, and only run our animation when a new task is added.

#### Redux and Immutability

Redux has a single immutable state tree (referred to as the store) where all state changes are explicitly handled by dispatching actions. Dispatched actions are processed by a reducer that accepts the previous state and the action and returns the next state of your application. It is easy to predict how the state tree is going to change based on actions that are dispatched. It is also easy to predict which action will be dispatched based on some event or interaction. This all leads to very predictable state management.

Writing immutable code can be tough - your Javascript skills will really be tested here - and it may seem pretty tedious, especially since we will be building very small apps with small state trees during this sprint. Because of that, it may be pretty hard to see the real benefits of immutable code in class. However, when you start working with a large application, with a huge state tree, you will quickly grow to appreciate the benefits of writing immutable code, and the extra effort it takes will seem much more worth it.

##### Follow Along

Here is a replit that will help you understand mutable code. In the next objective below, we will learn how to write immutable code.

Follow along with the exercises [here](https://repl.it/@snowkid314/understandingMutations)

##### Challenge

Read [this article](https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0). Write a paragaraph or two explaining what you learned. Send that paragraph to your PM.

---

#### Learn to describe reducer functions

The reducer pattern is a great state management pattern that allows us to write pure functions to manage state changes in a predictable manner.

##### Overview

Reducer functions take two arguments – the current state and action – and return a new, updated state object based on both arguments.

In pseudocode, this idea looks like:

        (state, action) => newState

More specifically, consider a function in JavaScript that, when passed an integer, would return that value + 1, without mutating the original integer’s value. Notice we could pass is our initialState value - `0` - and the return a new value - `1` - without overriding the initialState.

    const initialState = 0
    const reducer = (state) => {
      const newState = state + 1
      return newState;
    }

    const newStateValue = reducer(initialState);
    console.log(initialState, newStateValue); // 0, 1

Often, returning something such as an integer or a string is not the best choice, especially as data grows more complex than previous examples.

Consider the previous example, where component’s state utilizes an object as its data structure of choice:

    const initialState = { count: 0 }
    const reducer = (state) => {
      return { count: state.count + 1 }
    }

Again, we are returning a _new_ object and are not directly mutating or overriding the `initialState` object.

This reducer function is a pure function without any side-effects. Reducer functions are the perfect fit for managing changes in state while maintaining the immutability we want in our components.

We’ve discussed the nature of the incoming state value, but what about the action?

The action, represented by an object, contains properties related to some action that happens in our apps. Every action object is required to have a `type` property, which will “inform” the reducer actions happening in the app. The `type` allows the reducer to know what part of the state needs to change.

Let’s look at how we can use this to manage state in our apps.

##### Follow Along

Looking again at reducer above, let’s show it that we want to increment our count state by passing in an `action` with `'increment'` as the type.

    const initialState = { count: 0 }
    const reducer = (state, action) => {
      if (action.type === 'increment') {
        return { count: state.count + 1 }
      }
    }

    reducer(initialState, { type: 'increment' })

This strategy is especially powerful when we want our reducer to be able to _reduce_ the state. Take a look at our reducer now:

    const initialState = { count: 0 }
    const reducer = (state, action) => {
      if (action.type === 'increment') {
        return { count: state.count + 1 }
      } else if (action.type === 'decrement') {
        return { count: state.count - 1 }
      }
    }

    reducer(initialState, { type: 'increment' });
    reducer(initialState, { type: 'decrement' });

Now our state management is _very_ predictable. Our current state passes into the reducer, and an action follows to tell the reducer _how_ to update the state.

We can also add a `payload` property to our action objects (sometimes called `data`). Our reducer needs to have some data passed into it through the action to be able to update the state correctly, and this is where that data would live.

    const initialState = { name: 'Donald Duck' }
    const reducer = (state, action) => {
      if (action.type === 'changeName') {
        // how do we know what to change the name to? The action payload!
        return { name: action.payload }
      }
    }

    reducer(initialState, { type: 'changeName', payload: 'Mickey Mouse' });

As you will see in the follow along, the action, and its associated property `type`, allow us to use the reducer to perform conditional state transformations.

There’s one last edit we need to make to get to production quality. As you can imagine, or `if`, `if else`, `if else` … etc, statements are going to get very complex and long. We’ll use JavaScript’s `switch` statement to make that part of our reducer a lot more readable:

Back to the count example, look at the change here:

    const initialState = { count: 0 }
    const reducer = (state, action) => {
      // if (action.type === 'increment') {
      //   return { count: state.count + 1 }
      // } else if (action.type === 'decrement') {
      //   return { count: state.count - 1 }
      // }
      // we pass in the value we want to look at (action.type):
      switch(action.type) {
        // then we make a "case" for each possible value we expect:
        case 'increment':
          return { count: state.count + 1 };
        case 'decrement':
          return { count: state.count - 1 }
        // finally, we give a "catch-all" which is just to return state untouched. Never leave this out. There should always be a default:
        default:
          return state;
      }
    }

    reducer(initialState, { type: 'increment' });
    reducer(initialState, { type: 'decrement' });

Cleaned up, the reducer now looks like this:

    const initialState = { count: 0 }
    const reducer = (state, action) => {
      switch(action.type) {
        case 'increment':
          return { count: state.count + 1 };
        case 'decrement':
          return { count: state.count - 1 }
        default:
          return state;
      }
    }

    reducer(initialState, { type: 'increment' });
    reducer(initialState, { type: 'decrement' });

(Read more about `switch` statements [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch))

##### Challenge

Create a reducer function that can do the following:

1.  Take in an `initialState` value of an array of objects. Each object should represent a to-do item, and should contain only one property, `description`, which should be a string, a short description of the to-do item.

2.  Take in an action object with a `type` property and a `payload` property. The `payload` property should have a description key and a value equal to a new description entered by a user. (Don’t worry about making inputs now, just write the reducer.)

3.  If the type is equal to ‘ADD’, then return a new array with a shallow copy of the previous state, and spread in a new object that contains the new description key and its corresponding value.

4.  Return the previous state as a default case.

For additional practice, and challenge, how might you implement logic that would contain a type of ‘DELETE’ or ‘EDIT’?

---

#### Learn to employ the \`useReducer\` hook to manage state in a component

Writing reducers from the ground up can end up being a lot of boilerplate and time spent for a React developer. The goal is the make state management _easier_ in components. With that said, the `useReducer` hook provides a nice abstraction that allows a developer to efficiently `use` the power of `reducers` in React components, quite easily.

The React documentation is an excellent resource for information about this hook and something to keep in your collection of references moving forward: [React docs - useReducer](https://reactjs.org/docs/hooks-reference.html#usereducer)

##### Overview

The `useReducer` hook is an alternative to `useState` (`useState` actually uses `useReducer` hook under the hood). It is preferable when you have complex logic that you have to deal with in a component, or when you find yourself with a lot of state properties (more than 3) in a single component. `useReducer`, takes in a `reducer` function (that we build), as well as a value for the `initialState`. Then it returns both the current state and a dispatch method in an array, just like `useState` does.

`const [state, dispatch] = useReducer(reducer, initialState);`

The dispatch method is a significant addition to our arsenal here. It will “dispatch” an action to our reducer when specific events occur in our application. The dispatch allows us to powerfully combine the reducer function from our previous section, with the ability to maintain our state at the level of the component.

The `useReducer` hook has all the functionality we love from the `useState` hook and combines it with the power of the reducers we are building ourselves. In doing so, it provides access to both the state and a function that dispatch actions to our reducer.

##### Follow Along

Let’s build out a component to go along with our counter reducer. Pay attention to the comments in the code that will walk us through this process.

    import React, { useReducer } from 'react'

    const initialState = { count: 0 }
    // Initial count is established

    // We will use the same reducer we created in the previous section
    function reducer(state, action) {
      switch (action.type) {
        case 'INCREASE':
          return { count: state.count + 1 }
        case 'DECREASE':
          return { count: state.count - 1 }
        default:
          return state
      }
    }

    // Create a functional component
    function Counter() {
      // Use the useReducer hook by destructuring its two properties: state, and dispatch and pass in the reducer and the initialState to the useReducer function
      const [state, dispatch] = useReducer(reducer, initialState)

      // Return JSX that displays the count for the user
      // Note the two button elements which allow the user to increase and decrease the count.  Each of them contains an onClick event that dispatches the desired action object, with its given type.  Each action, when fired, is dispatched to the reducer and the appropriate logic is applied.
      return (
        <>
          {/* Note, we have access to the current state and the dispatch method from the useReducer hook, so we can utilize them to display the count as well as couple the dispatching of the actions from the appropriate buttons.*/}
          <div className="count">Count: {state.count}</div>
          <button onClick={() => dispatch({ type: 'INCREASE' })}>+1</button>
          <button onClick={() => dispatch({ type: 'DECREASE' })}>-1</button>
        </>
      )
    }

##### Challenge

Create a component which demonstrates the following MVP expectations and uses a reducer function and the `useReducer` hook to implement the required logic and maintain the state of the component:

1.  User should be able to input a string of text that represents a ‘todo item.’
2.  User should be able to press a button to submit that ‘todo item.’
3.  User should be able to submit a ‘todo item’ and view it on the screen.

For fun, you could go as far as you would like for stretch, but the main goal of MVP here for this mini-exercise, is just to be able to locally maintain a list of strings, entered by a user, by using a reducer function.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Reducer Todo](https://github.com/LambdaSchool/reducer-todo)

  Create a todo list app (I know, I know - but it really is a _great_ pattern to learn a new thing…) that uses the reducer pattern to manage the component state.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[The Reducer Pattern for WebPT18 w/Josh Jacobson](https://youtu.be/RdkEbMxDiA8)**

  Reducers offer one possible way to address this problem within the component. At the level of the application, an elegant combination of the Context API with reducers provides one possible way that React developers can manage global state.

- [All previous recordings](/archive/WEB3/module/rectpk6uIV3pCHJh8)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Read [this article](https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0). Write a paragaraph or two explaining what you learned. Send that paragraph to your PM.

- Objective challenge:

  Create a reducer function that can do the following:

  1.  Take in an `initialState` value of an array of objects. Each object should represent a to-do item, and should contain only one property, `description`, which should be a string, a short description of the to-do item.

  2.  Take in an action object with a `type` property and a `payload` property. The `payload` property should have a description key and a value equal to a new description entered by a user. (Don’t worry about making inputs now, just write the reducer.)

  3.  If the type is equal to ‘ADD’, then return a new array with a shallow copy of the previous state, and spread in a new object that contains the new description key and its corresponding value.

  4.  Return the previous state as a default case.

  For additional practice, and challenge, how might you implement logic that would contain a type of ‘DELETE’ or ‘EDIT’?

- Objective challenge:

  Create a component which demonstrates the following MVP expectations and uses a reducer function and the `useReducer` hook to implement the required logic and maintain the state of the component:

  1.  User should be able to input a string of text that represents a ‘todo item.’
  2.  User should be able to press a button to submit that ‘todo item.’
  3.  User should be able to submit a ‘todo item’ and view it on the screen.

  For fun, you could go as far as you would like for stretch, but the main goal of MVP here for this mini-exercise, is just to be able to locally maintain a list of strings, entered by a user, by using a reducer function.

- Project: Reducer Todo
