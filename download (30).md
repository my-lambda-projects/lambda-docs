

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

-   [Class Components](/web3/module/recnDKrWb24lgaziC/)
-   [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
-   [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
-   [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

-   [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
-   [Redux](/web3/module/recba2NUdVmgKYyR3/)
-   [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
-   [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

-   [Testing React](/web3/module/recS9H6qCj0dQe32B/)
-   [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
-   [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
-   [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

-   [Class Components](/web3/module/recnDKrWb24lgaziC/)
-   [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
-   [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
-   [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

-   [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
-   [Redux](/web3/module/recba2NUdVmgKYyR3/)
-   [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
-   [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

-   [Testing React](/web3/module/recS9H6qCj0dQe32B/)
-   [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
-   [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
-   [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# Composing and Sharing Non-Visual Behavior

<span class="lead"> </span>

**At the end of this module, you should be able to:**

-   define stateful logic
-   apply non-visual behavior (stateful logic) with custom hooks
-   compose hooks in a custom hook to extend multiple pieces of stateful logic

#### Pro Tip

A quick temper will make a fool of you soon enough.

Bruce Lee

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to define stateful logic

As React developers, it’s important to understand everything we can do inside components. Up to this point, we’ve stored and managed data and we’ve rendered elements to the DOM. However, React component often hold a lot of logic as well. We’ve seen examples of this already, but in this module we’ll put a name to it and be able to recognize it so that we can later use it as a very powerful tool when we build React components.

##### Overview

Stateful logic is logic that is built into a component. It can be a function that handles a click event or maybe a function that sets toggle state, or even a function that formats data before it gets displayed. Usually, this kind of logic deals with state in the component. Thus the moniker “stateful logic.”

##### Follow Along

Look at this component. Can you spot the stateful logic built into it?

    import React, { useState } from "react";

    const DynamicTitle = () => {
      const [title, setTitle] = useState("Hooks are so fun!");
      const [inputText, setInputText] = useState("");

      const handleChanges = e => {
        setInputText(e.target.value);
      };

      const changeTitle = e => {
        e.preventDefault();
        setTitle(inputText);
        setInputText("");
      };

      return (
        <div className="Wrapper">
          <h1 className="Title">{title}</h1>
          <form onSubmit={changeTitle}>
            <div className="Input">
              <input
                className="Input-text"
                id="input"
                name="inputText"
                onChange={handleChanges}
                placeholder="Create new title"
                type="text"
                value={inputText}
              />
              <label htmlFor="input" className="Input-label">
                New title
              </label>
            </div>
          </form>
        </div>
      );
    };

    export default DynamicTitle;

You are probably looking at the two functions - `handleChanges` and `changeTitle`. If so, that is correct! And we can probably also count the `title` and `inputText` state in there as well. Those are all great examples of stateful logic. And really, the sky’s the limit on what could be considered stateful logic in a React component.

##### Challenge

Now that you can identify stateful logic, go through a few of the React components you’ve built this week. Try to point out examples of different stateful logic. How many different examples did you find?

------------------------------------------------------------------------

#### Learn to apply non-visual behavior (stateful logic) with custom hooks

Non-visual behavior can take many forms. Chances are that you’ve already used it without even realizing when you have used hooks to manage your stateful logic. However, just as with everything else in programming, there are often ways that we can become more efficient with our code. `Don't Repeat Yourself` is a mantra in the tech industry for a reason, and this is just as true with non-visual behavior and stateful logic as it is anywhere else.

##### Overview

`Custom Hooks`, are so-called because you are building the hook yourself (customizing it), to apply non-visual behavior and stateful logic throughout your components. This way, you can reuse the same hook over and over again. Custom hooks follow the same patterns of naming that you’ve already learned (i.e. prefacing the function name with `use`, as in `useState`). You can build a reusable custom hook for anything from handling controlled inputs, to managing event listeners, or watching for key presses.

##### Follow Along

Let’s start with the same component that we evaluated in the objective above. Go ahead and look over it one more time, this time making sure to understand what the various parts are doing.

    import React, { useState } from "react";

    const DynamicTitle = () => {
      const [title, setTitle] = useState("This is a class component");
      const [inputText, setInputText] = useState("");

      const handleChanges = e => {
        setInputText(e.target.value);
      };

      const changeTitle = e => {
        e.preventDefault();
        setTitle(inputText);
        setInputText("");
      };

      return (
        <div className="Wrapper">
          <h1 className="Title">{title}</h1>
          <form onSubmit={changeTitle}>
            <div className="Input">
              <input
                className="Input-text"
                id="input"
                name="inputText"
                onChange={handleChanges}
                placeholder="Create new title"
                type="text"
                value={inputText}
              />
              <label htmlFor="input" className="Input-label">
                New title
              </label>
            </div>
          </form>
        </div>
      );
    };

    export default DynamicTitle;

See how we have a `useState` hook, a `handleChange` function to update based on any changes, and a `changeTitle` function to change the actual title of the component when we submit the form?

Now, what happens if we need to issue state for multiple `input` tags? If we were to follow the lead of the patterns shown above, we would end up having to rewrite large amounts of our code for each `useState` call that we’ve invoked in order to create state for our second, third, and fourth `input`s.

Instead, let’s build out our custom hook that to reuse stateful logic. In this way, we avoid repeating code unnecessarily. Read the following function and try to guess what each piece of code is doing:

    export const useInput = initialValue => {
      const [value, setValue] = useState(initialValue);
      const handleChanges = updatedValue => {
        setValue(updatedValue);
      };
      return [value, setValue, handleChanges];
    };

In this `useInput` custom hook function, we’re taking in an `initialValue` and returning three new values. We pass `initialValue` as a parameter on the function. `initialValue` is then passed into the `useState` hook, which returns an array with our `value` variable and `setValue` function (just the same as what you’ve used up to this point).

Next, we have a `handleChanges` function that uses the `setValue` function to update state to a new value. Finally, we return an array from our `useInput` custom hook containing the `value` variable, the `setValue` function, and the `handleChanges` function.

Let’s take a look at this custom hook when it’s imported and used in a component.

    import React, { useState } from "react";
    import { useInput } from "./useInput.js";

    const CustomForm = () => {
      const [username, setUsername, handleUsername] = useInput("");
      const [password, setPassword, handlePassword] = useInput("");
      const [email, setEmail, handleEmail] = useInput("");

      const resetValues = e => {
        e.preventDefault();
        setUsername("");
        setPassword("");
        setEmail("");
      };

      return (
        <form onSubmit={resetValues}>
          <input
            className="username-text"
            id="username"
            name="username"
            onChange={e => handleUsername(e.target.value)}
            placeholder="Username"
            type="text"
            value={username}
          />
          <input
            className="password-test"
            id="password"
            name="password"
            onChange={e => handlePassword(e.target.value)}
            placeholder="Password"
            type="password"
            value={password}
          />
          <input
            className="email-text"
            id="email"
            name="email"
            onChange={e => handleEmail(e.target.value)}
            placeholder="Email"
            type="text"
            value={email}
          />
          <button type="submit">Submit</button>
        </form>
      );
    };

    export default CustomForm;

Whoa. That looks crazy, right? Don’t worry. We’re going to dissect this whole script to figure out exactly what each part is doing.

First off, notice that we’re invoking the `useInput` custom hook three times at the top of the component and passing in an empty string as each one’s initial value:

    const [username, setUsername, handleUsername] = useInput("");
    const [password, setPassword, handlePassword] = useInput("");
    const [email, setEmail, handleEmail] = useInput("");

Our `useInput` hook returns a new copy of our custom hook and state each time. Also, because array destructuring is based on positioning and not the name, we are allowed by JavaScript to name each of the three items returned from `useInput` in different ways. This is why we can set the first item to `username`, the second to `setUsername`, and the third to `handleUsername` while the next two `useInput` calls return differently-named variables and functions.

From these invocations, it now becomes easy to rig up each of our input tags in our JSX just the same as we did before. Here they are again for your reference:

    <form onSubmit={resetValues}>
      <input
        className="username-text"
        id = "username";
        name = "username";
        onChange={e => handleUsername(e.target.value)}
        placeholder = "Username";
        type = "text";
        value={username}
      />
      <input
        className="password-test"
        id = "password";
        name = "password";
        onChange={e => handlePassword(e.target.value)}
        placeholder = "Password";
        type = "password";
        value={password}
      />
      <input
        className="email-text"
        id = "email";
        name = "email";
        onChange={e => handleEmail(e.target.value)}
        placeholder = "Email";
        type = "text";
        value={email}
      />
      <button type="submit">Submit</button>
    </form>

Notice how we are setting our `handleUsername`, `handlePassword`, and `handleEmail` functions to process changes to the input. Remember how we returned a `handleChanges` function from our custom hook? Well, we’ve renamed them here (again, thanks to array destructuring) and are using them just the same as before. However, now, we have less code for them in our component.

The final thing you should notice is the `resetValue` function. When we invoke it, we use the `setValue`s returned from each `useInput` (again, each one is named differently) and pass it in our reset value (in this case, an empty string). Isn’t this an easy way to change your state?

Here they are again for your reference:

    const resetValues = e => {
      e.preventDefault();
      setUsername("");
      setPassword("");
      setEmail("");
    };

By building out a custom hook, we can skip writing out all of the stateful logic for our non-visual behavior. Custom hooks produce beautiful, `DRY` code that is easy to read *and* use. You have built a *reusable* piece of code that makes it easy for you to import anywhere in your application and build out stateful logic in any of your components.

##### Challenge

Now that you can identify custom hook logic and how you might both create and use it in your components, go back to several components you’ve built over the last week and refactor the state in some forms you made to use the `useInput` custom hook from the component in the examples above.

------------------------------------------------------------------------

#### Learn to compose hooks in a custom hook to extend multiple pieces of stateful logic

The power of custom hooks is starting to become apparent now. However, the real power of hooks comes in the ability to compose multiple hooks into a single custom hook. You can think about it this way - hooks bring the compositional power of React components to stateful logic! 🤯

##### Overview

Just as we can compose functions in vanilla JavaScript and components in React to create new functionality, we can extend our stateful logic by combining several hooks in a powerful, single custom hook. This compositional ability allows us to build out interesting abilities by combining various hooks in our application.

We can develop this complexity using multiple hooks inside a single custom hook. We’ve done this already when we called `useState` inside `useInput`. Pretty cool! Now imagine writing several custom hooks and combining all of that logic into a single custom hook to use in your components. The possibilities are dizzying! And amazing! Let’s try it out by expanding the `useInput` custom hook we’ve already built.

##### Follow Along

We need to start by building out a second custom hook. Later on, we’ll combine it with the `useInput` custom hook from the previous objective to achieve a more compelling hook with multiple pieces of stateful logic.

First, we’ll implement the new hook that we will call `useLocalStorage`:

    import { useState } from "react";

    const useLocalStorage = (key, initialValue) => {
      const [storedValue, setStoredValue] = useState(() => {
        const item = window.localStorage.getItem(key);
        return item ? JSON.parse(item) : initialValue;
      });
      const setValue = value => {
        setStoredValue(value);
        window.localStorage.setItem(key, JSON.stringify(value));
      };
      return [storedValue, setValue];
    };

Let’s walk through what we’re doing here. First, we pass in a key-value (like: “input1,” “input2” ) and an `initialValue`. These two parameters (key and value) are used in the `useState` hook call and used immediately inside our custom hooks. Instead of just passing in an initial value to this `useState` hook, we are using an anonymous arrow function as a callback to do two things:

1.  Check if the `window.localStorage` has a specific item (retrieved by `key`) in it
2.  Return that item from local storage if it exists or the initialValue otherwise

Because of this, our hook can now successfully check to see if a specific state item exists in `localStorage`, **and** it can use that item if it exists instead of the provided `initialValue`. Then, we also have a `setValue` function that takes a `value` as a parameter, sets it to the current `storedValue` by using the `setStoredValue` provided by `useState`, and sets it `localStorage`. As our state is now stored, our custom hook will check here on refresh to see if the state exists.

Now that we have a custom hook for controlling value placement (and updates) in `localStorage`, we can combine it with `useInput` to create powerful logic. Take a look at the completed code, and then we’ll talk about what it’s doing:

    import { useState } from "react";

    export const useInput = (key, initialValue) => {
      const [value, setValue] = useLocalStorage(key, initialValue);
      const handleChanges = updatedValue => {
        setValue(updatedValue);
      };
      return [value, setValue, handleChanges];
    };

    const useLocalStorage = (key, initialValue) => {
      const [storedValue, setStoredValue] = useState(() => {
        const item = window.localStorage.getItem(key);
        return item ? JSON.parse(item) : initialValue;
      });
      const setValue = value => {
        setStoredValue(value);
        window.localStorage.setItem(key, JSON.stringify(value));
      };
      return [storedValue, setValue];
    };

While our `useLocalStorage` hook has stayed the same, our `useInput` custom hook has some nice upgrades going on. Instead of implementing `useState` from React as before, we’re now using `useLocalStorage`. Furthermore, we’re also taking in two parameters instead of one - `key` and `initialValue`. These are then passed directly into the `useLocalStorage` hook. Immediately, the hook sets about implementing special logic with the variables as described above. This returns to our `useInput` custom hook with either a value from `localStorage` or our initialValue, and our `useInput` custom hook then returns a `value`, `setValue` function, and a `handleChanges` function in an array just the same as it did before.

Now when we call the `useInput` hook in a component to control inputs dynamically, we just need to pass in a unique key for each input to keep track of it in localStorage. Something like this:

    const [username, setUsername, handleUsername] = useInput("userName", "");
    const [password, setPassword, handlePassword] = useInput("password", "");
    const [email, setEmail, handleEmail] = useInput("email", "");

Although this isn’t something you will often do (storing input values in localStorage), this setup is quite powerful, and it effectively demonstrates how composable hooks can be; by combining the stateful logic of multiple custom hooks, you can compose a really nice custom hook with advanced stateful logic.

One final thing to note is that we can employ the `useLocalStorage` custom hook in other places now as well. So, not only do we have an extra-powerful `useInput` created by composing multiple hooks together, we also have another custom hook available to us anytime we want to persist data in localStorage.

##### Challenge

Try to think of different instances where you could compose different custom hooks together, particularly with the new `useLocalStorage` hook that you learned above. Be as creative as possible in the implementations that you think of.

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Dark Mode](https://github.com/LambdaSchool/dark-mode)

    In this project you’ll take this crypto currency tracker app and build two custom hooks that, when composed together, will allow users to set and persist a dark mode preference.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Composing and Sharing Non-Visual Behavior for Web35 w/ Warren Longmire](https://youtu.be/0VY1OzYmHr4)**

    Composing and Sharing Non-Visual Behavior

-   [All previous recordings](/archive/WEB3/module/recAxmnYmusEi8JuL)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Now that you can identify stateful logic, go through a few of the React components you’ve built this week. Try to point out examples of different stateful logic. How many different examples did you find?

-   Objective challenge:

    Now that you can identify custom hook logic and how you might both create and use it in your components, go back to several components you’ve built over the last week and refactor the state in some forms you made to use the `useInput` custom hook from the component in the examples above.

-   Objective challenge:

    Try to think of different instances where you could compose different custom hooks together, particularly with the new `useLocalStorage` hook that you learned above. Be as creative as possible in the implementations that you think of.

-   Project: Dark Mode
