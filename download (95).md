Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

- [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
- [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
- [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
- [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

- [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
- [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
- [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
- [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

- [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
- [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
- [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
- [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

- [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
- [React Router II](/webannex/module/recYkF1FDilIedmwX/)
- [Form Management](/webannex/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

- [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
- [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
- [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
- [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Annex

<a href="/webannex/sprint/recfwZvI7QhMa7xbG" class="bd-toc-link">1.  User Interface and Git</a>

- [User Interface](/webannex/module/recl0IyzS2Vl89lZa/)
- [Git for Web Development](/webannex/module/rect59e95N6OSvoCd/)
- [User Interface II](/webannex/module/recGvXyWT6AvGtMHR/)
- [User Interface III](/webannex/module/recaVbBZhh8BTyMdM/)

<a href="/webannex/sprint/recIXiQgpgMdJ81ms" class="bd-toc-link">2.  Advanced CSS</a>

- [Responsive Design I](/webannex/module/recuDrqSGpWcepCMs/)
- [Responsive Design II](/webannex/module/recE3IqPtDxaVI0DW/)
- [Preprocessing I](/webannex/module/reculyBhIYkuoBRqh/)
- [Preprocessing II](/webannex/module/rec1hRu3bO6L0uxn2/)

<a href="/webannex/sprint/recclZwJxMU8kUngT" class="bd-toc-link">3.  JavaScript Fundamentals</a>

- [JavaScript I](/webannex/module/recCT3KJYTIRYwQMh/)
- [JavaScript II](/webannex/module/rec1oaBmEoSilO2yf/)
- [Prototypes and Inheritance](/webannex/module/rec0AWuNLezbpit7m/)
- [Classes](/webannex/module/recyS588eOvVUKAMc/)

<a href="/webannex/sprint/recRT8JKvbTiGaosk" class="bd-toc-link">4.  Single Page Applications</a>

- [React Router I](/webannex/module/rec2TJ1vrdfcnx2EG/)
- [React Router II](/webannex/module/recYkF1FDilIedmwX/)
- [Form Management](/webannex/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/webannex/module/recKK5C7wV0WiECfr/)

<a href="/webannex/sprint/recozTHaHJe6L1ThN" class="bd-toc-link">5.  Authentication and Testing</a>

- [Introduction to Authentication](/webannex/module/recQD9lnhqWEFh6g4/)
- [Using Sessions and Cookies](/webannex/module/recvIPgHwxF194c7q/)
- [Using JSON Web Tokens (JWT)](/webannex/module/reciCHdNjavSKaaLt/)
- [Testing the Back End](/webannex/module/reciXdxRA8zXJXDID/)

- [Prepare](#prepare)
- [Learn](#learn)
- [Projects](#projects)
- [Review](#review)

# React Router I

<span class="lead"> </span>

Due to the insane popularity of JavaScript frameworks and what we call Single Page Applications (SPAs) we rely on our modern web browsers today for a lot more than we used to in the past. One of the common trends with SPAs to see today is the idea of `Client Side Routing` or the browser taking care of _“URL” history_

**At the end of this module, you should be able to:**

- explain the difference between client-side routing and sever-side routing
- add React Router to an application and set up basic routing
- describe the \`Route\` component and set up routes within a React Application
- use the \`Link\` component to navigate between routes
- create dynamic routes using URL parameters and the \`match\` object

#### Pro Tip

Celebrate wrong answers, because that means someone’s about to learn!

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=OrBKbQbobC0), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=WSZkkZrquiA), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=ZLpRLXsPNHs), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=nbwHVhkXuVk), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=BNOjGb_DE38), or enable JavaScript if it is disabled in your browser.

- [Client vs Server side Routing](https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f)

- [React Router Quick Start](https://reacttraining.com/react-router/web/guides/quick-start)

  Examples w/ setup information.

- [The Route Component](https://reacttraining.com/react-router/web/api/Route)

  Documentation on the Route component

- [The \`match\` object](https://reacttraining.com/react-router/web/api/match)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain the difference between client-side routing and sever-side routing

Client-side routing is a JavaScript managed routing option. It offers control over your site URL & content without necessarily having to wait for a server to respond with content. It is designed to mimic the appearance of traditional multi page websites.

What is server-side routing? It’s the way the web has worked for decades. Every link click & change of the address bar is a new request to a remote server. Every page load includes all page design elements, which must be re-downloaded. Including headers, navigation, sidebars, footers, etc. The server side routing method is not very efficient.

##### Overview

### What is Routing?

Being able to access information based on a URL is not only a powerful tool at our disposal as end-users and developers, but it is also a standard. Routing is essential for handling a communication piece between computers. Routing is the way we navigate through websites and web applications today. When we click on a link on any web app or website, we are routing to a URL and requesting some information that lives somewhere else. You do this every day - just type `www.google.com` in a web browser, and you’ve utilized routing to get resources from a server.

### What is a Server?

Before we talk about the _how_ of routing, we need a solid definition of the _what_. In computer science, the term “server” refers to centralized resources on a network. These servers are physical devices, usually housed with other servers in large warehouses, that run the “behind the scenes” work of the internet like data storage. When you route, you’re routing to a server.

You may be familiar with this type of server room from movies or TV. Each one of those boxes is a server, housing thousands of filing cabinets worth of data every couple of inches.

![server room](https://s3.envato.com/files/e967264f-38e7-4819-a943-83ddf54a4cea/inline_image_preview.jpg)

Websites and Web-applications all rely heavily on information that is controlled by a server. We can’t get away from them, even when we hear buzz-words like “serverless” servers (hint: they’re not really server-less) we still rely on machines that communicate across channels to deliver content to us as end-users. Imagine if every time you clicked on something on a website, you had to request a resource from a server, and then the server had to go and retrieve that resource, and then that server had to send back some HTML/CSS and eventually some JavaScript in order to display the data on the screen. For a long time, this was how the web worked.This hasn’t entirely gone away, but we now have a slightly better way of doing things.

This image does a really good job of showing some of the key differences between Client-side (traditional) and Server-side(SPA) routing.

![Client vs server](https://imagebin.ca/40yMWdOcgBfd/IC690875.png)

### Server-Side Routing

When we request information from a server (by clicking on a link or button), that server then sends back the document that was requested. For example, we click on a link and our URL changes to match the request, then the server goes and finds a `template` or some `HTML` file and sends it back across the world wide web to deliver that content to the user.

All of this is handled and achieved on the server, and there are a few things that happen here. First, the server will refresh the web page that we’re looking at. This is because a new request was made for information, and the information given was a bunch of DOM elements, so we have to re-paint the web page. The information requested will be the only information given, no more, and no less. Because of this, we get the opportunity to load smaller portions of the webpage as opposed to requesting/loading the entire thing the whole time the way that we do in Client-Side Routing.

When you (the client) request a lot of information, your computer and subsequent internet-related devices run through a lot of protocols. The process can be really slow, especially when bandwidth is an issue.

### Client-Side Routing

Now that we know about how things used to be done, we can talk about modern routing. Javascript and the other tools that we get to work with within Javascript are super sophisticated. Because of the arrival of tools like [Google Chrome’s V8 Engine](https://en.wikipedia.org/wiki/Chrome_V8), we can do a lot of things that weren’t previously possible. One of those new patterns is using JavaScript to maintain state (or memory) within our applications and use that memory to tell the Browser what to display when a resource is requested.

When Routing is handled internally by the JavaScript that is already on the page, we achieve what is known as `Client-side routing`. And this tool is how we get things done today, especially in React! And the best part about this is that the page won’t refresh! The data is just there, displayed when we ask for it. How this works is that when a user clicks on a requested resource, instead of the client asking for that resource from the server via a URL, JavaScript will prevent this. We then get the resource (state) that is already available to us rendered out, and when using react, this happens beautifully through component-based architecture.

##### Follow Along

Read through this medium article [here](https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f). Look at the image above as you read for a visual representation of how both server-side routing and client-side routing work.

##### Challenge

On your own, write down some of the pros and cons for both server-side routing and client-side routing, and then write a paragraph of what you like about both, and which you would prefer to use and why. Submit this to your TL via slack.

---

#### Learn to add React Router to an application and set up basic routing

What is React Router? Well it’s as great as it sounds, a client side wrapper for React applications. This topic will teach out about React Router and how to get it set up in a React application.

##### Overview

React Router is declarative style routing for React applications. React Router is a versatile tool because it can be used for React and React Native as well. The best part of React Router is that it pushes the envelope for what a router should be on the client. Since it was built for use within a react ecosystem, it uses a `Reactive & Declarative` context. Meaning that we get a much more dynamic routing experience when building and designing our Routes within our React Apps.

### Getting Started

Let’s look at how we can build out an application using some dynamic routing. To install React Router, all we have to do is use `yarn` to download the package from `npm`. In the past, we used to include the entire `react-router` package, but today we get to specify which target we’re building for (Web or Native). Because we’re building for web, we’re going to target the `react-router-dom` package and include it into one of our applications.

Once you have it installed, all you need to do is include it as a package like any other `npm` package we’ve used to date.

    import { BrowserRouter as Router } from "react-router-dom";

Now we’re going to use Router as our `Base` component that will wrap our entire app. We’ll do this by wrapping our `<App />` component that we pass to `ReactDOM.render`.

    ReactDOM.render(
      < Router>
        <App />
      </Router>,
      document.getElementById("root")
    );

Now, if we inspect our page and look into the React Dev Tools, we can find some fun things at our disposal, that will eventually get passed down to all other `Routes` (as we define them) in our application.

Notice how our React elements are now all wrapped within a `BrowserRouter` and a `Router` component.

![BrowserRouter wrapper](https://ibin.co/3xOQ4G9zzQTA.png)

Notice how on `Props` and `State` we have some really neat things that come out of the box with React Router. We’ll go into further detail on these objects later, but for now, note that any time we register a route, we’ll gain access to these props/state objects `history` and `match`. This is the power of the Router. It wraps our app, but only the Routes will receive these necessities as necessary.

![Props and State](https://ibin.co/3xOPoxdrBHPL.png)

This is all we have to do to install the Router. We get everything we need this way.

##### Follow Along

Let’s create an Avenger’s React SPA app by using react-router.

- Start a project using `yarn create react-app avengers`
- Add react-router with `yarn add react-router-dom` or `npm install -s react-router-dom`
- In `app.js` import the `BrowserRouter` component and wrap your app with it:

  import { BrowserRouter as Router } from 'react-router-dom';

  ReactDOM.render(
  < Router>
  <App />
  </Router>,
  document.getElementById("root")
  );

##### Challenge

Start up a new React app called friends, install `react-router-dom` and get it wired up to use React Router. Inspect your app in the browser with the React tools and make sure you see your app wrapped in the `Router` component (reference the image above).

##### Dig Deeper

- [React Router 4 Quick Start Guide](https://reacttraining.com/react-router/web/guides/quick-start)

---

#### Learn to describe the \`Route\` component and set up routes within a React Application

The way we declaratively set up our routes with in our applications all starts with the `Route` Component. Once you understand how to set up you which components will be mounted when which paths in our URL’s are being requested, you’ll be off to a good start with React Router.

##### Overview

Routes are a way of getting to a destination.

To set up React Router, set up Routes by declaring what components will be mounted when certain URL paths are met. This step happens _after_ we’ve wrapped our `Root` component in the `Router` or `BrowserRouter` component. The best part of React Router is that you can do this at pretty much any point during your development process, whereas previously you had to declare your routes early on in the development cycle. What this allows us to do, is figure out more important things without allowing routing to get in the way. React Router is a super useful tool for this reason!

Once you have React Router installed by using `yarn add react-router-dom` , you can import the `Route` Component and use it within your application.

    import { Route } from 'react-router-dom';

The `Route` component declares what `components` will be _mounted_ based on what `URL's` the user requests. The best part about this process is that we get a chance to do this in a very `react` way. Lets picture a component `Users` that will display a list of users in your system when the URL `www.coolestapp.com/users` is requested. The `Route` component takes in a few props; the first is the URL `path` where the Route component will trigger. Next is the `component` prop. This is the component that you want React to _mount_ when the URL matches the requested `path`. So in our case, when `/users` is requested, the `Users` component will be mounted.

    <Route path="/users" component={Users} />

This route will take us to the `users` component whenever the `/users` URL is requested within our application. You may be thinking to yourself at this point, is that really it? The answer is: yes, it is! It’s really simple to declare routes and components that will be mounted when the routes are requested. Think of your `Route` components asking you this question every single time you set one up: what **component** do you want **mounted** when a user asks for what **URL path**?

If you use this tool, you’ll hit each piece of your application, and how a user might interact with each component.

Now let’s see this all in action in a larger portion of an application. Picture an app that has 3 major components that will need to be rendered as part of a `Navigation` system: `Home`, `Contact`, and `About`. Each of these three components will need to be rendered when a user requests the `"/"`, `"/contact"` and `"/about"` paths in our app. So, let us refer to our question above: what component do you want mounted when a user asks for what URL path? In our case, we want the following:

A user requests `/` so we will mount the `Home` component A user requests `/contact` so we shall mount the `Contact` component A user requests `/about` so let us render the `About` component

Now that we have a framework let’s practice with it.

    <Route path="/" component={Home}/>
    <Route path="/contact" component={Contact}/>
    <Route path="/about" component={About}/>

#### The `exact` prop

And there we have it, we have successfully declared our Routes within our application. But we have a bit of a problem. A problem that is easily solved. If you’re looking at the React Router documentation, you may have already come across the `exact` prop, which is provided to us by the React Router API. This prop is a very important feature of the `Route` Component. It comes to us because of the way that the package was built. Let’s consider how this whole thing works.

When it comes down to it, we are using an API that already exists for us as web developers. And that is the [History](https://developer.mozilla.org/en-US/docs/Web/API/History) API that is built into our web browser. If the URL `/` and `/about` are both requested, and we have an algorithm to match the characters in the sequence `/`, `/about`. Both the `/` and `/12` will match. Because of the way this is set up, if we request the route `/about`, then both the `Home` Component and the `About` Component will be rendered. React Router anticipates this, and the `exact` prop to the `Route` component solves the problem.

By placing `exact` on a `<Route />` component, you are saying that the specific path will only trigger if it matches exactly the path requested. This defaults to false, so by simply including the `exact` prop on your `Route` component, it will set it to true and only mount our `Home` component when the specific path `/` is requested and not when `/about` is requested. [Here](https://reacttraining.com/react-router/web/api/Route/exact-bool) is a link to the docs. And here is an example of how this will work.

    <Route exact path="/" component={Home}/>
    <Route path="/contact" component={Contact}/>
    <Route path="/about" component={About}/>

This is the same as before only now our `Home` component route has the `exact` prop added to it. We have now solved the problem.

##### Follow Along

Time to set up routes for our Avenger’s app. We want to have a home page, and a list page. Later we’ll add an Avenger page. So our app routes are going to be organized something like this:

    A user requests `/` so we will mount the `Home` component
    A user requests `/avengers` so we shall mount the `AvengerList` component

Create a `components` directory. Then inside that folder, create a `Home.js` file and an `AvengersList.js` file. For now, just render a header element with “Home” and “Avenger List” in the respective components.

Import those new components into `App.js`. Let’s create the routes for our app. We will need to import the `Route` component.

    import { Route } from 'react-router-dom';

Now render two route’s (and don’t forget to add the `exact` prop to the Home route:

    <Route exact path="/" component={Home}/>
    <Route path="/avengers" component={AvengerList}/>

Go to both url’s and make sure the components are rendering correctly.

Build out your `Home` component however you would like.

Add [this data](https://gist.github.com/dustinmyers/b2a904870c84a0339002458f972b3398) to your app and display the list of Avengers in the list component.

Add [this](https://gist.github.com/dustinmyers/35ad6751b5bd683b441faaf167dfa7d3) to your .css file to use my styles, or style it up how you’d like on your own.

##### Challenge

In your friends app, add a new `Home` component and a new `Friends` component. Then add a route for each component. Test your app in the browser to make sure both apps are rendering at the correct route. Build out your `Home` component and then render out a list of friends data in the `Friends` component.

---

#### Learn to use the \`Link\` component to navigate between routes

In order for our code to work with client-side routing, we can’t use anchor tags `<a href="...">`. Well, React Router has a Component to the rescue!

The `Link` Component!

    // Before:
    <a href="/articles">Articles</a>
    // After:
    <Link to="/articles">Articles</Link>

Essentially you can think of `Link` as a special version of the anchor `<a>` tag. (It’s so similar, it uses an anchor under the hood.) The main benefit of `<Link to="...">` is to help us stay within the realm of our “client-side app.”

##### Overview

The link component can be included just like any other component in your application. This will produce an anchor tag that will link to a pre-defined component of your choice. Remember, if we set up our routes properly, we’ll be able to use the anchor component to navigate our browsers to the path where a component can be mounted. We can think of our `Route` component as the boat on the ocean, and the `Link` as the wind and sails that make that boat move.

    import { Link } from 'react-router-dom'

    <Link to="/about">About</Link>

As is the case with all of the components that we get from React Router, `Link` will take a few props that we can use to control the component and allow it to work for us.

First, `Link` takes the `to` prop. Notice in the above code block that `to` is a string that looks like a URL. This is just like the `href="/about"` attribute on the `anchor` tag. This is how we navigate with React Router.

##### Follow Along

Let’s add a navigation bar to the avengers app. We’ll use `Link` to make a way to route to the `Home` component and the `AvengerList` component. We won’t make one for the `AvengerPage` component because we won’t have a way to tell it which avenger we want to route to.

    <ul className="navbar">
      <li><Link to="/">Home</Link></li>
      <li><Link to="/avengers">Avengers</Link></li>
    </ul>

Try out the links to make sure they work, and then style the nav bar. Once that is done, go to your `AvengerList` component and add a `Link` somewhere in the mapped list of avengers that will route you to the `AvengerPage`. To show an example, I’ll do it here on the header element. You’ll notice that I am using an interpolated string so that we can build out the URL dynamically using the avenger’s id.

    <Link to={`/avengers/${avenger.id}`}>
      <h3>{avenger.name}</h3>
    </Link>

Take a minute to inspect your navbar and your wrapped header elements in the dev tools. Look for the anchor tags that get rendered by the `Link` component.

##### Challenge

Make a navbar on the friends app. In the list component, add a `Link` component to the mapped list of friends to give us a way to route to the individual friend page.

---

#### Learn to create dynamic routes using URL parameters and the \`match\` object

The URL’s that we type into our web browsers are actually powerful enough to hold onto some dynamic information that we may need at some point in time. The Match object built into React Router allows us to utilize this behavior, and send information by means of the URL’s we type into our search bars, down into our components for use later.

##### Overview

Let’s say we have a list of users. Each user is an object with a few properties that contain specific information about the user. Each user object has a unique `ID` parameter that we can use to index him or her, and display information about only one user instead of a variety of users. How would we go about selecting which user to show?

We could build out a click handler that will store the user’s `ID` on `React Component State`, and then, inside of our `render function`, hold a conditional statement that hides the list of users except for a single user’s information. This method would work splendidly because React doesn’t care where your data comes from; it only cares what data you’re showing to the user.

The way to accomplish such a task using React router is to let the library do the `conditional rendering` for you. If we were to set up a route like the one below, we’re effectively telling React Router to mount a `SingleUser` component anytime we request the URL. `http://localhost:3000/users/<id-gets-entered-here>`.

    <Route path='/users/:userId' component={SingleUser} />

This `ID` will be some long string or even just a number, and the component doesn’t care. What is important to note is the thing that comes after the `:`. The parameter is a variable that we can use later to pull that information down. This pulling process happens through the `match` object that React Router provides for us.

Any component that is mounted via `React Router's Route` component will receive a `match` object as a prop. Because of this implementation, we can fetch the necessary data for the specific item to receive this information as the page is being mounted. This idea is very powerful because it allows us to implement what we call `dynamic routing`.

So, if the URL `http://localhost:3000/users/10` is requested, how do I then access that number `10` that is found on the end of the URL? One common way is to consume it from props on the `useEffect` method. Because the `match` object is found on any `Route` mounted component, we can consume that match object as we would any other prop.

    `useEffect(() => {
      const id = props.match.params.userId;
      // do something with the id
    }, [props.match.params.userId])

Remember that we called the id after `/friends` the `userId` when we set up our route. So that is what will be found as the `key/value` pair on the match object when this route is requested. If we were to look at the console, we could see a better picture of what’s going on with this here.

![match params full](https://image.ibb.co/fPd2X8/Screen_Shot_2018_06_26_at_9_55_17_AM.png)

Now you can do with that ID whatever you’d like. Normally the next step is to send it off to a server to retrieve some new information somewhere.

This is how one would set up dynamic routing using React Router. Here is a link to a little project that demonstrates it’s use case pretty well.

[![Edit o4nomn5p49](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/o4nomn5p49)

##### Follow Along

Now we can create an Avenger Page component to view details for individual Avengers. We’ll do this by creating a dynamic route using an `id` parameter, and rendering an `AvengerPage` component for the Avenger with that id.

First let’s create the `AvengerPage` component. It will be a functional component that renders details of an Avenger. Build out the design however you would like.

Next, add a dynamic route:

    <Route path="/avengers/:id" component={AvengerPage} />

Now when we do this, we’ll want to be sure to add the `exact` attribute to the `/avengers` route, or else that component will render at our new path as well. Add that, and your routes should look like this:

    <Route exact path="/" component={Home}/>
    <Route exact path="/avengers" component={AvengerList}/> //added the exact attribute
    <Route path="/avengers/:id" component={AvengerPage} />

Finally, we need to use the `match` object that gets passed as a prop to our new component to find the correct avenger to display the correct details in the `AvengerPage` component.

To do that, we will use `.find()` on the avengers list and find the avenger that matches the dynamic `/:id` parameter in the URL. Then, we will set the newly identified Avenger to an `avenger` variable. This will all happen inside the component before we return our JSX. The JSX, will reference that new `avenger` variable to render out their details.

    import React from 'react';

    const avengerData = []; // get the data from the same source above

    function AvengerPage(props) {
      const avenger = avengerData.find(avenger => props.match.params.id === avenger.id);
      return (
        // ...jsx goes here - something like...
        <h1>{avenger.name}</h1>
        // ...etc
      );
    }

But wait, there is a problem. If you test out your new route, you’ll see that there is an error that says something like “Cannot read property `name` of undefined.” That means that `avenger` is undefined and that the `.find()` function is not finding the avenger, nor setting it to the variable. Let’s fix this.

If you look at that expression `props.match.params.id === avenger.id` and inspect the two different `id`s, you’ll see that we’re getting a string for the `id` coming from the `match` object (because it’s coming from the URL string), whereas we’re getting a number from the id from the avengerList data. We need to change one data type so both of them are a string, or so that both of them are numbers. Personally, I like to use an interpolated string here to change the number `id` to a string. Refactor your `.find()` callback function to look like this:

    const avenger = avengerData.find(avenger => props.match.params.id === `${avenger.id}`);

##### Challenge

In the friends app you’ve been building, create a new, dynamic route for the path `/friends/:id`. Then create a `FriendPage` component that will find your friend from the list of friends based on the `/:id` param in the url, and render that friend’s details. Remember to style your app!

---

## <a href="#projects" id="projects" class="anchor"><span class="octicon octicon-link"></span></a>Projects

- ##### [React Router Basic Nav- This is for day 1](https://github.com/LambdaSchool/React-Router-Basic-Nav)

  This project is designed to get you used to putting together a Router using React Router V.4

- ##### [React-Router-Movies](https://github.com/LambdaSchool/React-Router-Movies)

  Create an app that renders a list of movies in one route, and a movie info page in another route.

- ##### [React-Router-Apple-Nav STRETCH ASSIGNMENT](https://github.com/LambdaSchool/React-Router-Apple-Nav)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[React Router I for WebPT13 w/Emily Seibert](https://youtu.be/ZRHal-kPNQY)**

  Intro to Single Page Applications

- [All previous recordings](/archive/FSW/module/rec2TJ1vrdfcnx2EG)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  On your own, write down some of the pros and cons for both server-side routing and client-side routing, and then write a paragraph of what you like about both, and which you would prefer to use and why. Submit this to your TL via slack.

- Objective challenge:

  Start up a new React app called friends, install `react-router-dom` and get it wired up to use React Router. Inspect your app in the browser with the React tools and make sure you see your app wrapped in the `Router` component (reference the image above).

- Objective challenge:

  In your friends app, add a new `Home` component and a new `Friends` component. Then add a route for each component. Test your app in the browser to make sure both apps are rendering at the correct route. Build out your `Home` component and then render out a list of friends data in the `Friends` component.

- Objective challenge:

  Make a navbar on the friends app. In the list component, add a `Link` component to the mapped list of friends to give us a way to route to the individual friend page.

- Objective challenge:

  In the friends app you’ve been building, create a new, dynamic route for the path `/friends/:id`. Then create a `FriendPage` component that will find your friend from the list of friends based on the `/:id` param in the url, and render that friend’s details. Remember to style your app!

- Project: React Router Basic Nav- This is for day 1

- Code Challenge: ReverseLinkedList

- Code Challenge: LargestDifferenceInArray
