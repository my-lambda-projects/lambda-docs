<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Java

<a href="/web4java/sprint/recnLDyTtONLTMiFJ" class="bd-toc-link">1.  Java Precourse Information</a>

- [Welcome to Java Spring](/web4java/module/recfnUAvFbeyIAHib/)
- [Java Spring Course Table of Contents](/web4java/module/recjH0lMflsFIVzDM/)

<a href="/web4java/sprint/recoJ4ZqNQWX3cy6E" class="bd-toc-link">2.  Java Fundamentals</a>

- [Java - JDK and Java Classes](/web4java/module/recAGVTYNZyJbEFpu/)
- [Java Interfaces, Abstract Classes, Lambda Expression](/web4java/module/rec6Hrk77HupYeoN5/)
- [Java - RDBMS and SQL Basics](/web4java/module/recyJ663TrxVgpqY9/)
- [Java - Intro to Maven, Spring, and Tomcat Using REST API](/web4java/module/recqtftA9E98qpbak/)

<a href="/web4java/sprint/recRVUSWQEtosl0Cz" class="bd-toc-link">3.  RDBMS and Intro to APIs</a>

- [Java - Spring Database Creation Including Seed Data](/web4java/module/recb0OVmRrJzqhH4D/)
- [Java - Read Data using CRUD Operations](/web4java/module/rec3THcdjv8BumGCt/)
- [Java - Inserting Deleting and Updating Data using CRUD Operations](/web4java/module/recJihkiNn2KH2nEW/)
- [Java - Data Modeling and Auditing Fields with custom querying](/web4java/module/rec2oQCFWOVShtxIx/)

<a href="/web4java/sprint/recSqm5AAEkJcIl3p" class="bd-toc-link">4.  Java Frameworks</a>

- [Java - Exception Handling](/web4java/module/rec3E1WYDyoiEF1e3/)
- [Java - User Authentication](/web4java/module/rececDV2OMIUcY2eH/)
- [Java - Automated Testing](/web4java/module/recDboXln5wm4aKJt/)
- [Java - Java Deployment and Best Practices](/web4java/module/rec7pCiBPzI4DkAJT/)

<a href="/web4java/sprint/recC5dhR9menaROwx" class="bd-toc-link">5.  WEB Unit 4 Java Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Java - Spring Database Creation Including Seed Data

<span class="lead"> </span>

<span id="Data_Model_Creation"></span>

**At the end of this module, you should be able to:**

- perform CRUD operations on an RDBMS using JPA and Hibernate (data modeling)
- implement seed data using SQL statements
- explain and use Spring Data Relationships
- implement a data seeding class using JPA and Hibernate
- implement massive data seeding
- use H2 Console and H2 IntelliJ integration to explore data

#### Pro Tip

All things in moderation, including moderation.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- [JPA Entity Relationships](https://www.tutorialspoint.com/jpa/jpa_entity_relationships.htm)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to perform CRUD operations on an RDBMS using JPA and Hibernate (data modeling)

<span id="Data_Modeling"></span>

##### Overview

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

Let’s start building a full Java Spring CRUD Application! Of course we will need:

- Dependencies
  - Spring Boot DevTools
  - Spring Web
  - Spring Data JPA
  - H2 Database
- Application.propererties updates
  - Configurations useful for working with H2
  - Configuration for a port that is not frequently used
  - Configuration to tell Spring Boot what happens when no accessors are found for a type (and there are no annotations to indicate it is meant to be serialized).
  - Configuration that keeps a transaction inside of the same entity manager This property register an EntityManager to the current thread, so you will have the same EntityManager until the web request is finished.
  - Configuration on how to handle schema definitions and seed data
- Application Layout through subpackages
  - `config`
  - `controllers`
  - `models`
  - `repositories`
  - `services`

##### Follow Along

Let’s create a CRUD application! We are using the IntelliJ IDE to create our applications. To create a Spring Boot application in IntelliJ, follow these steps

![Click on Create a project](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-01.png)

- Follow the wizard to create the application.
  - Create a project with the Spring Frame.

![Select Spring Framework](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-02.png)

- Name the project, picking the correct version of the JDK (NOT 8 for class)

![Select Name with Version 11](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-03.png)

- Add the appropriate dependencies: Spring Boot DevTools, Spring Web, Spring Data JPA, H2 Database

![Add dependencies](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-04.png)

- Name the project file
- Note: I am storing all my projects on my Mac under my home directory and then under a subdirectory called `jxwork`.

![Name the project file](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/JX-SP11-M2-05.png)

- If a popup appears asking, select to make this a Maven Project.

- If a popup appears asking, select to autoimport Maven dependencies.

##### Configure the application

- In the `POM.XML` file, comment out the scope for H2

<!-- -->

            <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
    <!--            <scope>runtime</scope>-->
            </dependency>

- Now add these lines to the `application.properties` found under main/resources. The comments are there so you know what each line means.

<!-- -->

    ### Configurations useful for working with H2
    spring.h2.console.enabled=true
    spring.h2.console.path=/h2-console
    #
    ### We set a port that is not frequently used
    server.port=${PORT:2019}
    #
    ### Feature that determines what happens when no accessors are found for a type
    ### (and there are no annotations to indicate it is meant to be serialized).
    spring.jackson.serialization.fail-on-empty-beans=false
    #
    ### keeps a transaction inside of the same entity manager
    ### This property register an EntityManager to the current thread,
    ### so you will have the same EntityManager until the web request is finished.
    spring.jpa.open-in-view=true
    #
    ### What do with the schema
    ### drop n create table again, good for testing
    spring.jpa.hibernate.ddl-auto=create
    spring.datasource.initialization-mode=always
    #
    ### Good for production!
    ### spring.jpa.hibernate.ddl-auto=update
    ### spring.datasource.initialization-mode=never

##### Creating the application structure

- First, let’s create each of the needed subpackages. Under the main package (`src/main/java/com.lambdaschool.sampleemps`), create the following subpackages
  - config
  - controllers
  - models
  - repositories
  - services

Now let’s enter some of the code

- Under the subpackage `config`
  - Create the class `H2ServerConfiguration`
  - Enter the following code in that class
  - Entering the comments is optional
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.config;

    import org.h2.tools.Server;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    import java.sql.SQLException;

    /**
     * Configures H2 access through the JetBrains IntelliJ IDEA IDE.
     * <p>
     * Adapted from https://techdev.io/en/developer-blog/querying-the-embedded-h2-database-of-a-spring-boot-application
     * necessary for using the database tool built into intellij
     */
    @Configuration
    public class H2ServerConfiguration
    {

        /**
         * TCP port for remote connections, default 9092.
         */
        @Value("${h2.tcp.port:9092}")
        private String h2TcpPort;

        /**
         * Web port, default 8082.
         */
        @Value("${h2.web.port:8082}")
        private String h2WebPort;

        /**
         * TCP connection to connect with SQL clients to the embedded h2 database.
         * <p>
         * Connect to "jdbc:h2:tcp://localhost:9092/mem:testdb", username "sa", password empty.
         *
         * @return The created TcpServer needed to access H2.
         * @throws SQLException If the server cannot be created.
         */
        @Bean
        @ConditionalOnExpression("${h2.tcp.enabled:true}")
        public Server h2TcpServer() throws
            SQLException
        {
            return Server.createTcpServer("-tcp",
                "-tcpAllowOthers",
                "-tcpPort",
                h2TcpPort)
                .start();
        }

        /**
         * Web console for the embedded h2 database.
         * <p>
         * Go to http://localhost:8082 and connect to the database "jdbc:h2:mem:testdb", username "sa", password empty.
         *
         * @return The created web server needed to access H2.
         * @throws SQLException If the server cannot be created.
         */
        @Bean
        @ConditionalOnExpression("${h2.web.enabled:true}")
        public Server h2WebServer() throws
            SQLException
        {
            return Server.createWebServer("-web",
                "-webAllowOthers",
                "-webPort",
                h2WebPort)
                .start();
        }
    }

- Under the subpackage `controllers`
  - Create the class `EmployeeController`
  - Enter the following code in that class
  - Entering the comments is optional
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.controllers;

    import com.lambdaschool.sampleemps.services.EmployeeService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    @RequestMapping("/employees") // optional
    public class EmployeeController
    {
        @Autowired
        private EmployeeService employeeService;

    }

We are done for now. The rest of the subpackages will be completed in other objectives.

##### Dig Deeper

- [CRUD REST API/Service](https://www.springboottutorial.com/spring-boot-crud-rest-service-with-jpa-hibernate)  
  Creating a CRUD REST API/Service with Spring Boot, JPA and Hibernate
- [Hibernate Introduction](https://javabrains.io/topics/hibernate/)  
  Hibernate Introduction
- [Hibernate fetching strategies](https://vladmihalcea.com/hibernate-facts-the-importance-of-fetch-strategy/)  
  A beginner’s guide to Hibernate fetching strategies

---

#### Learn to implement seed data using SQL statements

<span id="Data_Seeding_Using_SQL"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

Seeding Data is the process of putting into a database an initial set of data. This may be done for testing purposes, or the application may need an initial set of data to begin functioning.

One popular way of seeding data is using SQL. Spring Boot will look into your `resources` folder to see if a file named `data.sql` exits. If the file does exist, the data may be loaded into the database. The loading of the data depends on settings in `application.properties`. By default, the SQL statements get executed, and the data is loaded. The preferred practice is to explicitly turn this on in `application.properties` using the following entry:

    spring.datasource.initialization-mode=always

To turn off the execution of `data.sql`, use the following entry:

    spring.datasource.initialization-mode=never

A common practice is to first delete the data in the database. This is especially necessary when seeding a database with test data. Each time the application is executed, all old data is deleted and refreshed with the data from `data.sql`. This way you always know at the start of running the application what your data is. You delete data use the SQL command `delete from <table>`. You must delete from tables in a certain order.

1.  Find all tables whose primary keys do not exist in other tables. Delete from those tables first. This will include join tables and tables with Many to One relationships.
2.  Keeping finding tables whose primary keys do not exist in other tables and delete from those tables. This process can be repeated until all data is removed.

For example, we delete from the join table `EMPLOYEETITLES` first. Then from the Many to One Table `EMAILS`. Then delete from `JOBTITLES` and `EMPLOYEES`.

##### Follow Along

Continue with the application you started in Objective 1 - CRUD

- Create the file `data.sql` under `src/main/resources`
- Enter the following into that file!
- You might get a warning message about SQL dialect is not configured. This can safely be ignored.

<!-- -->

    DELETE
    FROM EMPLOYEETITLES;

    DELETE
    FROM EMAILS;

    DELETE
    FROM JOBTITLES;

    DELETE
    FROM EMPLOYEES;

We populate our database in the reverse order. We have to add data to a table before its primary key can be used in another table. So, start with the EMPLOYEE table

- So now add this to your file

<!-- -->

    INSERT INTO EMPLOYEES (EMPLOYEEID, NAME)
        VALUES (1, 'CINNAMON'),
               (2, 'BARNBARN'),
               (3, 'JOHN');

Now that we have employee primary keys, we can add some employee emails

- Continuing adding to the file

<!-- -->

    INSERT INTO EMAILS (EMAILID, EMAIL, EMPLOYEEID)
        VALUES (1, '[email protected]', 1),
               (2, '[email protected]', 1),
               (3, '[email protected]', 2);

Let’s now create some job titles

- And keep adding to the file

<!-- -->

    INSERT INTO JOBTITLES (JOBTITLEID, TITLE)
        VALUES (1, 'Big Boss'),
               (2, 'Wizard');

Now that we have some job titles and employees, let’s create a join table for those.

- Keep adding to the file

<!-- -->

    INSERT INTO EMPLOYEETITLES (EMPLOYEEID, JOBTITLEID)
        VALUES (1, 1),
               (1, 2),
               (2, 2);

Please note that we have been manually assigning primary keys to our database tables. This is fine, but we need to let Spring JPA Hibernate know that we have used some of the primary keys. Hibernate cannot start assigning primary keys at 1, since 1 has already been used. We need to tell Hibernate at what number to start assigning primary keys. We do this with the following statement

- And lastly add this to the file

<!-- -->

    /*
    Must tell hibernate of the id numbers already used.
    The number after with must be greater that the highest number id assigned.
     */
    alter sequence hibernate_sequence restart with 15;

Note that a comment is surrounded by `\* */`. And we have now seeded our database.

Expand to see a complete data.sql file

    DELETE
    FROM EMPLOYEETITLES;

    DELETE
    FROM JOBTITLES;

    DELETE
    FROM EMAILS;

    DELETE
    FROM EMPLOYEES;

    INSERT INTO EMPLOYEES (EMPLOYEEID, NAME, SALARY)
        VALUES (1, 'CINNAMON', 80000.00),
               (2, 'BARNBARN', 80000.00),
               (3, 'JOHN', 75000.00);

    INSERT INTO EMAILS (EMAILID, EMAIL, EMPLOYEEID)
        VALUES (1, '[email protected]', 1),
               (2, '[email protected]', 1),
               (3, '[email protected]', 2);

    INSERT INTO JOBTITLES (JOBTITLEID, TITLE)
        VALUES (1, 'Big Boss'),
               (2, 'Wizard');

    INSERT INTO EMPLOYEETITLES (EMPLOYEEID, JOBTITLEID)
        VALUES (1, 1),
               (1, 2),
               (2, 2);

    /*
    Must tell hibernate of the id numbers already used.
    The number after with must be greater that the highest number id assigned.
     */
    alter sequence hibernate_sequence restart with 15;

##### Dig Deeper

- [Baeldung](https://www.baeldung.com/spring-boot-data-sql-and-schema-sql)  
  Baeldung - Quick Guide on Loading Initial Data with Spring Boot
- [Spring](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-initialize-a-database-using-spring-jdbc)  
  Spring - How To Initialize a Database

---

#### Learn to explain and use Spring Data Relationships

<span id="Spring_Data_Relationships"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

When normalizing our database structure, we create relationships between tables. These relationships usually fall into two main categories: One to Many relationships and Many to Many relationships. Let’s look at each one separately.

We will use the finished Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git) as an example in explaining the topics. Later, we will add code to the application we started in Objective 1 CRUD to put into practice what is explained.

After normalizing our data, we will end up with different types of tables

- main or driving tables. These are tables that do not contain foreign keys. Other tables will reference them but they do not reference other tables. In our example, `Employees` is such a table.
- tables with foreign keys that are the one in a one to many relationship. These tables can be viewed as child tables of the main tables as they cannot stand alone without the reference to the main table. In our example, `Emails` is such as a table. Its purpose is to reference the `Employees` table adding a list of emails to a row in the `Employees` table.
- join tables contain foreign keys to two tables, joining those tables in a many to many relationship. In a Java Spring application, such a table usually does not have its own Model but is created through the ManyToMany annotation. In our example, the `Employeetitles` table is such a join table, joining `Employees` and `Jobtiles`.

### Overview One to Many

A row in one table may relate to 0 or more rows in another table. This is the way lists of data are represented. In our example, an employee can have a list of emails so employee has a one to many relationship with emails. It can also be said that emails has a Many to One relationship with employee.

Other examples of one to many relationships

- book to pages
- person to todo or chores
- order to items in the order

Usually, this is represented graphically by an arrow. The start of the arrow is on the “one” table; the head of the arrow is on the “many” table.

![One to Many Relationships](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/sampleemps-db-onetomany.png)

In Java Spring we need to specify both the one to many relationship and the reverse many to one relationship. In each case we must provide a field to hold the data from the other table in the relationship. Using our example

One to Many is from `Employee` to `Email` so we need a list of emails in employee. We use the annotation `@OneToMany` with attributes defining the relationship.

        @OneToMany(mappedBy = "employee",
                cascade = CascadeType.ALL, // when adding, reading, updating, and delete, the operations should affect the emails table as well)
                orphanRemoval = true) // if we find a email that has a reference to an employee that does not exist, delete that email record
        private List<Email> emails = new ArrayList<>();

Note that `employee` from the `mappedBy` attribute matches the `employee` field found right after the `ManyToOne` attribute. It is critical that these two be named the same including case!

Many to One is from `Email` to `Employee`. Each email can only have one employee so we have a single Employee object in the Email table. We use the annotation `@ManyToOne` with attributes defining the relationship.

        @ManyToOne
        @JoinColumn(name = "employeeid",
                nullable = false)
        private Employee employee;

Note that the `employeeid` in the `name` attribute must match exactly the primary key column from the `Employee` table.

Note that one to one relationship is a special case of the one to many relationship. The “many” side of the relationship is restricted to only one entry.

Notice that the way this is set up, an employee can be assigned duplicate emails. Making emails unique to an individual employee would require us to implement custom queries and that is beyond the scope of this module. So, just remember, though not encouraged!, employees can have duplicates emails in their lists.

### Overview Many to Many

Often in a database we have a list in one table and a list in the another. Each time from each list can be associated with 0 or more items from the other list. In our example we have `Employees` that can have 0 or more `Jobtitles` and a `Jobtitles` can be related to 0 or more `Employees`. Hence we have a Many to Many relationship.

Other examples of Many to Many Relationships include

- Authors to Books. Books can be written by multiple authors and authors can write multiple books
- Students to Classes. Students will take multiple classes and classes will have multiple students.
- Customers to Projects. Many Customers can buy the same project and customers can buy multiple products

Usually, this is represented by having an arrow from a join table to one of the lists with the head of the arrow pointing at the list. We then have another arrow from the join table to other list with the head of the arrow pointing at the other list. So in reality a Many to Many relationship is made up of two One to Many relationships. So in our example

- Each row in our join table will have only one employee but can have many rows with the same employee.
- Each row in our join table will have only one job title but can have many rows with the same job title.
- Normally we restrict our join table to have a unique combination of employee and job title.
- We will see later how to manually implement a many to many relationship using this one to many idea.

![Many to Many Relationships](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%202%20-%20JX%20Java%20-%20Read%20Data%20using%20CRUD%20Operations%20including%20Seeding%20Data/assets/sampleemps-db-manytomany.png)

In Java Spring we specify the many to many relationship in each table that is involved in the relationship. We decide on one table to be the main table. In our case we will pick `Employee`. It does not matter which table we pick. In our case the titles describe the employees, so without employees there would be no reason for job titles. Hence I picked Employee for our driving table.

In the `Employee` model we add this code.

        @ManyToMany()
        /*
         * Note: JoinTable is the name of a table that will get created in the database combining the two primary keys making up this relationship
         *       joinColumn is the primary key of the main, driving, table
         *       inverseJoinColumns is the primary key of the other table in the relationship
         *
         * We are using a Set inside of a List to help with enforcing uniqueness in the employeetitles. Sets by their very nature
         * only contain unique values. By using Sets we do not have to do a lot of extra coding to enforce uniqueness.
         * We can treat the HashSet very similar to ArrayLists. Differences will be highlighted throughout the course
         */
        @JoinTable(name = "employeetitles",
                joinColumns = @JoinColumn(name = "employeeid"),
                inverseJoinColumns = @JoinColumn(name = "jobtitleid"))
        Set<JobTitle> jobtitles = new HashSet<>();

It is critical that the JoinColumn names match exactly case and all with the respective primary keys of the tables being joined!

Now in the JobTitle model we add this code

        @ManyToMany(mappedBy = "jobtitles")
        private Set<Employee> employees = new HashSet<>();

- Notice that each model provides a private field LIST to hold the other model’s data!
- Notice that the `mappedBy` attribute matches exactly the list name given in the `Employee` model, the other model!

##### Follow Along

Continue with the application you started in Objective 1 - CRUD and where you added data.sql in Objective 2. Let’s enter some more code

### One to Many

- Under the subpackage `models`
  - Create the class `Employee`
  - Enter the following code in that class
    - Yes lowercase please!!!
      - Please note that all field names that will become columns are lowercase. This is by design. This way we do not have be concerned with how JPA will interpret the column names. They will be lowercase!
      - Please note that all table names are lowercase. That way we do not have to worry about how JPA will interpret our table names.
      - We also always give a table name. That way we do not have to worry about how JPA will interpret our Entity, Model name.
  - Note: you do not have enter the comments and the Getters and Setters can be generated in IntelliJ
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.models;

    import javax.persistence.*;
    import java.util.ArrayList;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Set;

    @Entity
    @Table(name = "employees")
    public class Employee
    {
        @Id // The primary key
        @GeneratedValue(strategy = GenerationType.AUTO) // We will let the database decide how to generate it
        private long employeeid; // long so we can have many rows

        @Column(nullable = false,
                unique = true)
        private String name;

        private double salary;

        @ManyToMany()
        /*
         * Note: JoinTable is the name of a table that will get created in the database combining the two primary keys making up this relationship
         *       joinColumn is the primary key of the main, driving, table
         *       inverseJoinColumns is the primary key of the other table in the relationship
         *
         * We are using a Set inside of a List to help with enforcing uniqueness in the employeetitles. Sets by their very nature
         * only contain unique values. By using Sets we do not have to do a lot of extra coding to enforce uniqueness.
         * We can treat the HashSet very similar to ArrayLists. Differences will be highlighted throughout the course
         */
        @JoinTable(name = "employeetitles",
                joinColumns = @JoinColumn(name = "employeeid"),
                inverseJoinColumns = @JoinColumn(name = "jobtitleid"))
        Set<JobTitle> jobtitles = new HashSet<>();

        @OneToMany(mappedBy = "employee",
                cascade = CascadeType.ALL,
                // when adding, reading, updating, and delete, the operations should affect the emails table as well)
                orphanRemoval = true)
        // if we find a email that has a reference to an employee that does not exist, delete that email record
        private List<Email> emails = new ArrayList<>();

        public Employee()
        {
            // the default constructor is required by the JPA
        }

        public long getEmployeeid()
        {
            return employeeid;
        }

        public void setEmployeeid(long employeeid)
        {
            this.employeeid = employeeid;
        }

        public String getName()
        {
            return name;
        }

        public void setName(String name)
        {
            this.name = name;
        }

        public double getSalary()
        {
            return salary;
        }

        public void setSalary(double salary)
        {
            this.salary = salary;
        }

        public List<Email> getEmails()
        {
            return emails;
        }

        public void setEmails(List<Email> emails)
        {
            this.emails = emails;
        }

        public Set<JobTitle> getJobtitles()
        {
            return jobtitles;
        }

        public void setJobtitles(Set<JobTitle> jobtitles)
        {
            this.jobtitles = jobtitles;
        }
    }

- Under the subpackage `models`
  - Create the class `Email`
  - Enter the following code in that class
  - Note: you do not have enter the comments and the Getters and Setters can be generated in IntelliJ
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.models;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    import javax.persistence.JoinColumn;
    import javax.persistence.ManyToOne;
    import javax.persistence.Table;

    @Entity
    @Table(name = "emails")
    public class Email
    {
        @Id // The primary key
        @GeneratedValue(strategy = GenerationType.AUTO) // We will let the database decide how to generate it
        private long emailid; // long so we can have many rows

        private String email;

        @ManyToOne
        @JoinColumn(name = "employeeid",
            nullable = false)
        private Employee employee;

        public Email()
        {
            // the default constructor is required by the JPA
        }

        // Getters and Setters begin. These can be generated!
        public long getEmailid()
        {
            return emailid;
        }

        public void setEmailid(long emailid)
        {
            this.emailid = emailid;
        }

        public String getEmail()
        {
            return email;
        }

        public void setEmail(String email)
        {
            this.email = email;
        }

        public Employee getEmployee()
        {
            return employee;
        }

        public void setEmployee(Employee employee)
        {
            this.employee = employee;
        }
    }

### Many to Many

- Under the subpackage `models`
  - Create the class `JobTitle`
  - Enter the following code in that class
  - Note: you do not have enter the comments and the Getters and Setters can be generated in IntelliJ
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.models;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    import javax.persistence.ManyToMany;
    import javax.persistence.Table;
    import java.util.ArrayList;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Set;

    @Entity
    @Table(name = "jobtitles")
    public class JobTitle
    {
        @Id // The primary key
        @GeneratedValue(strategy = GenerationType.AUTO) // We will let the database decide how to generate it
        private long jobtitleid; // long so we can have many rows

        private String title;

        @ManyToMany(mappedBy = "jobtitles")
        private Set<Employee> employees = new HashSet<>();

        public JobTitle()
        {
            // the default constructor is required by the JPA
        }

        public long getJobtitleid()
        {
            return jobtitleid;
        }

        public void setJobtitleid(long jobtitleid)
        {
            this.jobtitleid = jobtitleid;
        }

        public String getTitle()
        {
            return title;
        }

        public void setTitle(String title)
        {
            this.title = title;
        }

        public Set<Employee> getEmployees()
        {
            return employees;
        }

        public void setEmployees(Set<Employee> employees)
        {
            this.employees = employees;
        }
    }

### Repositories

- Under the subpackage `repositories`
  - Create the class `EmployeeRepository`
  - Enter the following code in that class
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.repositories;

    import com.lambdaschool.sampleemps.models.Employee;
    import org.springframework.data.repository.CrudRepository;

    public interface EmployeeRepository
        extends CrudRepository<Employee, Long>
    {

    }

- Under the subpackage `repositories`
  - Create the class `JobTitleRepository`
  - Enter the following code in that class
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.repositories;

    import com.lambdaschool.sampleemps.models.JobTitle;
    import org.springframework.data.repository.CrudRepository;

    public interface JobTitleRepository
        extends CrudRepository<JobTitle, Long>
    {

    }

### Services

- Under the subpackage `services`
  - Create the interface `EmployeeService`
    - This is where we define what operations we will allow on our data
  - Enter the following code in that class

<!-- -->

    package com.lambdaschool.sampleemps.services;

    public interface EmployeeService
    {

    }

- Under the subpackage `services`
  - Create the interface `EmployeeServiceImpl`
    - This is where we implement any business rules we need apply to our data
  - Enter the following code in that class
  - Try not entering the imports. Let IntelliJ do that for you

<!-- -->

    package com.lambdaschool.sampleemps.services;

    import com.lambdaschool.sampleemps.repositories.EmployeeRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service(value = "employeeSerivce") // needed to name this implementation as the service to use
    public class EmployeeServiceImpl
        implements EmployeeService // notice the Impl for implementing a service
    {
        @Autowired
        private EmployeeRepository employeerepos;

    }

Note in this application we will be using the `JobTitleRepository` and the `EmployeeService` to access our data. Normally you would either use all repositories or all services but I wanted to get both uses in the same example!

##### Dig Deeper

- [Column Names are Different](https://stackoverflow.com/questions/11156199/one-to-many-hibernate-join-if-column-names-are-different)  
  One to many hibernate join if column names are different
- [Baeldung](https://www.baeldung.com/jpa-one-to-one)  
  Baeldung: One-to-one Relationship
- [Baeldung](https://www.baeldung.com/hibernate-one-to-many)  
  Baeldung: One-to-many Relationship
- [Baeldung](https://www.baeldung.com/jpa-many-to-many)  
  Baeldung: Many-to-many Relationship
- [Baeldung](https://www.baeldung.com/spring-data-rest-relationships)  
  Baeldung: A Complete Multi-Relationship Application

---

#### Learn to implement a data seeding class using JPA and Hibernate

<span id="Data_Seeding_Using_Java_Spring"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git)t for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We can seed data to our application using Java. The models and repositories have to be in place before we use Java to seed our application. Preferably, the services would be in place as well. In this example, I will be using the services. You can use the repositories directly but miss some of the data validation that is done in the services. So let’s code this seed data!

##### Follow Along

- First create a class at the root package, the same package where your main method is located. You can call this class anything you wish. I usually call it `SeedData`. Add the following code to this class

- Let’s look at the starting annotations for this class.

  - Since this is making changes to the database, we annotate with `@Transactional`. More this annotation later in the course.
  - Spring Boot needs to know this class exists so we use `@Component`.
    - If we wish for this seed data NOT to be added to the database, all we have to do is not tell Spring Boot about the class. We do this by commenting out the `@Component` annotation. All the code is still in place but with the `@Component` annotation is gone; Spring Boot does not know about the class and thus no seeding the data!!!

<!-- -->

    @Transactional
    @Component
    public class SeedData implements CommandLineRunner
    {
        @Override
        public void run(String... args) throws Exception
        {

        }
    }

Notice that SeedData implements `CommandLineRunner`. `CommandLineRunner` is a special Spring interface with a single `run` method. This runs once and only once after the Application Context is loaded. The Application Context is the container that manages all the Beans and so is responsible for running the CommandLineRunner run method.

- To make this work, I want to add a constructor to Email. This constructor will take parameters of an email and an employee using those to create the object. So in the Email model add the constructor

<!-- -->

    <... other code ...>
        public Email(String email, Employee employee)
        {
            this.email = email;
            this.employee = employee;
        }
    <... other code ...>

- Looking at the data.sql file as inspiration, let’s recreate that same seed data using Java.
  - One big difference is we do not get to pick the primary keys. We will allow Hibernate to generate them for us.
  - The data.sql file first deletes all the data. I do not do that in my SeedData. Usually if I am loading data from both places and do not want to wipe out in SeedData what I just added through data.sql.
  - I am going to access the JPA methods directly from the repositories as oppose to going through the services. The choice is yours. Using the services is preferred if they are fully implemented! Ours are not. So, autowire in the repositories.

<!-- -->

    public class SeedData implements CommandLineRunner
    {
        @Autowired
        private EmployeeService employeeService;

        @Autowired
        private JobTitleRepository jobTitlerepos;

- Let’s create the JobTitles so we can add them when we create the employees

<!-- -->

        @Override
        public void run(String... args) throws Exception
        {
            JobTitle jt1 = new JobTitle();
            jt1.setTitle("Big Boss");
            jobTitlerepos.save(jt1);

            JobTitle jt2 = new JobTitle();
            jt2.setTitle("Wizard");
            jobTitlerepos.save(jt2);

- Now, let us create the Employees
- Notice that while creating the Employees, we add their emails and jobtitles
  - emails are added by adding an email one at time to the employee’s email arraylist
  - jobtitles are added on at a time using the employee’s jobtitle hashset.

<!-- -->

            Employee emp1 = new Employee();
            emp1.setName("CINNAMON");
            emp1.setSalary(80000.00);
            emp1.getEmails()
                    .add(new Email("[email protected]",
                                   emp1));
            emp1.getEmails()
                    .add(new Email("[email protected]",
                                   emp1));
            emp1.getJobtitles().add(jt1);
            emp1.getJobtitles().add(jt2);
            employeeService.save(emp1);

            Employee emp2 = new Employee();
            emp2.setName("BARNBARN");
            emp2.setSalary(80000.00);
            emp2.getEmails()
                    .add(new Email("[email protected]",
                                   emp2));
            emp2.getJobtitles().add(jt1);
            employeeService.save(emp2);

            Employee emp3 = new Employee();
            emp3.setName("JOHN");
            emp3.setSalary(75000.00);
            employeeService.save(emp3);
        }

- Let’s finish creating our Services. Here we will create a minimum service method. We will enhance it later in the course!
- In the services subpackage, update the code for EmployeeService so the interface looks like this:

<!-- -->

    package com.lambdaschool.sampleemps.services;

    import com.lambdaschool.sampleemps.models.Employee;

    public interface EmployeeService
    {
        Employee save(Employee employee);
    }

- Now let’s implement a very simple save service.
- In the services subpackage, update the code for EmployeeServiceImpl by adding the following method

<!-- -->

        @Transactional
        @Override
        public Employee save(Employee employee)
        {
            return employeerepos.save(employee);
        }

Before running make sure that in `application.properties` `spring.datasource.initialization-mode` is set to `never`. This will prevent Spring Boot from loading the data in data.sql!

##### Challenge

---

#### Learn to implement massive data seeding

<span id="Mass_Data_Seeding"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

We have much to update in adding these CRUD functions. Your Follow Along task is to find the code in the repo as it is mentioned in the objective!

Creating your own seed with values that you know is very useful. You know what to look for when you are testing the application. However, sometimes you just want a bunch of random data, say to test performance or pagination. Take a look at Javafaker. This cool dependency allows you to random generate all sorts of data from regular name and telephone number to Star Trek references to Cat information. Take a look at the various categories. For now we will use names and randomly generate salaries.

##### Follow Along

To use Javafaker, add the dependency to your `POM.XML` file. Add it right above `</dependencies>` closing tab! After adding this dependency:

- Right click on the `pom.xml` file
  - Goto to the context menu `Maven` and select `Reload project`

<!-- -->

            <!-- https://mvnrepository.com/artifact/com.github.javafaker/javafaker -->
            <dependency>
                <groupId>com.github.javafaker</groupId>
                <artifactId>javafaker</artifactId>
                <version>1.0.1</version>
            </dependency>

Now add to our SeedData file a random value field right after the `@Autowire`d fields.

        private Random random = new Random();

We need to initialize our Javafaker and tell it we are using US English. Put this after you have added your known data so at the end of the run method in SeedData

            Faker nameFaker = new Faker(new Locale("en-US"));

Let’s randomly generate some names. Our names must be unique. This is not guaranteed with Javafaker. So an easy workaround is to generate a bunch of names and add them to a SET. A SET only contains unique values. If you try to add a duplicate value to a SET, that add gets ignored. Perfect for what we want. We will then use this set to create our employees. This technique does not guarantee a certain number of records but it does a good job. This way will generate no more than 100 unique names. So after the `Faker nameFaker` variable declaration, add the following code:

            // this section gets a unique list of names
            Set<String> empNamesSet = new HashSet<>();
            for (int i = 0; i < 100; i++)
            {
                empNamesSet.add(nameFaker.name().fullName());
            }

Now let’s create more employees from this Javafaker data

            for (String empName : empNamesSet)
            {
                Employee employee = new Employee(); // create a new employee object that will be removed at the end of the loop body
                employee.setName(empName); // set the name
                employee.setSalary(50000.00 + (100000.00 * random.nextDouble())); // randomly generate salary from 50000 to 150000

                int randomInt = random.nextInt(10); // random number of emails from 0 - 9
                for (int j = 0; j < randomInt; j++)
                {
                    employee.getEmails()
                        .add(new Email(nameFaker.internet().emailAddress(),
                            employee));
                }
                employee.getJobtitles().add(jt1); // just assigning them to the first job title
                employeeService.save(employee);
            }

Enjoy this fun and useful dependency!

Expand to see a complete SeedData.java file

    package com.lambdaschool.sampleemps;

    import com.github.javafaker.Faker;
    import com.lambdaschool.sampleemps.models.Email;
    import com.lambdaschool.sampleemps.models.Employee;
    import com.lambdaschool.sampleemps.models.JobTitle;
    import com.lambdaschool.sampleemps.repositories.JobTitleRepository;
    import com.lambdaschool.sampleemps.services.EmployeeService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;
    import org.springframework.transaction.annotation.Transactional;

    import java.util.HashSet;
    import java.util.Locale;
    import java.util.Random;
    import java.util.Set;

    @Transactional
    @Component
    public class SeedData implements CommandLineRunner
    {
        @Autowired
        private EmployeeService employeeService;

        @Autowired
        private JobTitleRepository jobTitlerepos;

        private Random random = new Random();

        @Override
        public void run(String... args) throws Exception
        {
            JobTitle jt1 = new JobTitle();
            jt1.setTitle("Big Boss");
            jobTitlerepos.save(jt1);

            JobTitle jt2 = new JobTitle();
            jt2.setTitle("Wizard");
            jobTitlerepos.save(jt2);

            Employee emp1 = new Employee();
            emp1.setName("CINNAMON");
            emp1.setSalary(80000.00);
            emp1.getEmails()
                    .add(new Email("[email protected]",
                                   emp1));
            emp1.getEmails()
                    .add(new Email("[email protected]",
                                   emp1));
            emp1.getJobtitles()
                    .add(jt1);
            emp1.getJobtitles()
                    .add(jt2);
            employeeService.save(emp1);

            Employee emp2 = new Employee();
            emp2.setName("BARNBARN");
            emp2.setSalary(80000.00);
            emp2.getEmails()
                    .add(new Email("[email protected]",
                                   emp2));
            emp2.getJobtitles()
                    .add(jt1);
            employeeService.save(emp2);

            Employee emp3 = new Employee();
            emp3.setName("JOHN");
            emp3.setSalary(75000.00);
            employeeService.save(emp3);

            Faker nameFaker = new Faker(new Locale("en-US"));

            // this section gets a unique list of names
            Set empNamesSet = new HashSet<>();
            for (int i = 0; i < 100; i++)
            {
                empNamesSet.add(nameFaker.name()
                                        .fullName());
            }

            for (String empName : empNamesSet)
            {
                Employee employee = new Employee(); // create a new employee object that will be removed at the end of the loop body
                employee.setName(empName); // set the name
                employee.setSalary(50000.00 + (100000.00 * random.nextDouble())); // randomly generate salary from 50000 to 150000

                int randomInt = random.nextInt(10); // random number of emails from 0 - 9
                for (int j = 0; j < randomInt; j++)
                {
                    employee.getEmails()
                            .add(new Email(nameFaker.internet()
                                                   .emailAddress(),
                                           employee));
                }
                employee.getJobtitles()
                        .add(jt1); // just assigning them to the first job title
                employeeService.save(employee);
            }
        }
    }
    </code></pre>

##### Dig Deeper

- [Java-faker Homepage](https://dius.github.io/java-faker/)  
  Java-faker Homepage
- [Baeldung](https://www.baeldung.com/java-faker)  
  Baeldung - A Guide to JavaFaker
- [Set in Java](https://www.geeksforgeeks.org/set-in-java/)  
  Set in Java
- [Java.util.Random](https://www.geeksforgeeks.org/java-util-random-class-java/)  
  Java.util.Random class in Java

---

#### Learn to use H2 Console and H2 IntelliJ integration to explore data

<span id="H2_Console"></span>

##### Overview

- See the Github Repository [https://github.com/LambdaSchool/java-sampleemps.git/sampleemps_model](https://github.com/LambdaSchool/java-sampleemps.git) for the code used in the objective.

##### Software Needed

- Java Development Kit (JDK) - at least version 11
- JetBrains IntelliJ IDEA IDE
- Postman

Note we entered this configuration class in a previous module. Now let’s look at more in depth!

For testing purposes, Java Spring Developers typically use the H2 database. We use H2 as an in memory database. Each time the application is restarted the current data in the database is deleted. In fact the entire database is removed from memory and recreated. The database is then seeded with a fresh data set and is ready for new testing.

Note: Since this is an in memory database, the database is only available while the application is running.

For production purposes we need a more full featured, stable, persistence database. For that we will be using PostgreSQL later in this course. However, until we deploy our database, H2 fulfills are our requirements!

##### Adding H2 Database to Application

This dependency must be added in `POM.XML` file

            <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
    <!--            <scope>runtime</scope>-->
            </dependency>

These configurations should be added to the `application.properties` file

    ### Configurations useful for working with H2
    spring.h2.console.enabled=true
    spring.h2.console.path=/h2-console

Add this class in `config` package

    package com.lambdaschool.sampleemps.config;

    import org.h2.tools.Server;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    import java.sql.SQLException;

    /**
     * Configures H2 access through the JetBrains IntelliJ IDEA IDE.
     *
     * Adapted from https://techdev.io/en/developer-blog/querying-the-embedded-h2-database-of-a-spring-boot-application
     * necessary for using the database tool built into intellij
     */
    @Configuration
    public class H2ServerConfiguration
    {

        /**
         * TCP port for remote connections, default 9092.
         */
        @Value("${h2.tcp.port:9092}")
        private String h2TcpPort;

        /**
         * Web port, default 8082.
         */
        @Value("${h2.web.port:8082}")
        private String h2WebPort;

        /**
         * TCP connection to connect with SQL clients to the embedded h2 database.
         * <p>
         * Connect to "jdbc:h2:tcp://localhost:9092/mem:testdb", username "sa", password empty.
         *
         * @return The created TcpServer needed to access H2.
         * @throws SQLException If the server cannot be created.
         */
        @Bean
        @ConditionalOnExpression("${h2.tcp.enabled:true}")
        public Server h2TcpServer() throws SQLException
        {
            return Server.createTcpServer("-tcp",
                                          "-tcpAllowOthers",
                                          "-tcpPort",
                                          h2TcpPort)
                         .start();
        }

        /**
         * Web console for the embedded h2 database.
         * <p>
         * Go to http://localhost:8082 and connect to the database "jdbc:h2:mem:testdb", username "sa", password empty.
         *
         * @return The created web server needed to access H2.
         * @throws SQLException If the server cannot be created.
         */
        @Bean
        @ConditionalOnExpression("${h2.web.enabled:true}")
        public Server h2WebServer() throws SQLException
        {
            return Server.createWebServer("-web",
                                          "-webAllowOthers",
                                          "-webPort",
                                          h2WebPort)
                         .start();
        }
    }

##### Follow Along

Add the above class to your sample employee application developed in this Module.

### Accessing H2 through the H2 Console

Let’s access H2 through the H2 Console

![Accessing H2 through its console](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/JX-SP11-M3-07.gif)

Steps:

- The application must be running!!!
- Surf to http://localhost:2019/h2-console
- The sign on screen should default fine.
  - Saved Settings: `Generic H2 (Embedded)`
  - Setting Name: `Generic H2 (Embedded)`
  - Drive Class: `org.h2.Driver`
  - JDBC URL: `jdbc:h2:mem:testdb`
  - User Name: `sa`
  - Passord:
- Once connected you are presented with a list of the database elements and a blank box. Inside the black box, you can enter any valid SQL commands to run against the database.
  - To Execute that SQL, click the `Run` button
  - To start over, click the `Clear` button

### Accessing H2 through IntelliJ

Let’s access H2 through IntelliJ. This is primarily done in order to display a graphic representation of the database. All the database graphs you see in this course were done following this method.

![Accessing H2 through IntelliJ](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/JX-SP11-M3-06.gif)

Steps:

- The application must be running!!!
- In IntelliJ with your project open, open the right side tab `Databases`
- From the source (`+`) button, add a new data source
  - Select from the `Datasource` list `H2`
    - Complete the requested information:
      - Host: localhost
      - Port: 9092
      - User: sa
      - Password:
      - Save: Forever
      - Database: mem:testdb
    - Then click Apply OK

### Displaying H2 Diagram

![Accessing H2 Diagram](https://lambdaschool.github.io/java-curriculum-assets/Sprint%2011%20-%20Java%20with%20RDBMS%20and%20API%20Intros/Module%203%20-%20JX%20Java%20-%20Inserting%20Deleting%20and%20Updating%20Data%20using%20CRUD%20Operations%20including%20generating%20Seed%20Data/assets/JX-SP11-M3-08.gif)

Steps to display the database diagram

- Expand the jdbc:h2:tcp://localhost:9092/mem:testdb
- Expand TESTDB
- Expand schemas
- Expand PUBLIC
- Expand tables
  - You can now see your tables!
- Right click on Public
- From the Context Menu, select Diagrams -> Show Visualization
- A diagram of your database appears in a file in IntelliJ
- The arrow pointing out of the right angle allows you to save the diagram

Yes, you can do other functions through IntelliJ against an H2 database. However for the purposes of this class, we will mainly access H2 through its console.

##### Dig Deeper

- [Baeldung](https://www.baeldung.com/spring-boot-h2-database)  
  Baeldung Spring Boot H2 Database
- [Homepage for the H2 Database](https://www.h2database.com/html/main.html)  
  Homepage for the H2 Database

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Crudy Restaurants Initial

Using restaurants with menus as our model, we explore CRUD operations related to model data. We will start with the crudyrestaurants_initial application found in the repo

[GitHub Repo](https://github.com/LambdaSchool/java-crudyrestaurants.git)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Java Modeling Orders](https://github.com/LambdaSchool/java-orders.git)

  This is part 1 of a 3 part series. In the first part you are tasked with setting up the database model in a Java Spring Application.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Java Spring Database Modeling for WEB33 with John Mitchell](https://youtu.be/sRbsyfO54SI)**

  Abbreviated class due to Labor Day Holiday

- [All previous recordings](/archive/WEB4Java/module/recb0OVmRrJzqhH4D)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:
- Guided Project: Crudy Restaurants Initial
- Project: Java Modeling Orders
