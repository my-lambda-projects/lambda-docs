Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

-   [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
-   [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
-   [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
-   [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

-   [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
-   [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
-   [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
-   [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

-   [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
-   [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
-   [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
-   [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

-   [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
-   [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
-   [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

-   [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
-   [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
-   [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
-   [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

-   [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
-   [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
-   [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
-   [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

------------------------------------------------------------------------

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Project](#project)
-   [Review](#review)

# Introduction to Python II

<span class="lead"> </span>

We’re going to continue today working through Python basics, but we’re going to do it with an eye toward problem-solving strategy. Additionally, we’ll discuss applying our basic Python knowledge to more complex problems.

**At the end of this module, you should be able to:**

-   name and describe the details of each step of Lambda’s Problem Solving Framework
-   examine and interpret project requirements and create an action plan based on those requirements
-   create a Python program, demonstrate its successful performance, and explain the process used to create the program

#### Pro Tip

When talking about your journey, don’t focus on things you don’t know yet, focus on what you’ve learned and how quickly.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=IIBJ7OA0R7s), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=f3YAP5NsRYI), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to name and describe the details of each step of Lambda’s Problem Solving Framework

Many times, both as you are working through the Computer Science curriculum and when you are on the job, you will find yourself faced with large, challenging problems. There are strategies we can use to break these problems down into more manageable pieces.

> The single most important skill for a computer scientist is problem solving. Problem solving means the ability to formulate problems, think creatively about solutions, and express a solution clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity to practice problem-solving skills. Think Python, 2nd Edition, by Allen B. Downey (O’Reilly). Copyright 2016 Allen Downey, 978-1-4919-3936-9.

##### Overview

We can break every problem, large or small, into smaller chunks. It’s logical, if you can take an unsolvable problem and break it into smaller more manageable chunks that are solveable, by solving each individual part you will solve the entire problem.

Throughout the Computer Science curriculum, we will reference and use the Lambda Problem Solving Framework, sometimes referred to as **UPER**. This framework is a step-by-step process:

1.  **U**nderstand
2.  **P**lan
3.  **E**xecute
4.  **R**eflect

Almost all problems are a series of sub-problems. You will use the steps of **UPER** on the primary, outer problem and on the inner individual sub-problems.

### 1. Understand

The most crucial thing to do before you do anything else is to understand all of the details of what the problem is asking you to do. One helpful starting point is to transcribe the description of the problem from the page into your own words.

#### Questions

Here is a list of starter questions that might come up during this step:

-   What are the inputs your code receives?
-   What is the range of input?
-   How big can the input be (how much data)?
-   What are the outputs your code produces?
-   What is the range of output?
-   How big can the output be (how much data)?
-   How performant must the code be?
-   What is missing from the task description?
-   Are there third-party stakeholders who we should consult?
-   What assumptions are you making?
    -   Does anyone else on the team need to validate these assumptions?

#### Actions

-   The most important thing you can do during this stage of the process is to **ask questions**!
    -   Be as specific as you can when you are asking questions.
    -   Be clear and concise with your questions by using unambiguous language and only including necessary details.
-   Do not fear this part of the process—enjoy it!
    -   Try to have a mindset where you see the problem as a curiosity to be explored, not something there to antagonize you.
    -   Feeling antagonized and afraid won’t help you at work or in an interview. Remember, problem solving is the fun part so enjoy it!
-   Identify the smaller components that make up the larger problem.
    -   If you get stuck in understanding, break the larger problem into smaller sub-problems.
    -   Then, apply this framework against each of the smaller sub-problems until you solve the larger problem.
-   Try to digest the problem and comprehend it by rewriting the problem in your own words.
    -   If you had to describe the problem to someone else, how would you do so?
-   Diagram how the data flows through the problem.
    -   Think about each stage of the journey for the data and what will happen to it as it travels through your program.
-   Think like a villain.
    -   What inputs would break your program?
-   Where is the description of the problem incomplete?
    -   If you aren’t able to get answers on something that’s unclear in the specifications, make an educated guess and document your assumptions and your decision.

You are done with this step when you could explain this problem to someone who has never seen it. Your explanation should be thorough enough for the person to skip the Understand step themselves and start to plan right away.

### 2. Plan

This is where you will ask *what steps will I take to solve the problem*? You will take your description of the problem and transform it into a complete, actionable plan to solve that problem. If you find shortcomings in your understanding of the problem while you’re planning, drop back to Step 1 until you resolve the ambiguity. If you have not yet completed Step 1, you will end up planning to solve the wrong problem! When interviewing, it’s very important that you do this step aloud!

Remember, you aren’t coding during this step, unless it’s small pieces of throwaway code to test a hypothesis. You should write pseudocode during this step, however.

#### Questions

-   Do you know the answer to a similar problem that has similar inputs and outputs?
    -   What does this problem remind you of?
    -   Can you bring that knowledge to bear here?
-   Does my plan meet the performance requirements?
    -   What’s the time complexity?
    -   What’s the space complexity?
    -   How big can my input data be?
-   Can sorting the input data ahead of time lead to any improvements in time complexity?
    -   Does recursion help?
    -   Is the problem made up of identical subproblems?
    -   Can you state the problem with itself in its own definition?
-   Think like a villain. Does your plan cover the edge cases?

#### Actions

-   Solve the problem like a human.
    -   If you’re sorting something, imagine your task as a pile of blocks in front of you that need to be sorted.
-   Break down the steps you take into small enough pieces for a computer to understand.
-   Approach the problem from many angles.
-   Get a brute-force solution as quickly as possible, even if it’s not performant enough.
    -   It can lead you toward better solutions.
-   Come up with as many plans of attack as you can.
    -   Choose the best one that satisfies performance needs.
-   Try to solve a simpler version of the problem.
    -   If the input is a 2D array, can you solve it for a 1D array?
    -   If you need to count the number of ways to eat cookies 1, 2, or 3 at a time, first try to solve it for the number of ways you could eat two at a time or even one at a time.
    -   The solution to the simpler problem can lead to insights on the more complex problem.
-   List the nouns and verbs in the problem description.
    -   Map each one to an algorithm, process, data structure, object, method, function, etc.
-   Perfect can be the enemy of good.
    -   Even if your initial workable solution isn’t performant enough, you can iterate later.
    -   “Premature optimization is the root of all evil.”

You know that you completed this step when you have pseudocode that’s detailed enough to convert to real code. You should also be convinced the pseudocode represents a legitimate, working solution.

### 3. Execute

This is where you take your plan and convert it to actual, working code. This step isn’t easy, but it’s much easier if you’ve done a good job with Steps 1 and 2 above. If you find shortcomings in your plan while you’re implementing the solution, drop back to Step 2 until you resolve the ambiguity. If you have not yet completed Step 2, you will spend far longer on this step than you have to.

#### Questions

-   Think like a villain. Does your implementation handle all inputs?
-   What language is best to solve this problem?
    -   Best technically?
    -   Best for the company?
-   What is the best way to split this code into functional modules?
-   Are any of the modules reusable for later projects?
-   Does this functionality already exist?
    -   Are there built-in libraries I can leverage?
    -   Are there third-party libraries I can leverage?
        -   Are the licenses on those third-party libraries compatible with our needs?

#### Actions

-   Start a source code control repo (e.g. a git repo) if one doesn’t already exist.
-   Convert your pseudocode and outlines into actual code.
-   Don’t Repeat Yourself (DRY): Remove redundant code as you write it.
-   Document code as you write it.
    -   Header blocks that contain usage information.
    -   Comments where necessary.
-   Write code clearly enough that comments aren’t necessary.
    -   If comments help clarify or summarize a piece of code to a reader, definitely add comments.
-   If you write code that’s hackish or kludgy, fix it.
    -   If you don’t have time to fix it, comment it with:
        -   Why you couldn’t do it the Right Way (time constraints, etc.)
        -   What do you need to do to make it Right.
-   Follow the style guide for the company.
    -   If no style guide is available, follow the style of the existing codebase.
    -   If there is no existing style guide or codebase, choose the best one you can find.
-   Write unit tests as required.
-   Write end-to-end tests as required.

You know this step is complete when:

-   The program works on good data.
-   The program doesn’t fail on bad data or edge cases.
-   The program passes all tests.

### 4. Reflect

Is this implementation as good as I can make it? Would I be proud to show my code to another programmer?

#### Questions

-   Does your solution work in all cases?
    -   Main case?
    -   Edge cases?
-   Is the solution performant enough?
-   Is the code documented?
-   In retrospect, what would you do differently? What will you do differently next time?
    -   What went right?
    -   What went wrong?

#### Actions

-   Document or implement any changes that you still need to make to the code.
-   Document or remove any redundant code that you should refactor.
-   Remove unused code.
-   Document future shortcomings that you will need to address in the medium or long term.
-   Identify and document algorithms that you should replace with algorithms with better time complexity.
-   Identify and document or remove redundant computation.
-   Document any embarrassing code that you need to fix.
    -   Why you couldn’t do it the Right Way (time constraints, etc.)
    -   What you need to do to make it Right.

You know that this step is complete when you cannot think of anything else to reflect upon.

##### Follow Along

Now, let’s use the *dining philosophers problem* as an example problem to use our Problem Solving Framework on. Here’s a short description of the problem:

Five silent philosophers sit at a round table with bowls of noodles. One chopstick is placed between each pair of adjacent philosophers.

Each philosopher must alternately think and eat. However, a philosopher can only eat noodles when they have both left and right chopsticks. Each chopstick can be held by only one philosopher and so a philosopher can use the chopstick only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.

Eating is not limited by the remaining amounts of noodles or stomach space; an infinite supply and an infinite demand are assumed.

The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e. each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.

### 1. Understand

On the surface, this seems like a straight-forward problem however, there are some approaches that will lead to problematic results.

Some key pieces of information from the question we should highlight:  

-   there are **5** philosophers
-   there are **2 states** (eating, thinking)
-   there is exactly 1 chopstick in between each pair of philosophers (5 total)
-   BOTH chopsticks are required to transition from thinking to eating

Some important questions to ask here include *“When should philosophers pick up a chopstick?”* and *“When should philosophers put down a chopstick?”*

Remember that before you work on a solution, you want to establish if there are any restrictions or limitations you need to consider.

### 2. Plan

Let’s create a solution written as a set of rules that defines how philosophers should interact with chopsticks that will allow them to transition between *eating* and *thinking*.  

1.  philosopher is eating (2 chopsticks)
2.  philosopher finishes eating and sets down chopsticks
3.  philosopher is thinking (0 chopsticks)
4.  philosopher sees his/her neighbor set down chopsticks & picks them up
5.  repeat steps 1-4

### 3. Implement

We could break down the general plan above into a few specific rules.  

-   eat for a set amount of time once they are holding both chopsticks
-   set down the right chopstick
-   set down the left chopstick
-   pick up the left chopstick as soon as it becomes available
-   pick up the right chopstick as soon as it becomes available
-   repeat

However, this solution will NOT always work.

### 4. Reflect

The above solution has the potential to create a situation known in Computer Science as **deadlock**. This means that two processes (or in this case, philosophers) are stuck in an eternal state of waiting. If neither has two chopsticks, they cannot eat. But they also won’t put down chopsticks they’re holding (because they haven’t eaten yet). We need to revise the rules about when philosophers should pick up / put down chopsticks to eliminate this possibility.

##### Challenge

So that everyone gets to eat, there are some situations in which philosophers *should* pick up a chopstick, and some situations in which they *should NOT* (because another philosopher needs to use it).

Write a better solution to the dining philosophers problem so that deadlock does NOT occur.

------------------------------------------------------------------------

#### Learn to examine and interpret project requirements and create an action plan based on those requirements

##### Overview

When you are approaching a software project, it is common to receive a list of specifications or requirements. This usually takes the form of a list of necessary functions, capabilities, or characteristics related to the project and the plans for creating it.

### Types of Requirements

Most requirements fall within one of the following categories:

1.  Business Requirements
    -   Define the overall project objectives and what problems the stakeholder is trying to solve with the product.
2.  User Requirements
    -   Describes user expectations and how they will interact with the product.
    -   User scenarios often outline the tasks your users want to complete with the product.
3.  Functional Requirements
    -   Provide specifics on how a product should behave and specify the development needs.

### Using Project Requirements

The requirements they supply you only tell you what the final product must have and what it must allow users to do. The interesting part comes because the requirements themselves do not tell you the specifics of *how* to design or develop the site so it meets the required outcomes.

### Requirements Best Practices

Requirements documents should:

-   be specific.
-   avoid combining distinct requirements.
-   be verifiable during testing.

##### Follow Along

Now, let’s take an example project and transform the requirements into a plan of action. We are going to be looking at a hypothetical Rock-Paper-Scissors Game.

##### Requirements

-   There will be 2 players:
    -   One player will be a human user.
    -   The second player will a computer player that the human user is competing against.
-   Each player has three choices:
    -   rock
    -   paper
    -   scissors
-   There are three results after both the human and the computer make one of their choices:
    -   win
    -   lose
    -   tie
-   The rules for figuring out who wins and who loses are:
    -   rock beats scissors
    -   paper beats rock
    -   scissors beats paper
-   A tie occurs if both users choose the same option.

Notice how the requirements don’t tell us anything about *how* to make this program. The requirements merely state the required functionality of the finished product.

It’s easy to look at this list of requirements and just freeze up and not know what the next step should be. This is a perfect time to use our Lambda Problem Solving Framework (UPER)! Although for this example we will only do the first two steps of the framework (Understand and Plan).

##### Understand

Let’s make sure we understand all the details of the requirements. Looking over the list again, here are some questions that come up:

-   What happens at the start of the game?
-   What is the first thing the user will see when starting the game?
-   How are points being tracked?
-   At what point does the game end?
-   Will the computer user merely make random choices or will we program in some strategy based on user behavior?
-   Should we have some persistent data that stores previous results or a running win/loss count?
    -   If we save the data, where should we save it and when should we update the storage.
    -   When do we load the historical data?
-   How does the user quit or end the current game session?
-   Will we use the keyboard for input or will there be an interface for using a mouse?

Another important point to remember here is this is a **fun** puzzle to solve. Don’t get trapped into thinking there is *one right way* to meet these requirements. Think of the requirements as a creative writing prompt. The fun part is that now you get to come up with your own novel plan for meeting these requirements.

For this example, we have to decide about the answers to each of these questions before we move onto the planning phase.

-   **What happens at the start of the game?**   - *We should print out a welcome message to the user after they initialize the game.*
-   **What is the first thing the user will see when starting the game?**   - *They will see the welcome message and historical win/loss data.*
-   **How are points being tracked?**   - *We will track points in memory during a game and print out current score after each round. When the game ends we will save data to our data store.*
-   **At what point does the game end?**   - *The game will only end when the user quits the game.*
-   **Will the computer user merely make random choices or will we program in some strategy based on user behavior?**   - *For this first implementation of the game, let’s just have the computer make a random choice and not try to program in any strategy.*
-   **Should we have some persistent data that stores previous results or a running win/loss count?**   - *We will save our win/loss data to a text file that we will read from at the start of a new game and save to at the end of each game.*   - **If we save the data, where should we save it and when should we update the storage.**     - *We will save to a text file and update the file at the end of each game.*   - **When do we load the historical data?**     - *We will load the historical data from the text file at the start of a new game.*
-   **How does the user quit or end the current game session?**   - *The user will have the option to quit after each round of the game*
-   **Will we use the keyboard for input or will there be an interface for using a mouse?**   - *We will use keyboard input because this will be a Python terminal game.*

I think we’ve answered these questions in adequate detail to move on to the planning phase.

##### Plan

Now we need to take our project requirements and our answers to our questions and transform that information into a complete actionable plan that will produce the desired result. Remember, we will not be completing this problem in code but we will creating a plan of action and writing pseudo-code that will do it.

Let’s think of all the variables that will exist in our program first.

    ### necessary variables
    welcome_message
    historical_data_message
    quit_message
    win_message
    loss_message
    tie_message

    wins
    ties
    losses

    choice_options

    computer_choice
    user_choice

For now, we will just leave these as pseudocode, but next let’s think about the functionality of the game.

    ### procedures
    1. display welcome_message
    2. load historical_data and populate variables with data
    3. display historical_data_message with historical data
    4. prompt user to make a choice between rock, paper, scissors, or quit
      1. if quit, update text file with current wins, ties, losses data and exit game
      2. if not quit, move on to step 5
    5. computer makes a choice between rock, paper, and scissors
    6. compare user choice and computer choice
    7. display message based on result of comparison
    8. update wins, ties, losses appropriately
    9. return to step 4

So, now we’ve detailed what variables we need to use to store and interact with our data. We’ve also thought through and documented the sequential logic of our program.

We know that we have completed this step when we are confident we can start converting our pseudo-code into real code. I feel confident that we could do that.

##### Challenge

What you need to do is to take our pseudo-code one step further before writing code.

1.  Take the variable list and choose what data structure or data type you will use for each variable and document your choice.
2.  Take the list of procedures and come up with function names that will store related procedural code. For example, you may want to group all the procedural behavior that occurs when a user quits the game into a function named `quit_game`.

------------------------------------------------------------------------

#### Learn to create a Python program, demonstrate its successful performance, and explain the process used to create the program

Now that you’ve learned the basics, it time to put them to use for a more complex project. implementing a text adventure game.

##### Overview

Now, we need to write the simple Python terminal game. We will use the pseudo-code that we wrote during the previous objective:

    ### necessary variables
    welcome_message
    historical_data_message
    quit_message
    win_message
    loss_message
    tie_message

    wins
    ties
    losses

    choice_options

    computer_choice
    user_choice

    ### procedures
    1. display welcome_message
    2. load historical_data and populate variables with data
    3. display historical_data_message with historical data
    4. prompt user to make a choice between rock, paper, scissors, or quit
      1. if quit, update text file with current wins, ties, losses data and exit game
      2. if not quit, move on to step 5
    5. computer makes a choice between rock, paper, and scissors
    6. compare user choice and computer choice
    7. display message based on result of comparison
    8. update wins, ties, and losses
    9. return to step 4

##### Follow Along

Let’s do this part together. We are going to, step by step, transform our pseudocode into an actual working python program.

We will start by declaring all of our variables and assigning values to them:

    import random


    score =  {
        “wins”: 0,
        “ties”: 0,
        “losses”: 0
    }

    welcome_message = “Welcome to Rock, Paper, Scissors!”
    historical_data_message = “Wins: %s, Ties: %s, Losses: %s”
    quit_message = “Thanks for playing Rock, Paper, Scissors!”
    win_message = “Congratulations, you won!”
    loss_message = “Sorry, you lost!”
    tie_message = “It was a tie.”

    historical_data = # TODO: will need a function for loading historical data
    score[“wins”] = historical_data[“wins”]
    score[“ties”] = historical_data[“ties”]
    score[“losses”] = historical_data[“losses”]

    choice_options = {
        1: “rock”,
        2: “paper”,
        3: “scissors”,
        9: “quit”
    }

    computer_choice = random.randint(1, 3) # use the random module imported above
    user_choice = None

Now, we need to write out our procedural code by transforming our pseudo-code to actual Python code. We will look at our list of necessary procedures and logic and try to contain logical groupings into separate functions.

    import random


    score =  {
        “wins”: 0,
        “ties”: 0,
        “losses”: 0
    }

    welcome_message = “Welcome to Rock, Paper, Scissors!”
    historical_data_message = “Wins: %s, Ties: %s, Losses: %s”
    quit_message = “Thanks for playing Rock, Paper, Scissors!”
    win_message = “Congratulations, you won!”
    loss_message = “Sorry, you lost!”
    tie_message = “It was a tie.”

    historical_data = get_historical_data()
    score[“wins”] = historical_data[“wins”]
    score[“ties”] = historical_data[“ties”]
    score[“losses”] = historical_data[“losses”]

    choice_options = {
        1: “rock”,
        2: “paper”,
        3: “scissors”,
        9: “quit”
    }

    computer_choice = random.randint(1, 3)
    user_choice = None

    ### procedures
    ### 1. display welcome_message
    ### 2. load historical_data and populate variables with data
    ### 3. display historical_data_message with historical data
    ### 4. prompt user to make a choice between rock, paper, scissors, or quit
        # 4.1. if quit, update text file with current wins, ties, losses data and exit game
        # 4.2. if not quit, move on to step 5
    ### 5. computer makes a choice between rock, paper, and scissors
    ### 6. compare user choice and computer choice
    ### 7. display message based on result of comparison
    ### 8. update wins, ties, and losses
    ### 9. return to step 4

    ### 1. display welcome_message
    def show_welcome_message():
        welcome_message = “Welcome to Rock, Paper, Scissors!”
        print(welcome_message)

    ### 2. load historical_data and populate variables with data
    def get_historical_data():
        text_file = open(“history.txt”, “r”)
        text_data = text_file.read().split(“,”)
        text_file.close()
        return {
            “wins”: int(text_data[0]),
            “ties”: int(text_data[1]),
            “losses”: int(text_data[2])
        }

    ### 3. display historical_data_message with historical data
    def show_historical_data_message():
        print(historical_data_message %
              (score[“wins”], score[“ties”], score[“losses”]))

    ### 4. prompt user to make a choice between rock, paper, scissors, or quit
    def get_user_choice():
        choice = input(“[1] rock   [2] paper   [3] scissors    [9] quit\n”)
        return choice_options[int(choice)]

    ### 4.1. if quit, update text file with current wins, ties, losses data and exit game
    def quit_game(wins, ties, losses):
        text_file = open(“history.txt”, “w”)
        text_file.write(str(wins) + “,” + str(ties) + “,” + str(losses))
        text_file.close()

    ### 6. compare user choice and computer choice
    def compare_choices_and_get_result(user, computer):
        if user == computer:
            return “tie”
        elif (user == “rock” and computer == “scissors”) or (user == “paper” and computer == “rock”) or (user == “scissors” and computer == “paper”):
            return “win”
        else:
            return “loss”

    ### 7. display message based on result of comparison
    ### 8. update wins, ties, and losses
    def display_result_message_and_update_score(result):
        if result == “tie”:
            print(tie_message)
            score[“ties”] += 1
        elif result == “win”:
            print(win_message)
            score[“wins”] += 1
        else:
            print(loss_message)
            score[“losses”] += 1

We have all the individual pieces of our code. But, our code is a mess. And, we never figured out how we will loop through our game logic or quit when necessary. Now that we have all of this code there in front of us, it can be much easier to refactor. Let’s do that together.

*Note: we need to create a “history.txt” file with `0,0,0` as it’s only contents.*

The first thing we should do is move all the function definitions to the top of the file.

    import random


    def show_welcome_message():
        welcome_message = “Welcome to Rock, Paper, Scissors!”
        print(welcome_message)


    def get_historical_data():
        text_file = open(“history.txt”, “r”)
        text_data = text_file.read().split(“,”)
        text_file.close()
        return {
            “wins”: int(text_data[0]),
            “ties”: int(text_data[1]),
            “losses”: int(text_data[2])
        }


    def show_historical_data_message():
        print(historical_data_message %
              (score[“wins”], score[“ties”], score[“losses”]))


    def get_user_choice():
        choice = input(“[1] rock   [2] paper   [3] scissors    [9] quit\n”)
        return choice_options[int(choice)]


    def quit_game(wins, ties, losses):
        text_file = open(“history.txt”, “w”)
        text_file.write(str(wins) + “,” + str(ties) + “,” + str(losses))
        text_file.close()


    def compare_choices_and_get_result(user, computer):
        if user == computer:
            return “tie”
        elif (user == “rock” and computer == “scissors”) or (user == “paper” and computer == “rock”) or (user == “scissors” and computer == “paper”):
            return “win”
        else:
            return “loss”


    def display_result_message_and_update_score(result):
        if result == “tie”:
            print(tie_message)
            score[“ties”] += 1
        elif result == “win”:
            print(win_message)
            score[“wins”] += 1
        else:
            print(loss_message)
            score[“losses”] += 1

    score =  {
        “wins”: 0,
        “ties”: 0,
        “losses”: 0
    }

    welcome_message = “Welcome to Rock, Paper, Scissors!”
    historical_data_message = “Wins: %s, Ties: %s, Losses: %s”
    quit_message = “Thanks for playing Rock, Paper, Scissors!”
    win_message = “Congratulations, you won!”
    loss_message = “Sorry, you lost!”
    tie_message = “It was a tie.”

    historical_data = get_historical_data()
    score[“wins”] = historical_data[“wins”]
    score[“ties”] = historical_data[“ties”]
    score[“losses”] = historical_data[“losses”]

    choice_options = {
        1: “rock”,
        2: “paper”,
        3: “scissors”,
        9: “quit”
    }

    computer_choice = random.randint(1, 3)
    user_choice = None

So, now we have all of our function definitions and variable declarations at the top of our file. But, we haven’t used our functions and variables to write out the game loop for our game. This is a perfect scenario for the use of a `while` loop. We want to keep looping through our game logic unless the user has quit.

Let’s change our code again:

    def show_welcome_message():
        welcome_message = “Welcome to Rock, Paper, Scissors!”
        print(welcome_message)


    def get_historical_data():
        text_file = open(“history.txt”, “r”)
        text_data = text_file.read().split(“,”)
        text_file.close()
        return {
            “wins”: int(text_data[0]),
            “ties”: int(text_data[1]),
            “losses”: int(text_data[2])
        }


    def show_historical_data_message():
        print(historical_data_message %
              (score[“wins”], score[“ties”], score[“losses”]))


    def get_user_choice():
        choice = input(“[1] rock   [2] paper   [3] scissors    [9] quit\n”)
        return choice_options[int(choice)]


    def quit_game(wins, ties, losses):
        text_file = open(“history.txt”, “w”)
        text_file.write(str(wins) + “,” + str(ties) + “,” + str(losses))
        text_file.close()


    def compare_choices_and_get_result(user, computer):
        if user == computer:
            return “tie”
        elif (user == “rock” and computer == “scissors”) or (user == “paper” and computer == “rock”) or (user == “scissors” and computer == “paper”):
            return “win”
        else:
            return “loss”


    def display_result_message_and_update_score(result):
        if result == “tie”:
            print(tie_message)
            score[“ties”] += 1
        elif result == “win”:
            print(win_message)
            score[“wins”] += 1
        else:
            print(loss_message)
            score[“losses”] += 1

    score =  {
        “wins”: 0,
        “ties”: 0,
        “losses”: 0
    }

    welcome_message = “Welcome to Rock, Paper, Scissors!”
    historical_data_message = “Wins: %s, Ties: %s, Losses: %s”
    quit_message = “Thanks for playing Rock, Paper, Scissors!”
    win_message = “Congratulations, you won!”
    loss_message = “Sorry, you lost!”
    tie_message = “It was a tie.”

    historical_data = get_historical_data()
    score[“wins”] = historical_data[“wins”]
    score[“ties”] = historical_data[“ties”]
    score[“losses”] = historical_data[“losses”]

    choice_options = {
        1: “rock”,
        2: “paper”,
        3: “scissors”,
        9: “quit”
    }

    ### Start of Game
    show_welcome_message()
    show_historical_data_message()

    ### First user choice
    user_choice = get_user_choice()

    ### Game Loop
    while user_choice != “quit”:
        computer_choice = choice_options[random.randint(1, 3)]
        result = compare_choices_and_get_result(user_choice, computer_choice)
        display_result_message_and_update_score(result)
        user_choice = get_user_choice()

    ### Quit game if user exits game loop
    quit_game(score[“wins”], score[“ties”], score[“losses”])

Now, we have a functioning Rock, Paper, Scissors game!

##### Challenge

Our game could use some improvements. Take the ending code above and change it to add the following features:

1.  Besides the result message that gets display after every user choice, also display the computer’s choice and the current score.
2.  If the user quits, before exiting the program, display the current score.
3.  Besides prompting the user for their input for their choice, also display the previous round’s user choice and computer choice.

After adding those features, run your program to make sure everything is still working.

Now, sit down and write 1-2 paragraphs that explain the process you underwent to add the features to the program. Try not to just explain your new code, line-by-line, but describe your actual thought process and the high-level overview of what your new code does. Think of it the same way you would describe a painting/drawing of yours if someone asked you to explain your process. People don’t want to hear about every time you added more paint to your brush but they want to know why you chose the colors you did or your unique perspective on why you painted what you did.

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Intro to Python](https://github.com/LambdaSchool/Intro-Python-I)

    *Note: This project spans two modules (modules 1 and 2). You should roughly try to finish the first half of the problems during module 1 and the second half of the problems during module 2.*

    Toy programs designed to learn the basics of Python.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Introduction to Python II for CSPT12 w/Beej Jorgensen](https://youtu.be/ujKHsdRkx6U)**

    Learn to name and describe the details of each step of Lambda’s Problem Solving Framework

-   [All previous recordings](/archive/CS/module/recwpe3Y9TVWrGT8L)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    So that everyone gets to eat, there are some situations in which philosophers *should* pick up a chopstick, and some situations in which they *should NOT* (because another philosopher needs to use it).

    Write a better solution to the dining philosophers problem so that deadlock does NOT occur.

-   Objective challenge:

    What you need to do is to take our pseudo-code one step further before writing code.

    1.  Take the variable list and choose what data structure or data type you will use for each variable and document your choice.
    2.  Take the list of procedures and come up with function names that will store related procedural code. For example, you may want to group all the procedural behavior that occurs when a user quits the game into a function named `quit_game`.

-   Objective challenge:

    Our game could use some improvements. Take the ending code above and change it to add the following features:

    1.  Besides the result message that gets display after every user choice, also display the computer’s choice and the current score.
    2.  If the user quits, before exiting the program, display the current score.
    3.  Besides prompting the user for their input for their choice, also display the previous round’s user choice and computer choice.

    After adding those features, run your program to make sure everything is still working.

    Now, sit down and write 1-2 paragraphs that explain the process you underwent to add the features to the program. Try not to just explain your new code, line-by-line, but describe your actual thought process and the high-level overview of what your new code does. Think of it the same way you would describe a painting/drawing of yours if someone asked you to explain your process. People don’t want to hear about every time you added more paint to your brush but they want to know why you chose the colors you did or your unique perspective on why you painted what you did.

-   Project: Intro to Python
