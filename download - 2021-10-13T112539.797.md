Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Introduction to Python III

<span class="lead"> </span>

Learning new languages is a skill that is necessary for all developers. But a skill that’s more challenging but no less important is learning new _programming paradigms_. You’ve already been exposed to a number of different paradigms, potentially including _procedural_, _imperative_, _functional_, and _object-oriented_ (the one we’ll discuss in more detail in this module.

**At the end of this module, you should be able to:**

- name and describe each of the four pillars of object-oriented programming
- break down a set of project requirements to create a high-level plan for classes and the relationships between those classes
- demonstrate defining and instantiating classes in Python and describe the difference between a class and a class instance
- demonstrate usage of \_\_init\_\_, \_\_str\_\_, and \_\_repr\_\_ when defining a class in Python
- describe the convention for "private" methods and variables in Python
- explain the LEGB (Local, Enclosing, Global, Builtin) rule for variable scope in Python and demonstrate how it helps them understand Python code
- demonstrate the usage of class methods and class variables and explain the difference between these and instance methods and instance variables

#### Pro Tip

A witty saying proves nothing.

Voltaire

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=124f0YBJgro), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to name and describe each of the four pillars of object-oriented programming

##### Overview

### Object-oriented Programming

Object-oriented programming (OOP) is a way of writing computer programs to use “objects” to model _data_ and _behaviors_. Frequently, computer programs are just a list of instructions to the computer (procedural programming), telling the computer to do certain things in a certain way. However, in object-oriented programming, computer programs make use of “objects” that “talk” to one another to change the data in those objects. Also, because of the way a programmer designs an object-oriented program, other parts of the program or other people can easily reuse the code.

Most programming languages allow many ways of writing computer programs (multi-paradigm). For example, Python allows a developer to write programs using an object-oriented design or a procedural design.

### The Problem With Procedural Programming

The primary purpose of procedural programming is to break down a programming task into a collection of variables, data structures, and subroutines. This is the first approach many programmers learn because it is simple and straightforward. However, when writing larger computer programs that are likely more complex, it is easy for a procedural program to devolve into “spaghetti code”–a phrase for unstructured and difficult-to-maintain code.

### The Four Pillars of OOP

The four pillars of OOP are:

1.  Encapsulation
2.  Abstraction
3.  Inheritence
4.  Polymorphism

Below, we will discuss these pillars in greater detail and you will see how each of these concepts, when put into practice, can help a programmer avoid turning their programs into “spaghetti code”.

#### Encapsulation

The main point of representing an object in object-oriented design is to define the object’s public **interface** (the collection of attributes and methods that other objects can use to interact with the object). Other objects in the program need not access the _inner workings_ of that object.

The television is a real-world example. The interface to interact with the television is the remote control. Each button on the remote represents a method you can call on the television object. When we press “volume up” on the remote control, we don’t know or care what electronic signals are being sent to change the volume. The television is designed in such a way that those that interact with it through its common interface, the remote control, are free to not care or know about the _inner workings_ of the television.

In programming, hiding the implementation details of an object is called **encapsulation**.

One thing to note about this process is the need to design the public interface of your objects carefully. Once you’ve developed a large program with many interacting objects, changing the public interface can have cascading effects that are difficult to correct and keep track of. However, the benefit of encapsulation is you can change the _inner workings_ of your objects without having negative effects on your program. For example, imagine you’ve carefully designed an object’s public interface, but later you realize the inner workings are inefficient and are slowing down your program. You can go refactor the inner workings of that object to improve the efficiency and you won’t have to change the other objects in your program at all.

#### Abstraction

In its simplest terms, abstraction means dealing with the level of detail that is most appropriate to a task. It is important to remember that the objects in our program are not _real_ objects; they are _models_ of objects. A model car may look like the real thing on the outside, but the engine doesn’t run and the brakes likely don’t work. The model car is an **abstraction** of the real thing.

It is important to reach the correct level of abstraction for other objects that will interact with it. For instance, in order for a `Driver` object to drive a `Car` object, it needs to have access to a few attributes (`brakes`, `gas_pedal`) and a few methods (`steer()`, `change_gears()`, `apply_brakes()`).

![S1-Illustrations.001](https://i.imgur.com/OV8yunr.jpg)

However, a `Mechanic` object would need a different level of abstraction to interact with the `Car` object. In order for the `Mechanic` to repair the `Car`, it would need access to the `disc_brakes`, `fuel_injected_engine`, and `automatic_transmission` attributes. It would also need access to the `adjust_brake()` and `change_oil()` methods.

![S1-Illustrations.002](https://i.imgur.com/O9d9XkQ.jpg)

Obviously, this is a contrived example, but it illustrates how it is important to be thoughtful on what the right level of abstraction is when designing your objects so that the rest of the objects in your program can interact with that object effectively.

One tip to achieve the right level of abstraction is to only model _exactly_ what the system needs to perform. Don’t model what the system _might_ need. By targeting exactly what the system needs, you are more likely to achieve the correct level of abstraction for your program.

#### Inheritance

There are many types of relationships that you can model between objects. Inheritance describes the relationship where, “The dog _is an_ animal” or where “The teacher _is an_ employee”.

Inheritance is like a family tree. A person could say that they inherited their last name and their brown eyes from their grandfather. Similarly, inheritance allows our object classes to inherit attributes and methods from other classes in the program.

For example, we could create an `Animal` class that has attributes and methods that all animals within our program possess. However, we may want to create a `Dog` class that has all the `Animal` attributes and methods as well as dog-specific attributes and methods.

#### Polymorphism

Polymorphism is the ability to treat a class differently depending on which subclass is implemented.

For example, let’s say we modeled a game of chess in our program. We created a `Board` class that can accept a move from a `Player` class. Now, the `Board` will call a move function on the `Piece` class. Each of the six pieces are subclasses of the `Piece` class (`Rook`, `Bishop`, `King`, `Knight`, `Queen`, and `Pawn`). Each of these classes has a specific `move` method that overrides the `move` methods on the parent classes.

So, the `Board` class has a `move` method available on its interface. The `Board` class need not know what type of piece it is dealing with when it calls `move`, because the subclasses override that method. This is an example of Polymorphism.

##### Challenge

In your own words, write a short paragraph describing each of the four pillars of OOP.

---

#### Learn to break down a set of project requirements to create a high-level plan for classes and the relationships between those classes

##### Overview

When analyzing the problem you’re trying to solve, it’s important to identify all the objects that you will eventually represent with classes in your code. By spending time up front identifying all the necessary objects, you will make sure that you design all the interfaces at the correct level of abstraction.

### A Starting Point

A good starting point is to describe your problem in detailed sentences. Once you have some text that describes your general problem, you then go through and find all of the nouns in the text. The nouns then become the classes in your program. Any verbs associated with a noun become methods on the class. Any adjectives associated with the noun become the attributes on the class.

This can be an excellent starting point, however there are a few things to be careful of. A proficient programmer will use built-in data structures until there is a need to define a class. If an object has only data, then a built in structure like a list, set, or dictionary might be more appropriate than a class. If an object only has behavior and no stored data, then defining a function may be a better choice.

All this to say, that despite there being common advice given as a starting point for designing your program and choosing your classes, there is no silver bullet. It’s often necessary to think more deeply in order to avoid unnecessary abstraction.

### Self-Documenting

When programmers first start writing object-oriented code, a common complaint is that they end up writing more code to accomplish the same task than they would if they just wrote simple procedural code.

One thing to note is that object-oriented code, although at times more verbose, often ends up being self-documenting and much easier to read. Code length is not a good indicator of code complexity, and by the time we documented the procedural code, it would likely be as long as the object-oriented version.

##### Follow Along

Together, we are going to model an online store in Python.

The first thing to consider is what “objects” we need to model for an online store? Who are the users of the store? What does the store contain?

Let’s start by describing the situation in a few simple sentences:

> “We need to design an online store where customers can purchase products from vendors. Vendors need to be able to create the products that customers can then purchase.”

After a minute or two of thinking about the sentences above, we’ve come up with a list of objects that we need to model in our program:

- Users
  - Customers
  - Vendors
  - Admin
- Products
- Purchases

Before we starting writing code, let’s think about what attributes are required for each of these objects:

- Users
  - Attributes
    - name
    - is the user an admin?
  - Customers
    - Attributes
      - name
      - a collection of purchases
  - Vendors
    - Attributes
      - name
      - a collection of products
  - Admin
    - name
    - a flag that the user is an admin
- Products
  - Attributes
    - name
    - price
    - vendor
- Purchases
  - Attributes
    - product
    - customer
    - price
    - date and time info about when the purchase was completed

We also need to think about the relationships between these objects before we start writing our code:

- Sellers have products (one to many)
- Customers have purchases (one to many)
- Purchases have products (one to many)

Let’s now start writing our code. We will begin by making our User class:

    class User:
        def __init__(self, name, is_admin=False):
            self.name = name
            self.is_admin = is_admin

Now, this will serve as our base User class that all user types will inherit from. We now need to define three more classes, one for each user type:

    class User:
        def __init__(self, name, is_admin=False):
            self.name = name
            self.is_admin = is_admin

    class Admin(User):
        def __init__(self, name):
            super().__init__(name, is_admin=True)

    class Customer(User):
        def __init__(self, name):
            super().__init__(name)
            self.purchases = []

    class Vendor(User):
        def __init__(self, name):
            super().__init__(name)
            self.products = []

For the `Admin` class, we inherit from `User` and then call `User`’s `__init__()` method making sure to override the default `False` value for `is_admin`.

For the `Customer` class, we also inherit from `User` and call `User`’s `__init__()` method. This time, we can allow the default `False` value for `is_admin`, so we don’t pass in anything. Additionally, we set an attribute for `purchases` to an empty list.

For the `Vendor` class, we do the exact same thing as we did with the `Customer` class, except we set a `products` attribute to an empty list insead of `purchases`.

The objects we are still missing are for a product and a purchase. Let’s set those up now:

    from datetime import datetime

    class User:
        def __init__(self, name, is_admin=False):
            self.name = name
            self.is_admin = is_admin

    class Admin(User):
        def __init__(self, name):
            super().__init__(name, is_admin=True)

    class Customer(User):
        def __init__(self, name):
            super().__init__(name)
            self.purchases = []

    class Vendor(User):
        def __init__(self, name):
            super().__init__(name)
            self.products = []

    class Product:
        def __init__(self, name, price, vendor):
            self.name = name
            self.price = price
            self.vendor = vendor

    class Purchase:
        def __init__(self, product, customer):
            self.product = product
            self.customer = customer
            self.purchase_price = product.price
            self.purchase_data = datetime.now()

Notice that the classes for `Product` and `Purchase` do not inherit from any other classes. They simply initialize the attributes that we came up with in our plan. One other thing to note is that because we needed to use `datetime.now()` method to populate our `purchase_data` attribute, we needed to import that module. We did that with the line at the top that reads `from datetime import datetime`.

We aren’t quite done modeling all of the attributes and relationships we thought of in our plan. We still need a way for a `Vendor` to create a product and add it to it’s `products` attribute. Additionally, we still need a way for a `Customer` to purchase a product and add it to it’s `purchases` attribute. Let’s do that now:

    from datetime import datetime

    class User:
        def __init__(self, name, is_admin=False):
            self.name = name
            self.is_admin = is_admin

    class Admin(User):
        def __init__(self, name):
            super().__init__(name, is_admin=True)

    class Customer(User):
        def __init__(self, name):
            super().__init__(name)
            self.purchases = []
        def purchase_product(self, product):
            purchase = Purchase(product, self)
            self.purchases.append(purchase)

    class Vendor(User):
        def __init__(self, name):
            super().__init__(name)
            self.products = []
        def create_product(self, product_name, product_price):
            product = Product(product_name, product_price, self)
            self.products.append(product)

    class Product:
        def __init__(self, name, price, vendor):
            self.name = name
            self.price = price
            self.vendor = vendor

    class Purchase:
        def __init__(self, product, customer):
            self.product = product
            self.customer = customer
            self.purchase_price = product.price
            self.purchase_data = datetime.now()

Now, our `Vendor` class has a `create_product` method that will allow us to create products and store them with a specific `Vendor` instance. Our `Customer` class now has a `purchase_product` method that allows a `Customer` instance to make purchases and store records of those purchases on the instance.

##### Challenge

Use the planning strategy and process demonstrated above to design a parking lot. This is a common OOP interview question and the time you spend thoughtfully thinking through this problem will be helpful.

As you design your solution, and think through all of the necessary objects, attributes, methods, and relationships, keep the following in mind:

- Payments
  - What methods are allowed?
  - Where do customers pay?
- Capacity
  - How does the system respond when the lot is full?
  - How does the system know when the lot is full?
- Vehicles
  - Is capacity allocated differently depending on what type of vehicle enters the lot? How so?
- Pricing
  - Are there different rates for different times of day? How will this be handled?
  - Is there a discount for purchasing a longer total time?

---

#### Learn to demonstrate defining and instantiating classes in Python and describe the difference between a class and a class instance

##### Overview

### Defining Our First Class

It is easy to see why Python is known as a “clean” language. When we want to do something in Python, well, we just do it!

The simplest class in Python 3 looks like this:

    class MyFirstClass:
        pass

We are now writing object-oriented code in Python. We define the class by starting with the reserved `class` keyword. Then, we write the name of the class and terminate the line with a colon.

_Note: PEP 8 recommends that classes be named using **CamelCase** notation (start with a capital letter and any subsequent words also start with a capital letter)._

After the class definition, we have the contents of the class indented below. In Python, indentation is used, rather than braces or brackets to delimit the class definition. In our example, we simply added the `pass` keyword to indicate that no further action be taken. This is acting essentially as a placeholder.

### Instantiating a Class

So we’ve defined a class, but we haven’t actually done anything with it. It would be like creating a blueprint for a house but never building the house. In order to “create the house”, we have to _instantiate_ the class.

    >>> class MyFirstClass:
    ...     pass
    ...
    >>> a = MyFirstClass()
    >>> b = MyFirstClass()
    >>> print(a)
    <__main__.MyFirstClass object at 0x107dcf340>
    >>> print(b)
    <__main__.MyFirstClass object at 0x107d3f670>
    >>>

First, we defined `MyFirstClass` in the interpreter. Then, we store _instances_ of the class in variables `a` and `b`. Finally, we printed out `a` and `b`. Notice that when we print out `a` and `b`, we can see that those objects are of type `MyFirstClass` and are stored at two unique memory addresses.

As you can see, creating an instance of a class is as simple as typing the class name followed by a pair of parentheses. Even though it looks just like we are calling some function `MyFirstClass()`, we are actually calling the `__init__()` function that creates all of our class’s attributes and assigns them their initial values. If we don’t define our own, we inherit `__init__()` from the base `Object` class.

By printing the objects, Python tells us which class the objects are and what memory address they live at. We don’t actually use the memory addressed but this shows that we did in fact create two distinct objects in memory.

##### Challenge

Open a Python interpreter and complete the following:

1.  Define a class
2.  Instantiate the class twice, storing each instance in a separate variable.
3.  Print out the two class instances and make sure they are showing the class that you created and two distinct locations in memory.

---

#### Learn to demonstrate usage of \_\_init\_\_, \_\_str\_\_, and \_\_repr\_\_ when defining a class in Python

##### Overview

##### **init**

Most object-oriented languages have the concept of a **constructor**. A constructor is a special method that initializes an object when it is created.

_Note: Python is unique in that it has a constructor method and an initialization method. However, the constructor method is only used if you are doing something rare and exotic. We will focus on the initialization method here._

The `__init__` method is just like any other method except for its special name. The leading and trailing double underscores denote that this is a special method that the Python interpreter will treat as a special case.

Let’s create a `Student` class and define an `__init__` method on it.

    >>> class Student:
    ...     def __init__(self, first_name, last_name):
    ...          self.first_name = first_name
    ...          self.last_name = last_name
    ...
    >>>

Notice the first argument `self` that is passed into the `__init__` method. This is the primary difference between methods defined on an object and a normal function. All methods have one required argument. Conventionally, we name this argument `self` (although, in reality, we could name it anything we wanted). The `self` argument is simply a reference to the object that the method is being invoked on.

The next two arguments that we pass into the `__init__` method, we are calling `first_name` and `last_name`. Notice in the body of the method, we are storing the values of those arguments in attributes on the object itself.

Now, we have a blueprint for a `Student` object, but we haven’t actually created any instances of a `Student` yet. Let’s do that now:

    >>> student = Student("John", "Lennon")
    >>> print(student.first_name, student.last_name)
    John Lennon
    >>> print(student)
    <__main__.Student object at 0x105608340>
    >>>

What do you think would happen if we try to instantiate a `Student` class without passing in the `first_name` and `last_name` arguments? Let’s try it out:

    >>> student = Student()
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    TypeError: __init__() missing 2 required positional arguments: 'first_name' and 'last_name'
    >>>

Notice that the error message tells us that we are missing two positional arguments that are required to instantiate the `Student` object.

Whenever you define a class, the `__init__` method is where you define the _initialization_ behavior required to create a new instance of that class.

##### **str**

The `__str__` method is special just like `__init__`. The `__str__` method is supposed to return a string representation of an object (which is useful for debugging).

For an example, let’s look at the `__str__` method that is defined for `Time` objects:

    ### inside class Time:

    def __str__(self):
            return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)

When you `print` an object, Python calls the `__str__` method to determine what to print out. Compare the `__str__` method definition above to the output below.

    >>> time = Time(3, 17)
    >>> print(time)
    03:17:00

Whenever you are defining a new class, you should start by defining the `__init__` method so you can instantiate objects. The next thing you should do is define the `__str__` method so you have useful information for debugging.

##### **repr**

`__repr__` is similar to `__str__` in that it will return a printable representation of the object. However, with `__repr__` it will return _one_ of the ways possible to create the object.

For example, let’s say we have a `Point` class like this:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

Below, you can see how the interpreter represents an instance of `Point`:

    >>> point = Point(1, 2)
    >>> point
    <__main__.Point object at 0x10d814340>
    >>>

As you can see, this isn’t that helpful as a developer. What we might really want to know is how we could recreate that object. By defining a `__repr__` method on the `Point` class, we can do that:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        def __repr__(self):
            return 'Point(x=%s, y=%s)' % (self.x, self.y)

Now, look at how the interpreter returns a representation of the object when we access it:

    >>> point = Point(1, 2)
    >>> point
    Point(x=1, y=2)
    >>>

##### Challenge

Open a python interpreter and complete the following:

1.  Define a class
2.  In the class definition, define the `__init__`, `__str__`, and `__repr__`.
3.  Instantiate the class and store the instance in a variable.
4.  Interact with the variable to test that the `__str__` and `__repr__` methods are working as you’d expect based on your definition.

---

#### Learn to describe the convention for "private" methods and variables in Python

##### Overview

### “Private” Data and Name Mangling

Most object-oriented languages have a concept of access control. This means that some attributes and methods on an object are marked private. By marking them private, only that object can access them.

Python is different and does not do this. Python doesn’t enforce laws that someday might get in your way. The Python way is to provide unenforced guidelines and best practices instead. In Python, all methods and attributes on a class are publicly available. If we want to suggest that something not be used publicly, we can make a note in docstrings stating that the method is meant for internal use only.

It is also the convention to prefix an attribute or method with an underscore character `_`. Other Python programmers will see this and recognize it as a flag for an internal variable. However, the interpreter will still allow direct access.

To _strongly suggest_ that outside objects not access a property or method, we can add a double underscore `__` as a prefix. This causes the interpreter to perform _name mangling_ on the attribute. Essentially, an outside object could still access the internal data, but they will have to try a bit harder to do so.

    >>> class Point:
    ...     def __init__(self, x, y):
    ...         self.x = x
    ...         self.y = y
    ...         self.__private_name = "This is private."
    ...
    >>> my_point = Point(1, 2)
    >>> my_point.__private_name
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    AttributeError: 'Point' object has no attribute '__private_name'
    >>> my_point._Point__private_name
    'This is private.'
    >>>

We defined a `Point` class and added a “private” attribute called `__private_name`. Notice how when we try to access the attribute directly on the class instance, the interpreter throws an error. This is what name mangling does. However, see how the attribute is still directly accessible if we _really want to_. It’s as simple as prefixing a single underscore and the class name before the attribute name `_Point__private_name`. This is what _name mangling_ is.

### The `property` Keyword

Python gives us the `property` keyword in order to make methods look like attributes. For instance, let’s say that we want to perform some sort of validation whenever someone sets an attribute. Maybe we want to prevent someone from setting an attribute to an empty string. We can do this in Python by defining “private” _getter_ and _setter_ methods and a “private” attribute on the class. Then, we can use the _magic_ `property` keyword to wire up the _getter_ and _setter_. The code below will make it clear how this works.

    >>> class Color:
    ...     def __init__(self, rgb_value, name):
    ...         self.rgb_value = rgb_value
    ...         self._name = name
    ...     def _set_name(self, name):
    ...         if not name:
    ...             raise Exception("Invalid Name")
    ...         self._name = name
    ...     def _get_name(self):
    ...         return self._name
    ...     name = property(_get_name, _set_name)
    ...
    >>> c = Color("#0000ff", "bright red")
    >>> print(c.name)
    bright red
    >>> c.name = "red"
    >>> print(c.name)
    red
    >>> c.name = ""
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        File "<stdin>", line 7, in _set_name
    Exception: Invalid Name
    >>>

##### Challenge

Open a Python interpreter and complete the following:

1.  Define a class that makes use of a “private” getter and setter for a “private” attribute.
2.  Use the `property` decorator to “wire up” the getter and setter methods for accessing the property on an instance.
3.  Instantiate the class and store the instance in a variable.
4.  Test that the getter and setter methods are working when getting the attribute’s value and setting the attribute’s value.

---

#### Learn to explain the LEGB (Local, Enclosing, Global, Builtin) rule for variable scope in Python and demonstrate how it helps them understand Python code

##### Overview

All programming languages include rules about scope. Essentially, scope rules specify when variables can be accessed at a given place in the program.

In Python, we can remember the scope rules using the LEGB acronym.

1.  **L**ocal
2.  **E**nclosing
3.  **G**lobal
4.  **B**uiltin

The order matters. The interpreter will first search the Local scope, then Enclosing, Global and Built-in.

### Local

The Local scope will always be searched first and includes any variables assigned within a function.

    >>> x = 1
    >>> y = 2
    >>> def my_function(x):
    ...     y = 3
    ...     print(x, y)
    ...
    >>> my_function(10)
    10 3
    >>> print(x, y)
    1 2
    >>>

For the `print` function call within `my_function`, the `x` defined as the function parameter will be found first. Also, the definition for `y` on line #4 will be found first.

For the `print` function call made outside of `my_function`, there is no Local scope, only Global scope.

### Enclosing

Python allows functions to be nested. When searching for a variable, Python starts by looking in Local, and then searches the Enclosing scope.

    >>> x = 100
    >>> def my_outer_function(x):
    ...     y = 50
    ...     def my_inner_function():
    ...         print(x, y)
    ...     my_inner_function()
    ...
    >>> my_outer_function(75)
    75 50
    >>>

For the `print` function call on line #5 inside `my_inner_function`, to find `x`, it will first search `my_inner_function` and then `my_outer_function` where the parameter is defined. To find `y` on line #5, it will first search `my_inner_function`, then `my_outer_function` where it will find the definition on line #3.

### Global

Global scope is search after Local and Enclosing. Global is the simplest to understand. A variable declared at the global level is not enclosed inside any function.

    >>> x = 10
    >>> print(x)
    10
    >>>

One thing to remember is that in Python a variable must be _defined before it is referenced._

    >>> print(x)
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    NameError: name 'x' is not defined

### Builtin

If a variable is not found in Local, Enclosing, or Global scope, then the builtin variables are searched.

    >>> pow(2, 3)
    8
    >>> __name__
    '__main__'
    >>> len('cat')
    3

You can see above, how even though `pow`, `__name__` and `len` were not defined in the program, no errors were thrown. That is because these are found in the Builtin scope.

You can find all builtin variables by typing `dir(__builtins__)`:

    >>> dir(__builtins__)
    ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
    >>>

### `global` Keyword

We can declare a global variable in a function by using the `global` keyword.

    >>> def my_function():
    ...     global x
    ...     x = 100
    ...
    >>> my_function()
    >>> print(x)
    100
    >>>

By stating that the `x` variable is global inside `my_function`, it can now be referenced in the global scope. However, that function must be called for this to take place.

    >>> def my_function():
    ...     global x
    ...     x = 100
    ...
    >>> print(x)
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    NameError: name 'x' is not defined
    >>>

Because `my_function` was never called, the `x` variable does not exist.

### No New Scope

`if`, `elif`, or `else` blocks **do not** declare a new scope. The variable is defined in whatever scope the block itself is in. In the case below, `y` will be defined in the Global scope.

    >>> x = 100
    >>> if x > 0:
    ...     y = 50
    ...
    >>> print(y)
    50
    >>>

Also, the variables declared inside one of these blocks only exist if the block is entered. If the block is not entered, then that variable will not defined. In the example below, since the if block is never entered, `y` is not defined.

    >>> x = 0
    >>> if x > 0:
    ...     y = 50
    ...
    >>> print(y)
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    NameError: name 'y' is not defined
    >>>

##### Challenge

In your own words, write a paragraph that describes how variable scope works in Python. Do your very best to refer the writing above as little as possible. The more effort you put into writing the explanation in your own words, the better you will be able to recall this information in the future.

---

#### Learn to demonstrate the usage of class methods and class variables and explain the difference between these and instance methods and instance variables

##### Overview

### Instance vs. Class

Some attributes and methods are part of the class itself and some are part of the objects that are created using that class as a blueprint (instances).

When looking at a class definition, if you see an initial `self` argument on a method, then you know that it is an _instance method_. The `self` keyword is referencing the object instance that was created from the class, not the class itself. These are the types of methods you normally write when you create your own classes. The `exclaim` method on the `Car` class is a good example of a simple instance method.

    >>> class Car():
    ...     def __init__(self, name):
    ...         self.name = name
    ...     def exclaim(self):
    ...         print(f"I'm a Car! My name is {self.name}")
    ...
    >>> my_car = Car("Herby")
    >>> my_car.exclaim()
    I'm a Car! My name is Herby
    >>>

A _class method_ affects the class as a whole, not just the specific instance. Any change you make to the class (blueprint) affects all of the instances of that class.

Within a class definition, a preceding `@classmethod` decorator indicates that the following function is a class method. Also, the first parameter to the method is the class itself. The Python tradition is to name this parameter `cls` (because `class` is a reserved keyword).

Below, we will define a class `Counter` that has a _class method_ that will return the number of instances that exist for that class.

    >>> class Counter():
    ...     count = 0
    ...     def __init__(self):
    ...         Counter.count += 1
    ...     def exclaim(self):
    ...         print("I'm a Counter!")
    ...     @classmethod
    ...     def children(cls):
    ...         print(f"Counter class has {cls.count} instances that have been created")
    ...
    >>> counter_one = Counter()
    >>> counter_two = Counter()
    >>> counter_three = Counter()
    >>> Counter.children()
    Counter class has 3 instances that have been created
    >>>

In the `__init__` method, notice that we are incrementing `Counter.count` and not `self.count`. The `count` attribute is on the class itself and not on the instances.

Another way of achieving the same result is to not use the `@classmethod` decorator at all. You can do this by referencing the classname and not the instance. Some programmers prefer this method when defining class methods. See below for an example:

    >>> class Counter():
    ...     count = 0
    ...     def __init__(self):
    ...         Counter.count += 1
    ...     def children():
    ...         print(f"Counter class has {Counter.count} instances that have been created")
    ...
    >>> c = Counter()
    >>> c2 = Counter()
    >>> Counter.children()
    Counter class has 2 instances that have been created

The difference is in the `children()` method. Notice how there is no decorator above the method and therefore `cls` is not being passed into the method. In order to reference the class and not the instance in the `print` method, `Counter.count` is used.

##### Challenge

Open a Python interpreter and complete the following:

1.  Define a class that has a class method that references a class attribute when called.
2.  Do this once using the `@classmethod` decorator and a second time without using the decorator.
3.  Reflect on which method you prefer and why.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Intro to Python II](https://github.com/LambdaSchool/Intro-Python-II)

  A short introduction to object-oriented-programming concepts in Python.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Introduction to Python III for CS35 w/ Tom Tarpey](https://youtu.be/vGSQIModvbc)**

  Learning new languages is a skill that is necessary for all developers. But a skill that’s more challenging but no less important is learning new programming paradigms. You’ve already been exposed to a number of different paradigms, potentially including procedural, imperative, functional, and object-oriented (the one we’ll discuss in more detail in this module.

- [All previous recordings](/archive/CS/module/reca7NYptklr7F403)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  In your own words, write a short paragraph describing each of the four pillars of OOP.

- Objective challenge:

  Use the planning strategy and process demonstrated above to design a parking lot. This is a common OOP interview question and the time you spend thoughtfully thinking through this problem will be helpful.

  As you design your solution, and think through all of the necessary objects, attributes, methods, and relationships, keep the following in mind:

  - Payments
    - What methods are allowed?
    - Where do customers pay?
  - Capacity
    - How does the system respond when the lot is full?
    - How does the system know when the lot is full?
  - Vehicles
    - Is capacity allocated differently depending on what type of vehicle enters the lot? How so?
  - Pricing
    - Are there different rates for different times of day? How will this be handled?
    - Is there a discount for purchasing a longer total time?

- Objective challenge:

  Open a Python interpreter and complete the following:

  1.  Define a class
  2.  Instantiate the class twice, storing each instance in a separate variable.
  3.  Print out the two class instances and make sure they are showing the class that you created and two distinct locations in memory.

- Objective challenge:

  Open a python interpreter and complete the following:

  1.  Define a class
  2.  In the class definition, define the `__init__`, `__str__`, and `__repr__`.
  3.  Instantiate the class and store the instance in a variable.
  4.  Interact with the variable to test that the `__str__` and `__repr__` methods are working as you’d expect based on your definition.

- Objective challenge:

  Open a Python interpreter and complete the following:

  1.  Define a class that makes use of a “private” getter and setter for a “private” attribute.
  2.  Use the `property` decorator to “wire up” the getter and setter methods for accessing the property on an instance.
  3.  Instantiate the class and store the instance in a variable.
  4.  Test that the getter and setter methods are working when getting the attribute’s value and setting the attribute’s value.

- Objective challenge:

  In your own words, write a paragraph that describes how variable scope works in Python. Do your very best to refer the writing above as little as possible. The more effort you put into writing the explanation in your own words, the better you will be able to recall this information in the future.

- Objective challenge:

  Open a Python interpreter and complete the following:

  1.  Define a class that has a class method that references a class attribute when called.
  2.  Do this once using the `@classmethod` decorator and a second time without using the decorator.
  3.  Reflect on which method you prefer and why.

- Project: Intro to Python II
