<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Composing React Components and Passing Data Via Props

<span class="lead"> </span>

As you build bigger applications, you’ll want to start splitting up your app into smaller pieces so that it is easier to work on and maintain. These small pieces you will build are called components. Components will need to share state, so we will learn how to do this with a helper object called `props`.

**At the end of this module, you should be able to:**

- use JavaScript modules to export and import components
- describe props and how data flows in a React application
- demonstrate the ability to compose React components to build out a UI
- pass props as dynamic data to a React component

#### Pro Tip

All things in moderation, including moderation.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=EOuwkNt-MCU), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=ZBzHw78nzQM), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=5lzKaiC8ask), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=PDLixDiT-BA), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to use JavaScript modules to export and import components

At this point in the curriculum you are familiar with several concepts for addressing problems with specificity and context. Just as closure and scope describe what information can be reached within a function or block of code, modules are a pattern that describes the process for accessing information from one file to another. Modules act as a sort of barrier to our code, and results in the programs we write having greater value. The practices used today are highly effective, and still in their infancy. The following section will discuss past methods for passing JavaScript files, and the huge leap forward we’ve undergone with the latest ES6 version of JS Modules.

##### Overview

When JavaScript was first introduced, inserting it into a web application meant writing the code inside of a script tag inside of an HTML file. The script ran sequentially, that is, from top to bottom. Back then, if you wanted to use the same code in another project, you had to copy and paste it. There were also performance issues - namely, functions and variables were all global - if you weren’t careful, you could quickly see the trouble with declarations holding unexpected values. Eventually, including a `<src>` attribute did allow for more reusability, but it was still dependant on order and still globally scoped.

Then, a little over ten years ago, developers used module patterns like IIFE (Immediately Invoked Function Expression, pronounced ‘iffy’). This function runs as soon as it is defined. Take the seemingly normal looking code below. On closer inspection, you’ll notice the enclosing parentheses wrapping the anonymous function, as well as another set of calling parentheses, which results in the immediate execution of the code. While this keeps the global space tidy and grants privacy to any inner variables, it’s somewhat fragile and none too eloquent.

    (function() {
      //lexically enclosed function statement
    })();

You can read more about the history of programming modules and IIFE [here](https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-stop-feeling-iffy-about-using-an-iife-7b0292aba174)

### Server side JS

The release of Node.js in 2009 meant that JavaScript could now execute outside of the browser. With the adoption of a common JavaScript specified standard library known as CommonJS, we now have defined terms for sending data to and from our file systems. These advances were a complete game-changer for JavaScript developers, but all still relied heavily on third-party bundlers and transpilers to address common issues. Tools like webpack and rollup would compile packs of modules and assign any missing dependencies before sending them off to the browser. Transpilers such as Babel handle translating source code for the browser and convert the latest features of ES6 (any not supported in the browser) into compatible ES5. While handy, all of these programs require downloading, updating, and configuring.

### JS modules (ECMAScript modules)

This brings us to today. The first standardized syntax for using modules in JavaScript. Where past methods relied on specific functions or third-party libraries, with the latest version of JS, we can now export functions, data, components from our files by merely prefixing the `export` keyword. Then, when we want to bring such features into our file, we use the `import` keyword, the name of the exported item, and specify where it’s located. And that’s basically it. No dependencies or configurations, everything is ready to go right out of the box.

##### Follow Along

Let’s go through some examples. If you open a new codesandbox and create a few different files, you can try this out.

_`export` exports a single named function that can now be imported into another module using the import keyword_

    export const emphasize = str => {
      return str.toUpperCase();
    };

_When `export default` is specified (either inline or at the end of the file) the declaration that follows is exported by default and additional modules will need to be exported (and imported) by name._

    const emphasize = str => {
      return str.toUpperCase();
    };

    export default emphasize;

Multiple items exported from one module can then either be imported into separate modules or can all be extracted for use with object destructuring in the import declaration (see Import examples below).

When set up properly, this pattern is incredibly efficient; the majority of errors being syntactical, or from renaming or changing your file structure. Another advantage of modules is that top-level variables do not pollute the global object. In addition to connecting our project files, bringing in a library or an external component to our project is a matter of downloading it with our CLI and then directly importing it to our file. Fonts, loaders, middleware, pretty much anything you need. We won’t go into any detail about any of these libraries right now but refer to the docs for download commands and directions for implementation. For now, let’s take a better look at the import and export line syntax.

Importing a file/module starts with declaring the `import` keyword followed by the name of the import, then the `from` keyword followed by the `module specifier`. The module specifier usually is a file path or an npm module name. We will be working with file paths today.

Import examples

- A single named export

  import { a } from './directory/fileName'

- Multiple named exports

  import { item1, item2, item3 } from './directory/items.js'

- Exported as default

  import Component from './folderName/Component.js'

**File path specification**

The prefixing ‘./’ on the file URL points to a unique location of your file system. It indicates the file for import is exported elsewhere in the current directory. When the file is read, the loader knows where it is located in the directory tree. Adding an additional dot (‘../’) to the path will indicate a location one directory higher. Use the table below to reference quick file location indicators.

<table><thead><tr class="header"><th>File Location</th><th>Path prefix</th></tr></thead><tbody><tr class="odd"><td>Current Directory</td><td>./</td></tr><tr class="even"><td>Parent Directory</td><td>../</td></tr><tr class="odd"><td>Parent of Parent Dir</td><td>../../</td></tr></tbody></table>

##### Challenge

Using the codesandbox you’ve been trying this out in, make a React component in one file that is exported as the default export, and see if you can import it and render it in the `App` component. This is a good chance to try it out on your own before we do it together later.

---

#### Learn to describe props and how data flows in a React application

Understanding how data flows throughout a React app is a crucial aspect of the development process when using the React library. While other frameworks often rely on multi-directional data flow, in React we utilize a top to bottom strategy when passing data. You know about state data and how to implement it into an application using the state hook. Now we’re going take a look at what we can do with that data and how we use it to build reliable and reusable UI components.

##### Overview

### What are props?

When we want to pass information held on state inside one component to another component, we pass them as **props**. We’ll learn plenty about the how and why of props, but for now, the important thing to remember is that we never make changes to props data - props are read-only. This helps ensure that our data flow remains clean and organized. This way, we know exactly where changes are made to our application. And if something goes wrong, we can find the issue and fix it. Imagine an application with data changes occurring in every file. How easy would it be to understand how it worked, and how long would it take to locate a problem with the code?

### Managing state and props within components

A stateful component is one that holds state data, either as an object placed inside the constructor function, or a function component that includes the `.useState` function made available in the React v16.8 release (the one with hooks). We’ll be learning about function components for now; you’ll see class components later in the curriculum.

When data comes into our application, it is loaded and stored on state, either in a centralized component specifically for state management, or a component rendering other components. When data is consumed in multiple components, it is probably best to centralize that data in state in a top-level component. Other data that is specific to a certain component can live locally, just inside that component. Components rendered in a stateful component can receive state data via a props attribute. Here, it can be sent down on the props object to the child component, and there we can access it just like we would with most any other object. However, if we decide we want to make any change to our data **we do not** change the prop data itself. Instead, we send back what changes we should make to our state holding component; often, stored changes are sent back up to the parent container as enclosed information in a called function. You’ll learn plenty more about sending data in the coming days and weeks. For now, let’s take a closer look at class components and function components, and how they differ for holding state.

##### Follow Along

Take the following example of data we’ll be passing, a simple user object holding two key/value pairs.

    const user = { name: "Hubert", age: 27 };

Next, we save our user object to a state variable using the state hook you learned in the previous lesson. Then, we declare a named prop object inside the JSX in our return statement and set it equal to the state variable. The naming convention may appear confusing at first glance, but try to understand which ‘user’ name is the props object, and which is referencing the state variable. It makes sense for them to have the same name because the data is identical. That said, their intended use is not. Once data is set as props data, it is no longer state data and should never be mutated. If you wish to change the value of the props data, it must be done using the provided setUser function.

    const App = () => {
      const [user, setUser] = useState({ name: "Hubert", age: 27 });

      return <UserInfo user={user} />;
    };

Below, the function component UserInfo receives the state variable as props from its parent component. The props are passed in as an object argument and then sent down as a named “props” object to the child component (of UserInfo) seen later as DisplayName.

When the props data is passed as a JSX attribute on DisplayName, it is set to a variable and passed inside curly braces as object data. The named variable is now set as an object (containing our user data) on our props object and is now reachable from inside the component.

    const UserInfo = (props) => {
        return (
            <div>
                <DisplayName user={props.user} />
            <div>
        )
    }

DisplayName receives the props object as an argument and returns a React element where we pass the selected data to display by first referencing props -> then our named props object -> then the attribute name of the data we want to display; in this case “Hubert”.

    const DisplayName = props => {
        return (
            <div>
                <h2>Hello, my name is {props.user.name}.</>
            <div>
        )
    }

The above code block will render “Hello, my name is Hubert”

So why do we pass information around in this way? A few reasons are listed below.

- **Control.** As we learned with modules, when we break our components down into smaller functions, we gain greater control over what we display and how it works. By keeping state in one of a few select components and passing as props, we minimize the risk of making unintended changes to our state data.
- **Readability.** Separate files are easy to keep in order, and make it easier for other developers to read through our code, know where our state is held, and where it’s being sent. The easier your code is to read and understand, the more likely someone is to ask you write more it for them.
- **Maintenance.** If we want to make changes, we can find components quickly, and working in files that only manage one or two different aspects of our application is a much easier task than scrolling through hundreds of lines of code! Also, this way, we can isolate any problems that come up and debug faster.
- **Reusability.** This is huge! Now we have reusable components, and they can render any data that we pass through, so long as it matches to type on our object. And with a few modifications, we render additional data if we added to our object. Or we could even pass in an array of hundreds of objects and render the information contained on each one. This would only require a few additional lines of code.

##### Challenge

Create a new component to render the user’s age and pass it to UserInfo.

Stretch goal - Replace the single user object with an array containing several user objects with name and age properties, and any other information you would like to display. Use a map function to iterate over the props data in UserInfo and return a single DisplayUser component. Pass the iterated object data to each newly created component and render the data dynamically in your JSX.

---

#### Learn to demonstrate the ability to compose React components to build out a UI

Let’s think about the Facebook web application for a minute. How many things on our facebook pages could be thought of as reusable? Do buttons look the same? How about thumbnail images? Well you can bet that facebook isn’t writing a component for every single button they use. By learning how to build out components for reusability, you will really be able to tap into the power of ReactJS for building scalable web applications.

##### Overview

Now that we know all about functional components and how to pass arguments (props) through to those components and render those props data to the screen using JSX, we’re going to learn all about nesting components that may rely on one or another prop value from a parent component.

Let’s take a look at the following code example and learn how we can achieve this idea of nesting components:

    const App = props => {
      return (
        <div>
          <h2>Hello world from, {props.name}</h2>
          <div>
            <h4>My best friend in this world is: {props.bestFriend}</h4>
            <p>My favorite book is: {props.favoriteBook}</p>
          </div>
        </div>
      );
    }

This component is doing some simple rendering of DOM elements. It only relies on 3 props, so it’s not super sophisticated, but it makes for some cumbersome programming. Meaning, here we essentially have a component nested inside of another component. So lets start by breaking out the inner DOM elements that’s purpose is to render the `best-friend` data into it’s own component.

    const BestFriend = props => {
      return (
        <div>
          <h4>My best friend in this world is: {props.bestFriend}</h4>
          <p>My favorite book is: {props.favoriteBook}</p>
        </div>
      );
    };

While this is good, we really should make it so that `BestFriend` can be reused and nested. Now, when we use this component inside of our `App` component, we can pass data to it as props.

    const App = () => {
          return (
            <div>
              <BestFriend bestFriend="Homer Hickam" favoriteBook="October Sky"/>
            </div>
          );
        };

Now our component looks a little cleaner. But we can take it one step further. Notice that our `<p/>` tag could also be (if we so wanted) it’s very own component. For demonstration purposes of why this is neat, we’ll go ahead and make it happen.

    const Book = props => <p>My favorite book is: {props.favoriteBook}</p>;

And to use it nested within the `BestFriend` component

    const BestFriend = props => {
      return (
        <div>
          <h4>My best friends in this world is: {props.bestFriend}</h4>
          <Book favoriteBook={props.favoriteBook} />
        </div>
      );
    };

Now things are getting a little ridiculous, but this demonstration shows that react can pass props down as far as you’d like. We recommend not nesting components super deep because, in the long run, this can cause issues when attempting to work with the props that you’re passing down as well.

##### Follow Along

Now let’s build a few container components that each render their children and grandchildren. Let’s build out an ancestry tree that shows off the generations of the Simpsons.

Here is our data set:

    const simpsonData = {
      name: "Orville Simpson",
      spouse: "Yuma Hickman",
      children: [
        {
          name: "Abraham Simpson",
          spouse: "Mona",
          children: [
            {
              name: "Homer Simpson",
              spouse: "Marge Bouvier",
              children: [
                {
                  name: "Bart Simpson"
                },
                {
                  name: "Lisa Simpson"
                },
                {
                  name: "Maggie Simpson"
                }
              ]
            }
          ]
        }
      ]
    };

Let’s start by building out our `Parent Component`. Luckily our Parent components will be pretty straightforward.

    const Parent = props => {
      return <h1>Parent: {props.name}</h1>;
    };

Now that we have our data and component, we can mount up this component inside of a container component.

    <Parent name={simpsonData[0].name} />

Should mount an `h1` with `Abraham Simpson's` name printed to the screen. Now let’s tweak our Parent component to be able to conditionally mount a child component if a `child` prop is on the `props object`. To achieve this we’ll need a `Ternary Operator` that checks if the `child` prop is defined. If it is, we want to mount a `Child` component; if not, we want to mount `null`.

    const Parent = props => {
      return (
        <div>
          <h1>Parent: {props.name}</h1>
          {props.child ? <Child name={props.child} /> : null}
        </div>
      );
    };

Now we have to build out our child component so that we can properly use this one.

    const Child = props => {
      return (
        <div>
          <h2>Child: {props.name}</h2>
          {props.grandChild ? <GrandChild name={props.grandChild} /> : null}
        </div>
      );
    };

Notice we have the same behavior here as we did in the Parent. We’ll mount a `<GrandChild />` component if the correct prop exists. So now we need to build out `GrandChild`.

    const GrandChild = props => {
      return (
        <div>
          <h3>{props.name}</h3>
        </div>
      );
    };

So now that everything is put together let’s see how we can mount all these components up correctly.

    <Parent
      name={simpsonData[0].name}
      child={simpsonData[0].children[0].name}
      grandChild={simpsonData[0].children[0].children[0].name}
    />

Ok, so our data set isn’t the greatest, and the way this app works is entirely stringent upon specific data formatting, but it gets the idea across.

Your goal now is to try and extend this to `GreatGreatGrandchild` to be able to render out `Bart, Lisa, and Maggie` to the screen!

A good place to start would be right [here](https://codesandbox.io/embed/pwkl9zr140).

You can use CodeSandbox to build Live ReactJS applications. I recommend logging in through their Github OAuth portal. Have fun!

##### Challenge

Create an object that represents a generational tree of your family similar to the `Simpsons Object` found in our follow along example. Keep it simple. Build out a few nested components that demonstrate the ability to pass data and conditionally render components if certain props are available.

---

#### Learn to pass props as dynamic data to a React component

So far all the data we’ve passed has been static, that is data that doesn’t change. If we want our React app to actually react to anything, we need to start thinking about passing dynamic data.

##### Overview

We’re going to build a button component that, when clicked, returns a button and renders a new app component. The button component will have an array of colors represented by string hex values that we can use to describe our dynamic data. We’ll need to pass our state variable from app down via props to our button component. Also, we need to pass along a function that takes in an array and calls our setter function. While hooks make it easy to bring this functionality directly into any component, we’ll build this app and pass it for demonstrative purposes. In case you want to build additional components, you’ll be all set to go ahead and update their color as well. Let’s begin.

Since we’ll be using hooks, the first thing we need to is import the `useState` function to our file as named import.

    import React, { useState } from "react";

Next call `useState` at the top of your app function component and set its value to a destructed array containing the state variable and its setter function, in this example, color and setColor, respectively. Set the default value to the hex value for the color ‘white’. Then render our soon to be built Button component inside App and pass it our state variable as props.

    function App() {
      const [color, setColor] = useState("#FFFFFF");

      return (
        <div className="App">
          <Button color={color} />
        </div>
      );
    }

Now let’s write the function that our button will accept. We’ll name this function `changeColor` and have it take an array as its parameter. In our function statement, we call setColor and pass our array parameter using bracket notation to select a random index of the data given in the array dynamically. You probably recognize most of the code, but all that matters is it evaluates to random whole number from 0 to the max-index of the given array. Don’t forget to pass the function to button component as props; otherwise, it won’t be there when you try to access it.

    function App() {
      const [color, setColor] = useState("#FFFFFF");

      const changeColor = array => {
        setColor(array[Math.floor(Math.random() * array.length)]);
      };

      return (
        <div className="App">
          <Button color={color} changeColor={changeColor} />
        </div>
      );
    }

Alright, now all we need is the button. We’ll go ahead and build it in the same file to keep things simple. Below our app component declares the button function component. While it’s accessible anywhere in the file, we want to also place our array of colors inside of `Button` in case we decide to put it in its own file later. Next, return a `<button>` element and give a `style` and `onClick` attribute. Here is where we’ll pass our, now dynamic, props. In the `style` tag set `background` to `props.color` to represent our state value back in App. Set the `onClick` attribute to an anonymous arrow function that returns `props.changeColor()` and pass in our colors array as an argument.

    const Button = props => {
      const colors = [
        "#FFBAAA",
        "#27576B",
        "#D47F6A",
        "#AA7539",
        "#003D19",
        "#6E91A1",
        "#552D00"
      ];

      return (
        <button
          style={{ background: props.color, height: "50px", width: "200px" }}
          onClick={() => props.changeColor(colors)}
        >
          Click Me!
        </button>
      );
    };

Now click away and watch the magic happen! The button is now dynamic because our setter function can set the color variable the button receives. Now, this might not be the most practical example, and you may not spend your career building buttons that randomly change color (although dark mode _is_ pretty great), but think about the processes that led us here. We use functions, variables, and an array of data. What else could you do with these things to make changes to components? What changes could you make to the existing so instead of random color, the user can cycle through the array in order? The point is, once you have the patterns down, you’re really just writing Javascript.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [React Components Instagram Clone](https://github.com/LambdaSchool/React-Components-Insta-Clone)

  Use what you have learned the last two days to create multiple components, update state, pass data via props, and put it all together to create a Instagram clone.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Composing React Components and Passing Data Via Props for WebPT22 w/Keiran Kozlowski](https://youtu.be/r8NChRR2HUY)**

  As you build bigger applications, you’ll want to start splitting up your app into smaller pieces so that it is easier to work on and maintain. These small pieces you will build are called components. Components will need to share state, so we will learn how to do this with a helper object called props.

- [All previous recordings](/archive/FSW/module/recgzSGQtp2HYwgSR)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Using the codesandbox you’ve been trying this out in, make a React component in one file that is exported as the default export, and see if you can import it and render it in the `App` component. This is a good chance to try it out on your own before we do it together later.

- Objective challenge:

  Create a new component to render the user’s age and pass it to UserInfo.

  Stretch goal - Replace the single user object with an array containing several user objects with name and age properties, and any other information you would like to display. Use a map function to iterate over the props data in UserInfo and return a single DisplayUser component. Pass the iterated object data to each newly created component and render the data dynamically in your JSX.

- Objective challenge:

  Create an object that represents a generational tree of your family similar to the `Simpsons Object` found in our follow along example. Keep it simple. Build out a few nested components that demonstrate the ability to pass data and conditionally render components if certain props are available.

- Project: React Components Instagram Clone
