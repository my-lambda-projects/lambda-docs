<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications I

<a href="/web2/sprint/recPSZMPrmESUYo2C" class="bd-toc-link">1.  Applied JavaScript</a>

- [DOM I](/web2/module/rectn5PUU5ubcQkPu/)
- [DOM II](/web2/module/recJWv3RIfa4NFXbn/)
- [Components I](/web2/module/rec847sNXZX9CVDNl/)
- [Components II](/web2/module/recd6kDKS6eMapSRq/)

<a href="/web2/sprint/recYL2HDPPpkDmGEm" class="bd-toc-link">2.  Intro to React</a>

- [React Components and Component State](/web2/module/recZau7hH8vzww14N/)
- [Composing React Components and Passing Data Via Props](/web2/module/recgzSGQtp2HYwgSR/)
- [Component Side Effects](/web2/module/recKe8PW6ZMwjL1Qg/)
- [Advanced Styling Techniques](/web2/module/recNDoSqyUw3eq1y3/)

<a href="/web2/sprint/recH2pYM3qVavZTRN" class="bd-toc-link">3.  Single Page Applications</a>

- [React Router](/web2/module/recd7jGy7tfVkcFlX/)
- [Form Management](/web2/module/rect081xiYT2cfxGF/)
- [Advanced Form Management](/web2/module/recKK5C7wV0WiECfr/)
- [cypress.io](/web2/module/recduYpjgZBQaQM8X/)

<a href="/web2/sprint/recwKyMueNtoTTmUD" class="bd-toc-link">4.  WEB Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Projects](#projects)
- [Review](#review)

# React Router

<span class="lead"> </span>

Due to the insane popularity of JavaScript frameworks and what we call Single Page Applications (SPAs) we rely on our modern web browsers today for a lot more than we used to in the past. One of the common trends with SPAs to see today is the idea of Client Side Routing or the browser taking care of “URL” history

This module will guide you into the intricacies of React Router V5. As you learn and discover the inner workings of this package, your SPA’s will start to come to life, you’ll have more control over how your users view the content they’re supposed to be viewing, and you’ll be granted a rich developer experience. A lot of the items discussed here lend themselves to being commonly used

**At the end of this module, you should be able to:**

- explain the difference between client-side routing and sever-side routing
- set up routes within a React Application using the Router, Route and Link components
- use Router's useParam hook to add dynamic Routes to an application
- use Router's useRouteMatch hook to add nested Routes to an application
- use Router's useHistory hook to programmatically navigate to other routes

#### Pro Tip

The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time.

Tom Cargill, Bell Labs

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=OrBKbQbobC0), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=WSZkkZrquiA), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=ZLpRLXsPNHs), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=nbwHVhkXuVk), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=BNOjGb_DE38), or enable JavaScript if it is disabled in your browser.

- [Client vs Server side Routing](https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain the difference between client-side routing and sever-side routing

Client-side routing is a JavaScript managed routing option. It offers control over your site URL & content without necessarily having to wait for a server to respond with content. It is designed to mimic the appearance of traditional multi page websites.

What is server-side routing? It’s the way the web has worked for decades. Every link click & change of the address bar is a new request to a remote server. Every page load includes all page design elements, which must be re-downloaded. Including headers, navigation, sidebars, footers, etc. The server side routing method is not very efficient.

##### Overview

### What is Routing?

Being able to access information based on a URL is not only a powerful tool at our disposal as end-users and developers, but it is also a standard. Routing is essential for handling a communication piece between computers. Routing is the way we navigate through websites and web applications today. When we click on a link on any web app or website, we are routing to a URL and requesting some information that lives somewhere else. You do this every day - just type `www.google.com` in a web browser, and you’ve utilized routing to get resources from a server.

### What is a Server?

Before we talk about the _how_ of routing, we need a solid definition of the _what_. In computer science, the term “server” refers to centralized resources on a network. These servers are physical devices, usually housed with other servers in large warehouses, that run the “behind the scenes” work of the internet like data storage. When you route, you’re routing to a server.

You may be familiar with this type of server room from movies or TV. Each one of those boxes is a server, housing thousands of filing cabinets worth of data every couple of inches.

![server room](https://s3.envato.com/files/e967264f-38e7-4819-a943-83ddf54a4cea/inline_image_preview.jpg)

Websites and Web-applications all rely heavily on information that is controlled by a server. We can’t get away from them, even when we hear buzz-words like “serverless” servers (hint: they’re not really server-less) we still rely on machines that communicate across channels to deliver content to us as end-users. Imagine if every time you clicked on something on a website, you had to request a resource from a server, and then the server had to go and retrieve that resource, and then that server had to send back some HTML/CSS and eventually some JavaScript in order to display the data on the screen. For a long time, this was how the web worked.This hasn’t entirely gone away, but we now have a slightly better way of doing things.

This image does a really good job of showing some of the key differences between Client-side (traditional) and Server-side(SPA) routing.

![Client vs server](https://imagebin.ca/40yMWdOcgBfd/IC690875.png)

### Server-Side Routing

When we request information from a server (by clicking on a link or button), that server then sends back the document that was requested. For example, we click on a link and our URL changes to match the request, then the server goes and finds a `template` or some `HTML` file and sends it back across the world wide web to deliver that content to the user.

All of this is handled and achieved on the server, and there are a few things that happen here. First, the server will refresh the web page that we’re looking at. This is because a new request was made for information, and the information given was a bunch of DOM elements, so we have to re-paint the web page. The information requested will be the only information given, no more, and no less. Because of this, we get the opportunity to load smaller portions of the webpage as opposed to requesting/loading the entire thing the whole time the way that we do in Client-Side Routing.

When you (the client) request a lot of information, your computer and subsequent internet-related devices run through a lot of protocols. The process can be really slow, especially when bandwidth is an issue.

### Client-Side Routing

Now that we know about how things used to be done, we can talk about modern routing. Javascript and the other tools that we get to work with within Javascript are super sophisticated. Because of the arrival of tools like [Google Chrome’s V8 Engine](https://en.wikipedia.org/wiki/Chrome_V8), we can do a lot of things that weren’t previously possible. One of those new patterns is using JavaScript to maintain state (or memory) within our applications and use that memory to tell the Browser what to display when a resource is requested.

When Routing is handled internally by the JavaScript that is already on the page, we achieve what is known as `Client-side routing`. And this tool is how we get things done today, especially in React! And the best part about this is that the page won’t refresh! The data is just there, displayed when we ask for it. How this works is that when a user clicks on a requested resource, instead of the client asking for that resource from the server via a URL, JavaScript will prevent this. We then get the resource (state) that is already available to us rendered out, and when using react, this happens beautifully through component-based architecture.

##### Follow Along

Read through this medium article [here](https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f). Look at the image above as you read for a visual representation of how both server-side routing and client-side routing work.

##### Challenge

On your own, write down some of the pros and cons for both server-side routing and client-side routing, and then write a paragraph of what you like about both, and which you would prefer to use and why. Submit this to your TL via slack.

---

#### Learn to set up routes within a React Application using the Router, Route and Link components

##### Overview

#### React Router

React Router is declarative style routing for React applications. React Router is a versatile tool because it can be used for React and React Native as well. The best part of React Router is that it pushes the envelope for what a router should be on the client. Since it was built for use within a React ecosystem, it uses a Reactive & Declarative context. This means we get a much more dynamic routing experience when building and designing our Routes within our React Apps.

#### Route

Routes are a way of getting to a destination. A route can specify which components to render on the page, and in what order, as we’ve seen before.

To set up React Router, you need to declare what components will be mounted when certain URL paths are met. This step happens _after_ we’ve wrapped our `Root` component in the `Router` or `BrowserRouter` component. The best part of React Router is that you can do this at pretty much any point during your development process, whereas previously you had to declare your routes early on in the development cycle. What this allows us to do is figure out more important things without allowing routing to get in the way. React Router is a super useful tool for this reason!

Once you have React Router installed by using `npm install react-router-dom`, you can import the `Route` Component and use it within your application.

    import { Route } from 'react-router-dom';

The `Route` component declares what `components` will be _mounted_ based on what `URL's` the user requests. The best part about this process is that we get a chance to do this in a very “React” way. Lets picture a component `Users` that will display a list of users in your system when the URL `www.coolestapp.com/users` is requested. The `Route` component takes in a few props; the first is the URL `path` where the Route component will trigger. Next is the `component` prop. This is the component that you want React to _mount_ when the URL matches the requested `path`. So in our case, when `/users` is requested, the `Users` component will be mounted.

    <Route path="/users" component={Users} />

This route will take us to the `users` component whenever the `/users` URL is requested within our application. You may be thinking to yourself at this point, is that really it? The answer is: yes, it is! It’s really simple to declare routes and components that will be mounted when the routes are requested. It’s almost like your `Route` components ask you this question every single time you set one up: what **component** do you want **mounted** when a user asks for what **URL path**?

If you use this tool, you’ll hit each piece of your application, and how a user might interact with each component.

Now let’s see this all in action in a larger portion of an application. Picture an app that has 3 major components that will need to be rendered as part of a `Navigation` system: `Home`, `Contact`, and `About`. Each of these three components will need to be rendered when a user requests the `"/"`, `"/contact"` and `"/about"` paths in our app. So, let us refer to our question above: what component do you want mounted when a user asks for what URL path? In our case, we want the following:

A user requests `/` so we will mount the `Home` component A user requests `/contact` so we shall mount the `Contact` component A user requests `/about` so let us render the `About` component

Now that we have a framework let’s practice with it.

    <Route path="/" component={Home}/>
    <Route path="/contact" component={Contact}/>
    <Route path="/about" component={About}/>

##### The `exact` prop

And there we have it, we have successfully declared our Routes within our application. But we have a bit of a problem. A problem that is easily solved. If you’re looking at the React Router documentation, you may have already come across the `exact` prop, which is provided to us by the React Router API. This prop is a very important feature of the `Route` Component. It comes to us because of the way that the package was built. Let’s consider how this whole thing works.

When it comes down to it, we are using an API that already exists for us as web developers. And that is the [History](https://developer.mozilla.org/en-US/docs/Web/API/History) API that is built into our web browser. If the URL `/` and `/about` are both requested, and we have an algorithm to match the characters in the sequence `/`, `/about`. Both the `/` and `/12` will match. Because of the way this is set up, if we request the route `/about`, then both the `Home` Component and the `About` Component will be rendered. React Router anticipates this, and the `exact` prop to the `Route` component solves the problem.

By placing `exact` on a `<Route />` component, you are saying that the specific path will only trigger if it matches exactly the path requested. This defaults to false, so by simply including the `exact` prop on your `Route` component, it will set it to true and only mount our `Home` component when the specific path `/` is requested and not when `/about` is requested. [Here](https://reacttraining.com/react-router/web/api/Route/exact-bool) is a link to the docs. And here is an example of how this will work.

    <Route exact path="/" component={Home}/>
    <Route path="/contact" component={Contact}/>
    <Route path="/about" component={About}/>

This is the same as before only now our `Home` component route has the `exact` prop added to it. We have now solved the problem.

### Link

The link component can be included just like any other component in your application. This will produce an anchor tag that will link to a pre-defined component of your choice. Remember, if we set up our routes properly, we’ll be able to use the anchor component to navigate our browsers to the path where a component can be mounted. We can think of our `Route` component as the boat on the ocean, and the `Link` as the wind and sails that make that boat move.

    import { Link } from 'react-router-dom'

    <Link to="/about">About</Link>

As is the case with all of the components that we get from React Router, `Link` will take a few props that we can use to control the component and allow it to work for us.

The first thing that `Link` takes as a prop (and most important) is the `to` props. Notice in the above code block that `to` is a string that looks like a URL. This is just like the `href="/about"` attribute on the `anchor` tag. This is how we navigate with React Router.

#### Switch

We won’t use it here, but in many online tutorials you will see the use of `switch`. If a route matches multiple routes enclosed in a switch statement, the browser will only render the first component it comes across. This can come in handy when considering nested routes and the like.

##### Follow Along

For the next four objectives we are going to work on an `avengers` app together.

### Setting up React Router

Before we start we will need to install React Router and set up our directory. To install React Router, all we have to do is use `npm` to download the package. In the past, we used to include the entire `react-router` package, but today we get to specify which target we’re building for (Web or Native). Because we’re building for web, we’re going to target the `react-router-dom` package and include it into one of our applications.

    npm install react-router-dom

Once you have it installed, all you need to do is include it as a package like any other `npm` package we’ve used to date. In addition, we’ll want to import `React`, `ReactDOM`, and our `App` component.

    import React from "react";
    import ReactDOM from "react-dom";
    import { BrowserRouter as Router } from "react-router-dom";
    import App from "./App";

Now we’ll use Router as our `Base` component that will wrap our entire app. We’ll do this by wrapping our `<App />` component that we pass to `ReactDOM.render`. This way, what renders from App is controlled with `<Router>` as opposed to rendering everything in `App`.

    ReactDOM.render(
      <Router>
        <App />
      </Router>,
      document.getElementById("root")
    );

### Route

Now we can set up routes for our Avenger’s app. We want to have a home page, and a list page. Later we’ll add an Avenger page. So our app routes are going to be organized something like this:

    A user requests `/` so we will mount the `Home` component
    A user requests `/avengers` so we will mount the `AvengerList` component

Next, we need to create a `components` directory. Inside that folder, we need a `Home.js` file and an `AvengersList.js` file. For now, just render a header element with “Home” and “Avenger List” in the respective components.

Add [this](https://gist.github.com/dustinmyers/35ad6751b5bd683b441faaf167dfa7d3) to your .css file to use my styles, or style it up how you’d like on your own.

Add [this data](https://gist.github.com/dustinmyers/b2a904870c84a0339002458f972b3398) to your app and display the list of Avengers in the list component.

Import those new components into `App.js`. Let’s create the routes for our app. We will need to import the `Route` component. Our app imports should look something like this:

    import React from "react";
    import { Route } from "react-router-dom";
    import AvengersList from "./Components/AvengersList";
    import Home from "./Components/Home";
    import "./styles.css";

Now we want to render two routes - home and avengers. For the home route we need to include the `exact` parameter to specify that any additional text after the `"/"` shouldn’t route to home. Go ahead and test with and without `exact` to see the difference here.

    <Route exact path="/" component={Home}/>
    <Route path="/avengers" component={AvengerList}/>

Before moving on, go to both URLs and make sure the components are rendering correctly.

Feel free to build out your `Home` component however you would like.

### Adding Links

The next thing we want to do is incorporate links. We’ll do that by adding a nav bar.

We’ll use `Link` to make a way to route to the `Home` component and the `AvengerList` component.

First we need to add `Link` to our imports.

    import { Route, Link } from "react-router-dom";

Then we’ll add the navigation bar to our `App`.

    <ul className="navbar">
      <li><Link to="/">Home</Link></li>
      <li><Link to="/avengers">Avengers</Link></li>
    </ul>

Try out the links to make sure they work, and then style the nav bar. Once that is done, go to your `AvengerList` component and add a `Link` somewhere in the mapped list of avengers that will route you to the `AvengerPage`. To show an example, I’ll do it here on the header element. You’ll notice that I am using an interpolated string so that we can build out the URL dynamically using the avenger’s id.

    <Link to={`/avengers/${avenger.id}`}>
      <h3>{avenger.name}</h3>
    </Link>

Take a minute to inspect your navbar and your wrapped header elements in the dev tools. Look for the anchor tags that get rendered by the `Link` component.

Our final `App.js` before hooks should look something like this:

    import React, { useState } from "react";
    import { BrowserRouter as Router, Route, Link, Switch } from "react-router-dom";
    import AvengersList from "./Components/AvengersList";
    import Home from "./Components/Home";
    import "./styles.css";

    const App = () => {
      return (
        <Router>
          <nav className="navbar">
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/avengers">Avengers</Link>
            </li>
          </nav>
          <div className="App">
            <Switch>
              <Route exact path="/" component={Home} />
              <Route path="/avengers" component={AvengersList} />
            </Switch>
          </div>
        </Router>
      );
    };

    export default App;

##### Challenge

1.  Start up a new React app called friends, install react-router-dom and get it wired up to use React Router. Inspect your app in the browser with the React tools and make sure you see your app wrapped in the Router component (reference the image above).
2.  In your friends app, add a new `Home` component and `Friends` component. Then add a route for each component. Test your app in the browser to make sure both apps are rendering at the correct route. Build out your `Home` component and then render out a list of friends data in the `Friends` component.
3.  Make a navbar on the friends app. In the list component, add a Link component to the mapped list of friends to give us a way to route to the individual friend page.

---

#### Learn to use Router's useParam hook to add dynamic Routes to an application

##### Overview

React’s newest update, 5.1, released late in 2019 supports hooks. This is really helpful for routing, so we’ll spend the next few objectives exploring use cases of some common hooks.

### `useParam`

The `useParam` hook relies on props to pass new and changing data into the app. Parameters are placeholders in a URL that represent some changing data. When we’ve set up routes in the past we’ve written some route like \` &lt;Route path=”/employee\` that corresponds to some component, but what if we want to load different data depending on the URL?

The `useParam` hook allows us to create dynamic routes that will render content based on the URL. So, instead of requiring that all routes are written out ahead of time, the URL determines what renders on the page. For example, a url `"website.com/johnSmith"` would render data about John Smith, while `"website.com/janeDoe"` would render data about Jane Doe - neither have to be specified in your code. The browser “matches” the URL to the data, thus the name. If no data is found, it throws an errorIn some ways this provides access to search parameters in the URL. Before React Router 5.1 this was only possible using `match.params`.

In order to use a parameter in routing we need to assign the route with a colon in `App.js` or wherever else the routes are defined. So, \` &lt;Route path=”/employee`becomes` &lt;Route path=”/:employee`. With that simple change we can use the `useParam\` hook to create dynamic routes.

A real life example of this is Twitter. It would be crazy to imagine that every time a user makes a new profile, a new line of code has to be written. Instead, Twitter routes look something like this:

    <Route path='/:handle' component={Profile} />

The path is specified with a `:` and the component will load accordingly.

##### Follow Along

Let’s return to our avengers app and created dynamic routes with `useParam` such that `ourapp.com/avengers/Thor` will render information about an avenger from our `data.js` file, in this case, Thor.

### App.js

We don’t need to import `UseParams` in `App.js`, but we do need to make some changes here. Importantly, we need to pass data to `avengersList` and set up our routes such that they will accept any `hero` parameter.

    <div className="App">
            <Switch>
              {/* we can use Route to render child components instead of having to use the component prop. This way we can easily pass down props to our components.  */}
              <Route path="/avengers/:hero">
                {/* Passing our data to avenger's list */}
                <Avenger key={hero.id} hero={hero} />
              </Route>
              <Route path="/avengers/">
                <AvengersList hero={hero} />
                {/* Passing our data to avenger's list */}
              </Route>

              {/* You can also render a component with the component prop if you do not need to pass any additional props to your component */}
              <Route path="/" component={Home} />
            </Switch>
          </div>

### AvengerList.js

In our `Avenger.js` file, we’ll need to import `useParams` and set up the parameter for Avenger.

    import React from "react";
    import { useParams } from "react-router-dom";

After that, we can edit our `Avenger` function to match the `hero` data to the route specified in the URL. JavaScript will look at the hero `id` and match it to the `id` in `data.js`.

    function Avenger({ hero }) {
      // console.log("Props", props);
      const params = useParams();
      // we can use this hook to grab information about the way React Router matched this route

      // we want to match the hero to the route
      const heros = hero.find(item => item.id === Number(params.hero));
      return (
        <div className="character-card">
          <h2>{heros.name}</h2>
          <p>{heros.nickname}</p>
          <p>{heros.description}</p>
          <img src={heros.thumbnail} alt="random avengers img" />
        </div>
      );
    }
    export default Avenger;

Once this is in place you should be able to visit a site such that `ourapp.com/avengers/3` will render information about Captain America. Similarly, `ourapp.com/avengers/4` should match and render information about Spiderman, and so on. Play around with this feature using different URL routes before moving on.

##### Challenge

Create a dynamic route in your `Friends` application with `useParams`

---

#### Learn to use Router's useRouteMatch hook to add nested Routes to an application

##### Overview

The next hook we’ll look at is `useRouteMatch`. This hook lets you add nested routes to your application such that you can change a single parameter in the URL without having to change the whole thing. This way you could easily have a `website.com/about/employee1/employee-details` URL and `website.com/about/employee2/employee-details` URL, with only one specified route in your code.

In the example above, if we wanted to change our route such that “about” was “our story” or any different string, it wouldn’t break our webpage.

In previous versions of React Router, developers used a workaround to manually sort and match routes. For illustration purposes though, this example of such highly redundant code is still pretty relevant.

    import { useRouteMatch } from 'react-router-dom'

    function App() {
      const {path, url} = useRouteMatch();

      return (
        <li>
          <Link to = {`/about/employee1/employee-details`></Link>
          <Link to = {`/about/employee2/employee-details`></Link>
          <Link to = {`/about/employee3/employee-details`></Link>
          <Link to = {`/about/employee4/employee-details`></Link>
        </li>

        <Switch>
            <Route path = {`/about/employee1/employee-details`></Link>
            <Route path = {`/about/employee2/employee-details`></Link>
            <Route path = {`/about/employee3/employee-details`></Link>
            <Route path = {`/about/employee4/employee-details`></Link>
            <employee-details/>
            </Route>
            </Switch>
      )
    }

With react router 5.1, we can simply reference `${url}` in place of redundant links. The resulting code is cleaner and less prone to error.Study the following example before moving on.

    import { useRouteMatch } from 'react-router-dom'

    function App() {
      const {path, url} = useRouteMatch();

      return (
        <li>
          <Link to = {`${url}/employee-details`></Link>
        </li>

        <Switch>
            <Route path = {`${path}/employee-details`}>
            <employee-details/>
            </Route>
            </Switch>

      )
    }

##### Follow Along

Let’s add the `useRouteMatch` hook to our Avenger’s app to dynamically route to multiple avengers.

As usual, we need to import the hook in our `App.js` file like so:

    import { useRouteMatch } from "react-router";

Then, we can declare a variable called `match` and give it the value of the route path to follow. That might look something like this:

      const { path, url } = useRouteMatch();

The only thing we need to add to our lists is the `{url}` to our `<NavLink>` elements such that `anyurl.com/anything/hero/movies` will be a valid URL. By adding this we are telling React to first render information about the hero, then, when the `movies` parameter is added (manually or via button click), to load the list of movies that the hero is in. We don’t need to write a new route for each hero, we can simply use `{url}` to specify that the same route can be used for any hero.

      // path: "/avengers/:hero"
      // url: "/avengers/1"
      const heros = hero.find(item => item.id === Number(params.hero));
      return (
        <div className="characters-list-wrapper">
          <div className="character-card">
            <h2>{heros.name}</h2>
            <p>{heros.nickname}</p>
            <p>{heros.description}</p>
            <img src={heros.img} alt="random avengers img" />
            <nav className="nav-buttons">
            // replace
              <NavLink to={`${url}/movies`}>Movie List</NavLink>
            </nav>
            <Route path={`${path}/movies`}>
              <Movies movielist={heros} />
            </Route>
          </div>
        </div>
      );
    }
    export default Avenger;

Before moving on, check your work by looking over the complete [Avenger’s Example](https://codesandbox.io/s/react-router-avengers-example-5lu6t) on CodeSandbox.

##### Challenge

Create a nested route in your `Friends` application with `useParams`

---

#### Learn to use Router's useHistory hook to programmatically navigate to other routes

##### Overview

The final hook we’ll look at today allows us to create dynamic elements (buttons, text, etc.) whose function changes based on a user’s history.

For example, in a storefront webpage, we could create a button called “return to last item” that would return to the last item the user viewed (wither that be a T-shirt, or a pair of shoes), rather than a default list of items or home page.

The hook we will use to accomplish this is called `useHistory`.

For example, code that looks like this would render the last component the user visited when the button is clicked.

    import { useHistory } from 'react-router-dom'

    function BackButton({ children }) {
      let history = useHistory()
      return (
        <button type="button" onClick={() => history.goBack()}>
          {children}
        </button>
      )
    }

This is useful for navigation, among other things.

##### Follow Along

In the `AvengerList` component, you have rendered a list of Avengers, and you’re using the `Link` component to route to the `AvengerPage` route. Let’s change that to use the `history` object instead. Wherever you would like - on the wrapping div, or a button - add an `onClick` event handler that invokes a function to `goBack`.

As usual our first steps will be to 1) import `useHistory` and 2) declare it as a variable.

    // import useHistory
    import { useHistory } from "react-router"

    //globally declare hook
    const history = useHistory();

Once we’re set up with that we can add a button to our Avenger’s List component such that when clicked, the button will return to the last page.

    //add button to return statement
    return (
        <div>
          <h1>
            Avenger: </h1>
           <h1> {name} {nickname}</h1>
          <button type="button" onClick={() => history.goBack()}>
            Go Back
          </button>
        </div>
      );
    }

Once this code is properly implemented you should be able to navigate between your `Home` and `Avengers` pages and use Go Back to route to your last visited page.

##### Challenge

Add an `onClick` event handler to your `friends` app that works with a method of `useHistory` wherever it makes sense to do so.

---

## <a href="#projects" id="projects" class="anchor"><span class="octicon octicon-link"></span></a>Projects

- ##### [React-Router-Movies](https://github.com/LambdaSchool/React-Router-Movies)

  Create an app that renders a list of movies in one route, and a movie info page in another route.

- ##### [React-Router-Apple-Nav STRETCH ASSIGNMENT](https://github.com/LambdaSchool/React-Router-Apple-Nav)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[React Router for WebPT22 w/Chris Atoki](https://youtu.be/LRGJi0o4W7Y)**

  Due to the insane popularity of JavaScript frameworks and what we call Single Page Applications (SPAs) we rely on our modern web browsers today for a lot more than we used to in the past. One of the common trends with SPAs to see today is the idea of Client Side Routing or the browser taking care of “URL” history This module will guide you into the intricacies of React Router V5. As you learn and discover the inner workings of this package, your SPA’s will start to come to life, you’ll have more control over how your users view the content they’re supposed to be viewing, and you’ll be granted a rich developer experience. A lot of the items discussed here lend themselves to being commonly used

- [All previous recordings](/archive/WEB2/module/recd7jGy7tfVkcFlX)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  On your own, write down some of the pros and cons for both server-side routing and client-side routing, and then write a paragraph of what you like about both, and which you would prefer to use and why. Submit this to your TL via slack.

- Objective challenge:

  1.  Start up a new React app called friends, install react-router-dom and get it wired up to use React Router. Inspect your app in the browser with the React tools and make sure you see your app wrapped in the Router component (reference the image above).
  2.  In your friends app, add a new `Home` component and `Friends` component. Then add a route for each component. Test your app in the browser to make sure both apps are rendering at the correct route. Build out your `Home` component and then render out a list of friends data in the `Friends` component.
  3.  Make a navbar on the friends app. In the list component, add a Link component to the mapped list of friends to give us a way to route to the individual friend page.

- Objective challenge:

  Create a dynamic route in your `Friends` application with `useParams`

- Objective challenge:

  Create a nested route in your `Friends` application with `useParams`

- Objective challenge:

  Add an `onClick` event handler to your `friends` app that works with a method of `useHistory` wherever it makes sense to do so.

- Project: React-Router-Movies
