

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Server-Side Routing with Express

<span class="lead"> </span>

Node’s HTTP server uses a single `request handler function` for all requests. Express provides a way to break the application into different request handlers for each URL+ HTTP method combination.

This feature is called **Routing** and is one of the main features of `Express`.

In this module we will take a deeper look at routing. We will:

-   use the `routing` feature of express to build several endpoints.
-   cover different ways to pass data to a Web API.
-   introduce `REST` as a way to guide the architecture of our web
-   using Express Routers to organize our code.

**At the end of this module, you should be able to:**

-   explain how routing works in an express application
-   read data from the query string, request body and route parameters.
-   explain the basics of the REST architectural style
-   use Express Routers to organize Web API code

#### Pro Tip

Life is a marathon, not a sprint.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=tLIzjmFxsag), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=kKDB1TpL9dM), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=dgkQxWnUjKE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=qFCLzVbODJM), or enable JavaScript if it is disabled in your browser.

-   [Basic Routing on Expressjs.com](https://expressjs.com/en/starter/basic-routing.html)

    Getting Started with Routing from the Official Express site

-   [HTTP Primer for Frontend Developers](https://www.webdevdrops.com/en/http-primer-for-frontend-developers-f091a2070637/)

    Simple introduction to HTTP

-   [Express Routing Guide](https://expressjs.com/en/guide/routing.html)

    Routing Guide on Expressjs.com

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain how routing works in an express application

Routing is one of the main features of Express. Using `routing` we can map incoming requests to the appropriate request handler based on the URL and HTTP Method used.

Routing makes building RESTful Web APIs a breeze. We can have a **single URL per resource** and execute different code based on the HTTP Method/Verb used.

Building Web APIs to perform CRUD (**C**reate, **R**ead, **U**pdate, **D**estroy) operations on resources is also very straight forward because there are HTTP Methods that map directly to each operation.

##### Overview

Let’s look at a basic example of routing in action.

First, to make our Express application respond to `GET` requests on different URLs, add the following endpoints:

    // this request handler executes when making a GET request to /about
    server.get('/about', (req, res) => {
      res.status(200).send('<h1>About Us</h1>');
    });

    // this request handler executes when making a GET request to /contact
    server.get('/contact', (req, res) => {
      res.status(200).send('<h1>Contact Form</h1>');
    });

Two things to note:

-   we are using the same HTTP Method on both endpoints, but express looks at the URL and executes the corresponding request handler.
-   we can return a string with valid HTTP!

Open a browser and navigate to the `/about` and `/contact` routes. The appropriate route handler will execute.

##### Follow Along

Now, please follow along as we write endpoints that execute different request handlers on the same URL by changing the HTTP method used.

Let’s start by adding the following code after the `GET` endpoint to `/hobbits`:

    // this request handler executes when making a POST request to /hobbits
    server.post('/hobbits', (req, res) => {
      res.status(201).json({ url: '/hobbits', operation: 'POST' });
    });

Note that we return HTTP status code 201 (created) for successful `POST` operations.

Next, we need to add an endpoint for `PUT` requests to the same URL.

    // this request handler executes when making a PUT request to /hobbits
    server.put('/hobbits', (req, res) => {
      res.status(200).json({ url: '/hobbits', operation: 'PUT' });
    });

For successful `PUT` operations, we use HTTP Status Code 200 (OK).

Finally, let’s write an endpoint to handle `DELETE` requests.

    // this request handler executes when making a DELETE request to /hobbits
    server.delete('/hobbits', (req, res) => {
      res.status(204);
    });

We are returning HTTP Status Code 204 (No Content), but if you are returning any data to the client, perhaps the removed resource, on successful deletes, you’d change that to be 200 instead.

You may have noticed that we are not reading any data from the request, as that is something we’ll learn later in the module. Something else we are about to learn is how to use a tool called `Postman` to test our `POST`, `PUT`, and `DELETE` endpoints.

##### Challenge

Your assignment is to add endpoints to handle `POST`, `PUT` and `DELETE` for the `/users` route. Returning a JSON response similar to what we did in the code-along is sufficient.

##### Dig Deeper

-   [Express Response Object API](https://expressjs.com/en/4x/api.html#res)  
    Express Response Object API Documentation
-   [Express Request Object API](https://expressjs.com/en/4x/api.html#req)  
    Express Request Object API Documentation
-   [Express Routing Guide](https://expressjs.com/en/guide/routing.html)  
    Routing Guide on Expressjs.com

------------------------------------------------------------------------

#### Learn to read data from the query string, request body and route parameters.

Most Web APIs require data from clients. This data can come in different ways:

-   as route parameters.
-   as key/value pairs inside the query string.
-   as the request body.

In this module, we’ll cover how to read data sent by clients using all of these methods.

##### Overview

### Reading and Using Route Parameters

Let’s revisit our `DELETE` endpoint.

    server.delete('/hobbits', (req, res) => {
      res.status(204);
    });

How does the client let the API know which hobbit should be deleted or updated? One way, the one we’ll use, is through `route parameters`. Let’s add support to route parameters to our `DELETE` endpoint.

We define route parameters by adding it to the URL with a colon (`:`) in front of it. Express adds it to the `.params` property part of the request object. Let’s see it in action:

    server.delete('/hobbits/:id', (req, res) => {
      const id = req.params.id;
      // or we could destructure it like so: const { id } = req.params;
      res.status(200).json({
        url: `/hobbits/${id}`,
        operation: `DELETE for hobbit with id ${id}`,
      });
    });

This route handler will execute every `DELETE` for a URL that begins with `/hobbits/` followed by any value, so `DELETE` requests to `/hobbits/123` and `/hobbits/frodo` will both trigger this request handler. The value passed after `/hobbits/` will end up as the `id` property on `req.params`.

The value for a route parameter will always be `string`, even if the value passed is numeric. When hitting `/hobbits/123` in our example, the type of `req.params.id` will be `string`.

Express routing has support for multiple route parameters. For example, defining a route URL that reads `/hobbits/:id/friends/:friendId`, will add properties for `id` and `friendId` to `req.params`.

### Using the Query String

The query string is another strategy using the URL to pass information from clients to the server. It is structured as a set of key/value pairs, where each pair takes the form of `key=value` and pairs are separated by an `&`. To mark the beginning of the query string, we add `?` and the end of the URL, followed by the set of key/value pairs.

An example of a query string would be: `https://www.google.com/search?q=lambda&tbo=1`. The query string portion is `?q=lambda&tbo=1` and the key/value pairs are `q=lambda` and `tbo=1`.

Let’s add sorting capabilities to our API. We’ll provide a way for clients to hit our `/hobbits` and pass the field they want to use to sort the responses and our API will sort the data by that field in ascending order.

Here’s the new code for the `GET /hobbits` endpoint:

    server.get('/hobbits', (req, res) => {
      // query string parameters get added to req.query
      const sortField = req.query.sortby || 'id';
      const hobbits = [
        {
          id: 1,
          name: 'Samwise Gamgee',
        },
        {
          id: 2,
          name: 'Frodo Baggins',
        },
      ];

      // apply the sorting
      const response = hobbits.sort(
        (a, b) => (a[sortField] < b[sortField] ? -1 : 1)
      );

      res.status(200).json(response);
    });

Visit `localhost:8000/hobbits?sortby=name` and the list should be sorted by `name`. Visit `localhost:8000/hobbits?sortby=id` and the list should now be sorted by `id`. If no `sortby` parameter is provided, it should default to sorting by `id`.

To read values from the query string, we use the `req.query` object added by Express. There will be a key and a value in the `req.query` object for each key/value pair found in the query string.

The value of the parameter will be of type `array` if more than one value is passed for the same key and `string` when only one value is passed. This means that in the query string `?id=123`, `req.query.id` will be a string, but for `?id=123&id=234` it will be an array.

Another gotcha is that the names of query string parameters are case sensitive, `sortby` and `sortBy` are two different parameters.

The rest of the code sorts the array before sending it back to the client.

### Reading Data from the Request Body

We begin by taking another look at the `POST /hobbits` endpoint. We need to read the hobbit’s information to be able to add it to the hobbits array. Let’s do that next:

    // add this code right after const server = express();
    server.use(express.json());

    let hobbits = [
      {
        id: 1,
        name: 'Bilbo Baggins',
        age: 111,
      },
      {
        id: 2,
        name: 'Frodo Baggins',
        age: 33,
      },
    ];
    let nextId = 3;

    // and modify the post endpoint like so:
    server.post('/hobbits', (req, res) => {
      const hobbit = req.body;
      hobbit.id = nextId++;

      hobbits.push(hobbit);

      res.status(201).json(hobbits);
    });

To make this work with the hobbits array, we first move it out of the get endpoint into the outer scope. Now we have access to it from all route handlers.

Then we define a variable for manual id generation. When using a database, this is not necessary as the database management system generates ids automatically.

To read data from the request body, we need to do two things:

-   Add the line: `server.use(express.json());` after the express application has been created.
-   Read the data from the body property that Express adds to the request object. Express takes all the information that the client added to the body and makes it available as a nice JavaScript object.

**Note that we are skipping data validation to keep this demo simple, but in a production application you would validate before attempting to save to the database.**

Let’s test it using Postman:

-   Change the method to POST.
-   Select the `Body` tab underneath the address bar.
-   Click on the `raw` radio button.
-   From the dropdown menu to the right of the `binary` radio button, select \`JSON (appplication/json).
-   Add the following JSON object as the body:

    {
      "name": "Samwise Gamgee",
      "age": 30
    }

Click on `Send`, and the API should return the list of hobbits, including Sam!

##### Follow Along

Please code along as we implement the `PUT` endpoint and a way for the client to specify the sort direction.

### Implement Update Functionality

Let’s continue practicing reading route parameters and information from the request body. Let’s take a look at our existing PUT endpoint:

    server.put('/hobbits', (req, res) => {
      res.status(200).json({ url: '/hobbits', operation: 'PUT' });
    });

We start by adding support for a route parameter the clients can use to specify the id of the hobbit they intend to update:

    server.put('/hobbits/:id', (req, res) => {
      res.status(200).json({ url: '/hobbits', operation: 'PUT' });
    });

Next, we read the hobbit information from the request body using `req.body` and use it to update the existing hobbit.

    server.put('/hobbits/:id', (req, res) => {
      const hobbit = hobbits.find(h => h.id == req.params.id);

      if (!hobbit) {
        res.status(404).json({ message: 'Hobbit does not exist' });
      } else {
        // modify the existing hobbit
        Object.assign(hobbit, req.body);

        res.status(200).json(hobbit);
      }
    });

Concentrate on the code related to reading the `id` from the `req.params` object and reading the hobbit information from `req.body`, the rest of the code will change as this is a simple example using an in-memory array, and most production APIs will use a database.

##### Challenge

For the following exercises, use the provided database helper functions inside `/data/db.js` to work with the users from the database.

Implement a `GET` endpoint that will accept an `id` as a route parameter and return the user corresponding to that `id`. If the user is not found return the correct HTTP Status Code.

Implement all CRUD operations on users, including get by ID.

Add sorting and pagination support to the GET all endpoint. For pagination the client should supply the API with sorting information, the number of users per page, and the page number.

##### Dig Deeper

-   [HTTP Messages on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)  
    MDN Article about the anatomy of HTTP Requests and Responses

------------------------------------------------------------------------

#### Learn to explain the basics of the REST architectural style

**RE**presentational **S**tate **T**ransfer or `REST` is set of principles, introduced in 1999 by Roy Fielding, that define a way to design distributed software. The [original document introducing REST can be read here](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).

In this module we’ll take a high level look at the key principles of `REST`.

##### Overview

`REST` is a generally agreed-upon set of principles and constraints. They are **recommendations**, not a standard.

When designing a RESTful Web API, keep the following principles in mind:

-   everything is a **resource**.
-   each resource is accessible via a **unique URI**.
-   resources can have multiple **representations**.
-   communication happens over a **stateless** protocol (HTTP).
-   resource management happens via **HTTP methods**.

By applying the `REST` architecture to our APIs, we can make them scalable and simpler to maintain and extend.

##### Follow Along

REST APIs have six constraints:

-   **client-server** architecture.
-   **stateless** architecture: each request should stand on its own, and order should not matter. No shared state.
-   **cacheable**: improves network performance.
    -   `GET`, `PUT`, and `DELETE` should be *idempotent* (the same command executed multiple times, the state of resources on the server is exactly the same, much like pure functions)
    -   `POST` is *not* idempotent.
    -   Caching is a way to store and retrieve data so that future requests can be fulfilled faster without repeating expensive calculations or operations.
-   **layered system**: component A (a client) might or might not communicate directly with component B (the server). There may be other layers between them like logging, caching, DNS servers, load balancers, and authentication.
-   **code on demand**
    -   The API returns the resource and code to act on it.
    -   The client only needs to know how to execute the code.
    -   Makes the API more flexible, upgradable and extendible.
    -   Most web application, send JavaScript code along with the data.
-   **uniform interfaces**
    -   Each resource should be accesible through a single url. Not a hard requirement, but recommended.
    -   We should be able to manage the resources through these *representations* (the URL).
    -   every interaction with the resource should happen through the URL identifier we gave to it.
    -   Self-descriptive messages.
    -   **HATEOAS** (**H**yepermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tate). Much like a *choose your own adventure book*, the pages are not read in order. You start at page 1, and based on the information available, the reader (client) chooses the action to take, moving them to a different page. A good example of a hypermedia API is [the GitHub API](https://api.github.com).

##### Challenge

Write a short paragraph explaining what we mean by REST in the context of web API design.

Submit your paragraph to your Project Manager.

------------------------------------------------------------------------

#### Learn to use Express Routers to organize Web API code

As your application matures and becomes larger, the number of resources and routes will likely follow suit. This can quickly add complexity to our Web API. If you find yourself thinking *“this server file has too many lines of code”*, it’s time to brake it down into different files.

Express **Routers** are a way to split an application into sub-applications to make it more modular and easier to maintain and reason about.

In this module we’ll:

-   use Express Routers to reorganize our code for readability.
-   discuss common patterns used to structure the files and folders in our Web API.
-   use the `CommonJS` module system to share code among different files.

##### Overview

An Express `Router` behaves like a mini Express application. It can have it’s own `Routing` and `Middleware`, but it needs to exist inside of an Express application. Think of routers as organizing Express applications because you write separate pieces that can later be *composed* together.

This should all become clear with an example.

We’ll start with our main server file.

    const express = require('express');

    const server = express();

    server.use('/', (req, res) => res.send('API up and running!'));

    server.listen(8000, () => console.log('API running on port 8000'));

If our applications looked like this, we wouldn’t need routers, but now imagine that this application needs endpoints to see a list of users, get details for a single user, add users, modify existing users, and also inactivate users. That is at least 5 endpoints for the `users` resource.

Now imagine this application also needs to deal with products, orders, returns, categories, providers, warehouses, clients, employees, and more. Even if we only have 5 endpoints per resource, each endpoint will have many lines of code, and you can see how trying to cram all that code in a single file could get unwieldy real fast.

Let’s rewrite it to separate the main server file from the file handling the routes for users.

Create a file to handle all routes related to the user resource.

    // inside /users/userRoutes.js <- this can be place anywhere and called anything
    const express = require('express');

    const router = express.Router(); // notice the Uppercase R

    // this file will only be used when the route begins with "/users"
    // so we can remove that from the URLs, so "/users" becomes simply "/"
    router.get('/', (req, res) => {
      res.status(200).send('hello from the GET /users endpoint');
    });

    router.get('/:id', (req, res) => {
      res.status(200).send('hello from the GET /users/:id endpoint');
    });

    router.post('/', (req, res) => {
      res.status(200).send('hello from the POST /users endpoint');
    });

    // .. and any other endpoint related to the user's resource

    // after the route has been fully configured, then we export it so it can be required where needed
    module.exports = router; // standard convention dictates that this is the last line on the file

Now, even if the user resource needs 8 or 10 endpoints, they are packaged neatly into this file.

How can we use it in our main file? Like so:

    const express = require('express');

    const userRoutes = require('./users/userRoutes');
    const productRoutes = require('./products/productRoutes');
    const clientRoutes = require('./clients/clientRoutes');

    const server = express();

    server.use('/users', userRoutes);
    server.use('/products', productRoutes);
    server.use('/clients', clientRoutes);

    server.listen(8000, () => console.log('API running on port 8000'));

Much cleaner, we added three sets of endpoints to our server where each needs only two lines of easy to read and understand code.

There is an alternative syntax for writing route handlers, but we’ll leave that for you to explore.

Also, note that **it is possible to have a central router that represents our API and have that router import the routes**. This logic cleans up our main server file even more. Let’s see a quick example of that.

    const express = require('express');

    const apiRoutes = require('./api/apiRoutes');

    const server = express();

    server.use('/api', userRoutes);

    server.listen(8000, () => console.log('API running on port 8000'));

And the `apiRoutes` could look like this:

    // inside /api/apiRoutes.js <- this can be place anywhere and called anything
    const express = require('express');

    // if the other routers are not nested inside /api then the paths would change
    const userRoutes = require('./users/userRoutes');
    const productRoutes = require('./products/productRoutes');
    const clientRoutes = require('./clients/clientRoutes');

    const router = express.Router(); // notice the Uppercase R

    // this file will only be used when the route begins with "/api"
    // so we can remove that from the URLs, so "/api/users" becomes simply "/users"
    router.use('/users', userRoutes);
    router.use('/products', productRoutes);
    router.use('/clients', clientRoutes);

    // .. and any other endpoint related to the user's resource

    // after the route has been fully configured, then we export it so it can be required where needed
    module.exports = router; // standard convention dictates that this is the last line on the file

As you can see, routers can *use* other routers.

The `userRoutes`, `productRoutes` and `clientRoutes` remain unchanged (other than relocating them inside the API folder).

In the next section, follow along as we practice using Routers.

##### Follow Along

Let’s implement a simple API that returns strings, but takes advantage of Express Routers. Express routers are overkill for such a simple application, but in larger applications, there would be many benefits to taking this approach.

We’ll build it from scratch. First, follow these steps to create the folder and main server file:

-   create an empty folder for our Web API, feel free to name it anything you’d like.
-   **CD into the folder** you just created and type `npm init -y` to generate a default `package.json` file. The `-y` flag saves time by answering `yes` to all the questions that the `npm init` command would ask one at a time.
-   open the folder in your favorite text editor.
-   inside the `package.json` file, change `"test": "echo \"Error: no test specified\" && exit 1"` inside the `scripts` object to read: `"start": "nodemon index.js"`. This will let us run our server using `nodemon` by typing `npm start` at the command line/terminal. **Make sure to save the file.**
-   we need to install `nodemon` as a development time dependency only because it is not needed when we deploy our server to production. Type `npm install -D nodemon` and that will add it to the `devDependencies` property in our `package.json` file.
-   create a file to host the server code, we’ll call it `index.js`.
-   add the basic code to create our Express server and have a default `/` endpoint we can use to test that our server is responding to requests.

    const express = require('express');

    const server = express();

    server.use('/', (req, res) => res.send('API up and running!'));

    // using port 9000 for this example
    server.listen(9000, () => console.log('API running on port 9000'));

-   add the `express` npm module: `npm install express`.
-   start the server by typing `npm start`.
-   test it by visiting: <http://localhost:9000>0 in your browser.

Let’s add our first router to manage the `races` resource.

-   create a folder called `races` to host our router.
-   create a file called `raceRoutes.js` and add the following code:

    const express = require('express');

    const router = express.Router();

    router.get('/', (req, res) => {
      const races = ['human', 'elf', 'hobbit', 'wizard', 'dwarf', 'orc'];

      res.status(200).json(races);
    });

    module.exports = router;

Now open your `index.js` file and use the newly created router by following these steps.

-   require the `raceRoutes.js` file after requiring Express.
-   use the race router to handle the `/races` endpoint.

Our `index.js` file now looks like this:

    const express = require('express');

    const raceRoutes = require('./races/raceRoutes');

    const server = express();

    server.use('/races', raceRoutes);

    server.use('/', (req, res) => res.send('API up and running!'));

    server.listen(9000, () => console.log('API running on port 9000'));

Visiting <http://localhost:9000/races>s should return our array of strings.

Great job! You are on your way to writing well-structured APIs that other team members (including your future self) will love working with!

##### Challenge

Using your newly learned Express Router expertise, add a second Router to handle the `/villains` endpoint. Return a list of names of two or three villain characters you remember (even better if it’s from the Lord of The Rings to be consistent).

##### Dig Deeper

-   [Express Router Documentation](https://expressjs.com/en/4x/api.html#router)  
    Express Router Guide

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node API 2 Guided Project

Starter code for Node API 2 lecture

[GitHub Repo](https://github.com/LambdaSchool/node-api2-guided)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Node API 2 Project](https://github.com/LambdaSchool/node-api2-project)

    Afternoon project for Node API 2 Module

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Server-Side Routing with Express for Web PT 18 w/ Jason Maurer](https://youtu.be/5hM03hEC2IQ)**

    Node’s HTTP server uses a single request handler function for all requests. Express provides a way to break the application into different request handlers for each URL+ HTTP method combination.

-   [All previous recordings](/archive/FSW/module/recBjiSulq0PYLCIj)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Your assignment is to add endpoints to handle `POST`, `PUT` and `DELETE` for the `/users` route. Returning a JSON response similar to what we did in the code-along is sufficient.

-   Objective challenge:

    For the following exercises, use the provided database helper functions inside `/data/db.js` to work with the users from the database.

    Implement a `GET` endpoint that will accept an `id` as a route parameter and return the user corresponding to that `id`. If the user is not found return the correct HTTP Status Code.

    Implement all CRUD operations on users, including get by ID.

    Add sorting and pagination support to the GET all endpoint. For pagination the client should supply the API with sorting information, the number of users per page, and the page number.

-   Objective challenge:

    Write a short paragraph explaining what we mean by REST in the context of web API design.

    Submit your paragraph to your Project Manager.

-   Objective challenge:

    Using your newly learned Express Router expertise, add a second Router to handle the `/villains` endpoint. Return a list of names of two or three villain characters you remember (even better if it’s from the Lord of The Rings to be consistent).

-   Guided Project: Node API 2 Guided Project

-   Project: Node API 2 Project

-   Code Challenge: SumAndProduct

-   Code Challenge: StackMachine
