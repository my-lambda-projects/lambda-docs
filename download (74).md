Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science

<a href="/cs/sprint/reckLrPDHRpFN3a6p" class="bd-toc-link">1.  Computer Science Fundamentals</a>

-   [Python Basics](/cs/module/recHNgXTaBpnn052p/)
-   [Problem Solving](/cs/module/recagU9ihCuMePtbx/)
-   [Time and Space Complexity](/cs/module/recZ6g2C5xkxHmT16/)
-   [Computer Memory Basics](/cs/module/recy2QANAS6Blpc5o/)

<a href="/cs/sprint/recdbs5ZPBtMb6fou" class="bd-toc-link">2.  Data Structures and Algorithms I</a>

-   [Array and String Manipulation](/cs/module/recR43dkPzilEMXlE/)
-   [Linked Lists](/cs/module/recQJcAAjpSTtNf8A/)
-   [Queues and Stacks](/cs/module/rec07JKgm7ltWrPYD/)
-   [Searching and Recursion](/cs/module/rec00Cf3TiBWiCONA/)

<a href="/cs/sprint/recyC7E0YQc0qQgxa" class="bd-toc-link">3.  Data Structures and Algorithms II</a>

-   [Binary Search Trees](/cs/module/recgJOPYUjvQaN2sa/)
-   [Tree Traversal](/cs/module/recS3C67spna4M4HU/)
-   [Graphs I](/cs/module/recEPIaHFEriTuU2x/)
-   [Graphs II](/cs/module/recX4dkkIPeJ6JjX6/)

<a href="/cs/sprint/recsJW8CaZiKcyUZj" class="bd-toc-link">4.  Data Structures and Algorithms III</a>

-   [Hash Tables I](/cs/module/recLpJY4yFQcV3qeW/)
-   [Hash Tables II](/cs/module/recG6onEnlSOWziKO/)
-   [Technical Interview Tips I](/cs/module/reczaVKTynSkqN8ZS/)
-   [Technical Interview Tips II](/cs/module/rec6kEjLri9SXMYdE/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Review](#review)

# Binary Search Trees

<span class="lead"> </span>

**At the end of this module, you should be able to:**

-   describe the properties of a binary tree and the properties of a "perfect" tree
-   recall the time and space complexity, the strengths and weaknesses, and the common uses of a binary search tree
-   construct a binary search tree that can perform basic operations with a logarithmic time complexity

#### Pro Tip

A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.

John Gall, “Systemantics: How Systems Really Work and How They Fail”

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=1uoWLo9-rUE), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=XqF8SQzMHyA), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=mvuDGJFkKbQ), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe the properties of a binary tree and the properties of a "perfect" tree

##### Overview

A binary tree is a specific type of tree data structure. It is made up of nodes where each node has a maximum of two children. The children are usually named `left` and `right`.

Here is an example of a what a class for a binary tree node might look like:

    class BinaryTreeNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

##### Follow Along

With this simple class, we can now build up a structure that could be visualized like so:

![](https://tk-assets.lambdaschool.com/c00c8f45-abff-4c3a-b29b-92631b5ac88e_binary-tree-example.001.png)

### “Perfect” Trees

One thing to notice about this tree is that each level of the tree is full. There are no missing nodes. This type of tree is called a “perfect” tree.

If a binary tree is perfect, they have specific properties:

1.  The total number of nodes on each level of the tree doubles as the tree grows.

    ![](https://tk-assets.lambdaschool.com/36747e43-d96d-40c9-b8ab-d318f6da8aed_binary-tree-example-levels.001.png)

2.  The number of nodes that the last level contains is equal to the sum of all the other level’s nodes plus one. So, the last level has slightly more than half of the nodes on a perfect tree.

These properties are useful for understanding how to calculate the *height* of a tree. The height of a tree is the number of levels that it contains. Based on the properties outlined above, we can deduce that we can calculate the tree’s height with the following formula:

<img src="https://i.upmath.me/svg/log_2(n%2B1)%20%3D%20h" data-align="center" alt="log_2(n+1) = h" />

In the formula above, `n` is the total number of nodes. If you know the tree’s height and want to calculate the total number of nodes, you can do so with the following formula:

<img src="https://i.upmath.me/svg/n%20%3D%202%5Eh%20-%201" data-align="center" alt="n = 2^h - 1" />

We can represent the relationship between a perfect binary tree’s total number of nodes and its height because of the properties outlined above.

##### Challenge

1.  Calculate how many levels a perfect binary tree has given that the total number of nodes is 127.
2.  Calculate the total number of nodes on a perfect binary tree, given that the height of the tree is 8.

##### Dig Deeper

-   <https://en.wikipedia.org/wiki/Binary_tree>  
-   <https://www.geeksforgeeks.org/binary-tree-data-structure/>  

------------------------------------------------------------------------

#### Learn to recall the time and space complexity, the strengths and weaknesses, and the common uses of a binary search tree

##### Overview

A binary search tree is a particular type of binary tree that orders its nodes precisely. The rules for a binary search tree are:

1.  All the nodes to the left of the current node are smaller.
2.  All the nodes to the right of the current node are larger.

A binary search tree is balanced if the heights of its left and right subtrees differ by at most one, and both the of the subtrees are also balanced.

![](https://tk-assets.lambdaschool.com/f84f26b9-09f3-48e0-a4c6-a51740d9c083_binary-tree-example-balanced-unbalanced.001.png)

##### Follow Along

### Time and Space Complexity

#### Lookup

If a binary search tree is balanced, then a lookup operation’s time complexity is logarithmic (`O(log n)`). If the tree is unbalanced, the time complexity can be linear (`O(n)`) in the worst possible case (virtually a linear chain of nodes will have all the nodes on one side of the tree).

#### Insert

If a binary search tree is balanced, then an insertion operation’s time complexity is logarithmic (`O(log n)`). If the tree is entirely unbalanced, then the time complexity is linear (`O(n)`) in the worst case.

#### Delete

If a binary search tree is balanced, then a deletion operation’s time complexity is logarithmic (`O(log n)`). If the tree is entirely unbalanced, then the time complexity is linear (`O(n)`) in the worst case.

#### Space

The space complexity of a binary search tree is linear (`O(n)`). Each node in the binary search tree will take up space in memory.

### Strengths

A binary search tree has the same level of performance for lookups as a sorted array. However, insertions and deletions are faster (`O(log n)` vs. `O(n)`).

In the worst case, binary search trees also outperform dictionaries (`O(log n)` vs. `O(n)`). That being said, in the average case, dictionaries beat a binary search tree with `O(1)` time complexity.

Binary search trees are also sorted by default. You can pull out all of the elements in sorted order by conducting an *in-order* traversal.

### Weaknesses

The primary weakness of a binary search tree is that the performance degrades if it becomes unbalanced. Some binary search trees have internal operations that keep them balanced automatically, but if not, and the binary search trees are unbalanced, the operations are `O(n)`.

The other weakness is that they are not the fastest at any one thing. Binary search trees are good at a broad number of things but not good at one thing. Either an array or a dictionary will be faster at certain operations.

If you want to learn more about trees that automatically rearrange their nodes to remain balanced, look into [AVL trees](https://en.wikipedia.org/wiki/AVL_tree) or [Red-Black trees](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)

##### Challenge

1.  In your own words, explain why an unbalanced binary search tree’s performance becomes degraded.

##### Dig Deeper

-   <https://www.geeksforgeeks.org/binary-search-tree-data-structure/>  
-   <https://en.wikipedia.org/wiki/Binary_search_tree>  

------------------------------------------------------------------------

#### Learn to construct a binary search tree that can perform basic operations with a logarithmic time complexity

##### Overview

To create a binary search tree, we need to define two different classes: one for the nodes that will make up the binary search tree and another for the tree itself.

##### Follow Along

Let’s start by creating a `BSTNode` class. An instance of `BSTNode` should have a `value`, a `right` node, and a `left` node.

    class BSTNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

Now that we have our basic `BSTNode` class defined with an initialization method let’s define our `BST` class. This class will have an initialization method and an `insert` method.

    class BST:
        def __init__(self, value):
            self.root = BSTNode(value)

        def insert(self, value):
            self.root.insert(value)

Notice that our `BST` class expects each `BSTNode` to have an `insert` method available on an instance object. But, we haven’t yet added an `insert` method on the `BSTNode` class. Let’s do that now.

    class BSTNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

        def insert(self, value):
            if value < self.value:
                if self.left is None:
                    self.left = BSTNode(value)
                else:
                    self.left.insert(value)
            else:
                if self.right is None:
                    self.right = BSTNode(value)
                else:
                    self.right.insert(value)

Now that we can insert nodes into our binary search tree let’s define a `search` method that can lookup values in our binary search tree.

    class BST:
        def __init__(self, value):
            self.root = BSTNode(value)

        def insert(self, value):
            self.root.insert(value)

        def search(self, value):
            self.root.search(value)

Our `BST` class expects there to be a `search` method available on the `BSTNode` instance stored at the root. Let’s go ahead and define that now.

    class BSTNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

        def insert(self, value):
            if value < self.value:
                if self.left is None:
                    self.left = BSTNode(value)
                else:
                    self.left.insert(value)
            else:
                if self.right is None:
                    self.right = BSTNode(value)
                else:
                    self.right.insert(value)

        def search(self, target):
            if self.value == target:
                return self
            elif target < self.value:
                if self.left is None:
                    return False
                else:
                    return self.left.search(target)
            else:
                if self.right is None:
                    return False
                else:
                    return self.right.search(target)

##### Challenge

To implement a `delete` operation on our `BST` and `BSTNode` classes, we must consider three cases:

1.  If the `BSTNode` to be deleted is a leaf (has no children), we can remove that node from the tree.
2.  If the `BSTNode` to be deleted has only one child, we copy the child node to be deleted and delete it.
3.  If the `BSTNode` to be deleted has two children, we have to find the “in-order successor”. The “in-order successor” is the next highest value, the node that has the minimum value in the right subtree.

Given the above information, can you write pseudocode for a method that can find the *minimum value* of all the nodes within a tree or subtree?

##### Dig Deeper

-   <https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/>  
-   <https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/>  

------------------------------------------------------------------------

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[CSPT15 Binary Search Tress with Tom Tarpey](https://youtu.be/7S2-NCq2fa4)**

    Lecture Recording

-   [All previous recordings](/archive/cs/module/recgJOPYUjvQaN2sa)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:
    1.  Calculate how many levels a perfect binary tree has given that the total number of nodes is 127.
    2.  Calculate the total number of nodes on a perfect binary tree, given that the height of the tree is 8.

-   Objective challenge:
    1.  In your own words, explain why an unbalanced binary search tree’s performance becomes degraded.

-   Objective challenge:

    To implement a `delete` operation on our `BST` and `BSTNode` classes, we must consider three cases:

    1.  If the `BSTNode` to be deleted is a leaf (has no children), we can remove that node from the tree.
    2.  If the `BSTNode` to be deleted has only one child, we copy the child node to be deleted and delete it.
    3.  If the `BSTNode` to be deleted has two children, we have to find the “in-order successor”. The “in-order successor” is the next highest value, the node that has the minimum value in the right subtree.

    Given the above information, can you write pseudocode for a method that can find the *minimum value* of all the nodes within a tree or subtree?
