<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web Applications II

<a href="/web3/sprint/recq59MvEIZfUAohy" class="bd-toc-link">1.  Advanced React</a>

- [Class Components](/web3/module/recnDKrWb24lgaziC/)
- [The React Lifecycle](/web3/module/rec1DPoOZSmocXfak/)
- [Composing and Sharing Non-Visual Behavior](/web3/module/recAxmnYmusEi8JuL/)
- [Testing Web Applications](/web3/module/rechTQVfCg4p85Hoi/)

<a href="/web3/sprint/recukritK1B1pFrcM" class="bd-toc-link">2.  Advanced State Management</a>

- [The Reducer Pattern](/web3/module/rectpk6uIV3pCHJh8/)
- [Redux](/web3/module/recba2NUdVmgKYyR3/)
- [Async Redux](/web3/module/recSoiWNJzGURrXYh/)
- [Context API](/web3/module/recByjgF7FwwH5Z7W/)

<a href="/web3/sprint/recnhsJGy28gNi1K5" class="bd-toc-link">3.  Advanced Web Applications</a>

- [Testing React](/web3/module/recS9H6qCj0dQe32B/)
- [Client-Side Authentication](/web3/module/recQlbCZf9tOVgiXC/)
- [HTTP / AJAX II](/web3/module/recupVjaAKPqbuk7Y/)
- [Deploying Web Apps](/web3/module/receOMvCB7dSyX5FL/)

<a href="/web3/sprint/recVFiuMBzbcZllxC" class="bd-toc-link">4.  WEB Unit 3 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Testing Web Applications

<span class="lead"> </span>

In this module we will learn about automated testing, and more specifically how to write unit tests with Jest and react-testing-library.

**At the end of this module, you should be able to:**

- explain what automated testing is and its importance
- use react-testing-library for testing react components
- use react-testing-library to test user interactions with fireEvent

#### Pro Tip

We all build on the work of others.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=jyWUNzzV29U), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=uFXGcLpbBMU), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=vItkiDBCVcc), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain what automated testing is and its importance

Testing is essential for software quality. It should be integrated into the development process from beginning to end. We should not wait until a feature is complete to start testing it. Testing software manually on every commit to source control or every time we make a change does not scale! Automated testing works by using software to test our code.

##### Overview

### Why test

Automated testing minimizes the risk of bugs finding their way into production code. **Testing is NOT optional**. Testing should be a part of every developer’s workflow. A feature is not done until it is fully tested! In direct contrast to manual testing, automated testing significantly reduces the manpower and margin for error needed to confidently ship a product. Though it can’t entirely remove manual testing from the process, it certainly helps.

**In terms of benefits, testing…**

- Surfaces bugs faster.
- Reduces the risk of regressions.
- Allows us to trust the code.
- Makes us think about the edge cases.
- Acts as a safety net when making changes or refactoring.
- Acts as documentation for the code.
- Encourages us to write more testable (better!) code.

**On the other hand, NOT testing…**

- Forces very expensive manual testing.
- Causes bugs and edge cases to be encountered later.
- Makes refactoring or adding features risky and scary.
- Can make codebases fragile and expensive to maintain.
- Makes less documented codebases much harder to understand.

Not writing tests can be thought of as **taking a loan with a very high-interest rate**. The quick payoff is being able to write spaghetti code unhindered. The costs long term can become enormous and surpass hundreds of times over any marginal time gains obtained by not writing tests. Eventually, entire teams of developers can get so bogged down in bugs and regressions that the product can’t move forward.

### Types of testing

There are many different ways of classifying tests. Here are some common levels of testing:

#### Integration testing

In this level, several units of software are tested as a group to ensure they work together correctly.

#### End-to-end testing

End-to-end (E2E) testing is where the whole application is tested, simulating real user scenarios closely. Because these tests are slow and expensive, there should be a thick “cushion” of unit tests in a codebase.

#### Unit Testing

We test the smaller units of software (often functions or methods) in isolation. There are usually many unit tests in a codebase, and because these tests are meant to be run often, they need to run fast. We will talk about this eventually, but not much today.

### When to Test

When trying to determine whether to manually test a feature, or to automate testing, consider the following guidelines:

- Automated testing should be built for any test that is executed often. Internally at Lambda we say “1..2.. automate!” meaning, you should only do a task 2 times manually before you are required to build out a system to automate that test or task for you. It isn’t always relevant, but a catchy motto to consider.
- Automated testing should be built for any difficult manual task - if it requires too much work, or too many steps, that even a 2nd manual test would be a large task, automate it from the start.
- Automated testing should be built for any test that, if it fails, will dramatically affect the use of a product or health of a company. For example, you’d always want to build a test to check for security of credit card information on a payment processing website.

On the flip side, if you’re trying something new, or if test requirements are changing a lot, you can probably hold off on creating an automated test.

### How to Test

The framework we use for testing is: arrange, act, assert. These are three steps that we can take to build good tests. First, we “arrange” our test by setting up our code such that it can be tested. Then, we “act” - calling a method or function that returns a result of interest to our test. Finally, with that return we “assert” if our expected return matched the actual return.

Very often arrange and act will happen in the same line of code, for illustration here we’ve separated these sections, but don’t be scared if you see them together.

##### Follow Along

Read through this article that talks about how to know what to test: https://kentcdodds.com/blog/how-to-know-what-to-test

##### Challenge

Research other types of tests: sanity testing, smoke testing, regression testing, system testing, snapshot testing, acceptance testing.

---

#### Learn to use react-testing-library for testing react components

In the Node ecosystem, small and specialized libraries prevail over large, batteries-included frameworks. In a similar way architecting a React application requires putting together a stack made of several different libraries, testing our React components require that we choose libraries depending on the methodology we favor, and use them together.

##### Overview

In the last objective we discussed the general _what_ and _why_ of testing. Here we’re going to dive into the _how_. We will use the [react-testing-library](https://testing-library.com/docs/react-testing-library/intro) to run tests in this unit. Unlike previous testing libraries, react-testing-library is designed with the user in mind, testing components via DOM nodes, similar to how a user would interact with the front end of a website.

react-testing-library recently underwent a major overhaul - we used to use a different libraries, Enzyme and Jest, for tests that cared more about the internal management of props and state. Now though, we can use react-testing-library to test prop, state, output (in DOM elements), and more.

The “hello world” so to speak in the react-testing-library is a test to check if a component loads without crashing. Here, we declare a test, name it, and check if the App renders.

    test("renders App without crashing", () => {
      render(<App />);
    });

Earlier, we discussed about the “Arrange, Act, Assert” structure for testing. There’s a technical first step, import - we’ll look at all of them below. For more details, check out the [testing-library documentation](https://testing-library.com/docs/react-testing-library/example-intro).

The following matches the structure we’ve studied and is slightly simplified version of what you’‘ll find in the documentation. What we’ll walk through in the tutorial is even more simple but this example is good for illustration.

Here we are testing the `greeting` component to see if our expected greeting (“hello lambdalorians”) appears in the browser as we expect it will per the code below. Important note here, our tests work with text because that’s what the user sees and what the user experiences - the test does not test on classes, for example, because that’s an implementation detail, not a rendered element.

    import React from 'react';

    const Greeting = () => {
      return <h1 class="my-greeting">Hello Lambdalorians!</h1>;
    };

    export default Greeting;

### Import

As with any library, we need to import react-testing-library before we can use it, this all should look more or less familiar from imports we’ve done before. You’ll notice that “Arrange, Act, and Assert” are yet to be filled out.

    // import dependencies
    import React from "react";

    // import react-testing methods
    import { render } from "@testing-library/react";

    // add greeting
    import Greeting from "./Greeting";

    test("renders greeting on Greeting component", async () => {
      // Arrange
      // Act
      // Assert
    });

### Arrange

The `render` method renders a React element into a virtual DOM and returns utility functions for testing the component. Recalling our definition of “arrange”, this is basically the part where we set ourselves up for success. Here, we use `getByText` to set up the action that we want to run later on - checking the greeting text.

    test("renders greeting on Greeting component", async () => {
      // Arrange
      const { getByText } = render(<Greeting />);
      // Act
      // Assert
    });

### Act

The `getByText` method can be used to “query” the DOM for a specific node by its text that we expect to see in the browser. We will use it here to test that our greeting (“hello lambdalorians”) is being rendered by the `<Greeting />` component.

    test("renders greeting on Greeting component", async () => {
      // Arrange
      const { getByText } = render(<Greeting />);
      // Act
      const greeting = getByText(/hello lambdalorians!/i);
      // Assert
    });

A quick note here, you may notice that “hello lambdalorians” is written with `/` instead of `"`s. This is regex syntax and is commonly used in testing. the `i` designates our text as case insensitive so even though we have the string “hello lambdalorians” written, our test will pass even if “hElLo LamBdAlOriAns” is displayed in the browser.

### Assert

Finally, we need to “assert” that the greeting has indeed been rendered. Here we use a couple of new functions - `expect` is a Jest function that is made globally available with create react app. The other, `toBeInTheDocument()`, comes from [Jest DOM](https://testing-library.com/docs/ecosystem-jest-dom), a companion library to react-testing-library that provides custom matchers for Jest. A full list of functions can be found on [GitHub](https://github.com/testing-library/jest-dom). Throughout our examples we assume that you import Jest DOM in create-react-app, and suggest that you always do this, rather than importing it every time.

    test("renders greeting on Greeting component", async () => {
      // Arrange
      const { getByText } = render(<Greeting />);
      // Act
      const greeting = getByText(/hello lambdalorians!/i);
      // Assert
      expect(greeting).toBeInTheDocument();
    });

### Running Tests

You should be at least somewhat familiar with this process from tests that we’ve used throughout Lambda to help your code along. All tests run in the terminal with `npm test` - as you run tests you should see passes and failures in the console. Running this test would result in a “pass” since our earlier code does indeed render “Hello Lambdalorians”.

##### Follow Along

Here, we are testing to see wither learn react will render the way we expect it to.

1.  **Create a React project** with `create-react-app` in command line.

Remember that older versions of Create React App required you to install `@testing-library/jest-dom` and `@testing-library/react` separately. Not anymore. And **we do NOT need to install Jest** either, as CRA projects come with Jest installed and working out of the box.

1.  **Open `App.test.js`** (inside the `src` folder). You should see the below:

        import React from 'react';
        import { render } from '@testing-library/react';
        import App from './App';

        test('renders learn react link', () => {
          const { getByText } = render(<App />);
          const linkElement = getByText(/learn react/i);
          expect(linkElement).toBeInTheDocument();

    });

1.  **Note** a few things about the imports:

- `React` has to be in scope because we will be using JSX.
- `react-testing-library` exposes a render function that we are importing with `import { render }` syntax. This allows us to render React components so we can **test them**.

1.  **Render a React element** containing a “Hello World” message, and run tests as usual:

        it('renders without crashing', () => {
          render(
            <span className="greet">hello world</span>
          );
        });

1.  **Inspect the output** by logging `wrapper.debug()`. See how the element is rendered into a in-memory document-like structure:

![alt text](https://tk-assets.lambdaschool.com/f9be6244-1d0a-4386-ae0e-cf01e20b98f7_ScreenShot2019-04-15at13.56.43.png)

1.  **Capture the node of interest.** Let’s assume the true, actual purpose of some React component returning the jsx `<span>hello world</span>` is to render a “hello” message to the screen for the user to see. We could assert that by mounting such a component, the browser will render a span containing this language. We can use a `dom-testing-library` **query** to capture such an element:

        it('renders without crashing', () => {
          const wrapper = rtl.render(
            <span className="greet">hello world</span>
          );
          // the querying functionality is accessed through the wrapper:
          const element = wrapper.queryByText(/hello/i);

          // assertions will come in here
        });

1.  **Run assertions** about the actual output:

        expect(element).toBeTruthy(); // jest matcher
        expect(element).toBeInTheDocument(); // jest-dom matcher
        expect(element).toBeVisible(); // jest-dom matcher

##### Challenge

Add two more text elements (headers, paragraphs, anchor tags, etc) to the component and write a test for each of them to assert that they are being rendered.

---

#### Learn to use react-testing-library to test user interactions with fireEvent

The philosophy of `@testing-library/dom` is to test UI the same way a user would. We as users would probably test an application by confirming that the visual pieces that are supposed to be there are actually there (like buttons, inputs, links or labels). We would ensure critical content can be read, inputs filled in, and that clicking buttons has the desired effect of having other pieces appear (or go away).

##### Overview

For review, the react-testing-library are designed to mimic how a human would interact with a website, just like the react-testing-library, these tests focus on UI specifically. This again, is just another way to consider the user in design.

We test pieces of interface by capturing what we expect to see (or not see) in the DOM using queries. What should (or should not) be there is rendered to a virtual DOM by the library’s renderer. This is the DOM node of interest (a certain button, a label containing a specific text, an input with some specific value). We can run matchers against that piece of DOM to **assert**, for example, that the selection exists in the document, or that it’s visible.

Let’s consider the example of an increment counter that increases by one every time the `Increment` button is clicked. Set up like so:

    import React, { useState } from 'react';

    const Counter = () => {
      const [count, setCount] = useState(0);

      return (
        <div>
          <h2>{count}</h2>
          <button onClick={() => setCount(count + 1)}>Increment</button>
          <button onClick={() => setCount(count - 1)}>Decrement</button>
        </div>
      );
    };

    export default Counter;

Our test would look something like the following. This should look similar to the example we walked through in the last objective, with just a few more steps added on. Importantly, we simulate a user click with `fireEvent.click(button)` and include multiple assertions at the end.

    import React from "react";

    import { render, fireEvent } from "@testing-library/react";
    import Counter from "./Counter";

    test("increments count when increment button is clicked", async () => {
      // Arrange
      const { getByText } = render(<Counter />);
      // Act
      const count = getByText(/0/i);
      // get the button node
      const button = getByText(/increment/i);
      // simulate a user click
      fireEvent.click(button);
      // Assert
      expect(count).toHaveTextContent("1"); //passes with 1 because we expect it to be 1 after a button click
      expect(count).not.toHaveTextContent("0");
    });

### Break the Test

We’ll tell you to break your tests often. In the example above there are multiple `expect` statements as an attempt to ‘break the test’, this is important and intentional. When testing, we want to “break the test” as much as we possibly can, this is the best (and really the only) way to ensure that your website won’t break when a user goes to try and use it.

##### Follow Along

1.  **Change** `App.js` to output different jsx:
    const App = () => {
    return (
    <section aria-labelledby="KittensHeader">
    <h2 id="KittensHeader">All About Kittens</h2>
    <p className='content'>Lorem ipsum dolor sit amet</p>
    </section>
    }

2.  **Import** the App component into our test file `App.test.js` and render it. You may pass any props you want! Renders the app component.

           import React from 'react';
           import { render } as rtl from '@testing-library/react';
           import App from './App';

           it('renders "all about kittens" text', () => {
             render(<App foo="you may inject props!" />);
           });

3.  **Capture** a piece of the output! We expect some text containing “All About Kittens” to be rendered so we’ll use `queryByText`. This is an example of the `act` phase.

           it('renders "all about kittens" text', () => {
             const { queryByText } = render(<App />);
             const hasKittensText = queryByText(/all about kittens/i);
           });

4.  **Assert** that the `hasKittensText` is actually in the document. If it’s not, the value of `hasKittensText` will be null.

           it('renders "all about kittens" text', () => {
             const { queryByText } = render(<App />);
             // IMPORTANT
             // queryByText() returns either the node, or null:
             const hasKittensText = queryByText(/all about kittens/i);
             expect(hasKittensText).toBeInTheDocument();
           });

5.  **Try out** `getByText()` as an alternative to `queryByText()`.

           it('renders "all about kittens" text', () => {
             const { queryByText } = render(<App />);
             // IMPORTANT
             // getByText() returns either the node, or **FAILS THE TEST** outright:
             expect(getByText(/all about kittens/i));
           });

6.  **Break the test!.** Remember that `getByText`, as well as the rest of the queries that have `get` prefix in their names, will cause a test fail, instead of returning a null value. Queries that have the `query` prefix return `null` if the element is not found.

           it('renders "all about kittens" text', () => {
             const { queryByText } = render(<App />);
             // no matcher needed, although it may be added to improve readability
             expect(getByText(/THIS WILL MAKE THE TEST CRASH AND BURN/i));
           });

    ![alt text](https://tk-assets.lambdaschool.com/8fdc962c-fff0-427f-aa69-41108cf491bb_ScreenShot2019-04-15at17.39.25.png)

7.  **Capture using different criteria.** We have many other queries available to us. In our component, we have an `aria-labeledby` attribute on the `section` to inform screen readers that the element `<h2 id="KittensHeader">All About Kittens</h2>` is actually a label for the `section` element. Let’s capture the `h2` by label text! The point is to test like a user would. We expect a particular label to be there for our users!

           it('renders "all about kittens" text', () => {
             const wrapper = rtl.render(<App />);
             expect(wrapper.getByLabelText(/All About Kittens/i));
           });

##### Challenge

Use the starter code above to create a test that works for the decrement button.

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [React Testing - Contact Form](https://github.com/LambdaSchool/React-Testing-Contact-Form)

  Write tests for a contact form to give you confidence in the component’s code

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Testing Web Applications for Web35 w/ Warren Longmire](https://youtu.be/IH-1DYjcpxg)**

  Testing Web Applications

- [All previous recordings](/archive/WEB3/module/rechTQVfCg4p85Hoi)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Research other types of tests: sanity testing, smoke testing, regression testing, system testing, snapshot testing, acceptance testing.

- Objective challenge:

  Add two more text elements (headers, paragraphs, anchor tags, etc) to the component and write a test for each of them to assert that they are being rendered.

- Objective challenge:

  Use the starter code above to create a test that works for the decrement button.

- Project: React Testing - Contact Form
