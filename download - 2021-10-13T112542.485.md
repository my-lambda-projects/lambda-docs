Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAwVjE2LjA2MDlDMCAyNy43MzM1IDkuMDg5MjkgMzEuNzg0MyAxNS43MzIxIDM0Ljc1MTNIMTUuNzVMMTYuMjg1NyAzNUMxNi40MTA3IDM0LjkyODkgMTYuNTM1NyAzNC44NzU2IDE2LjY3ODYgMzQuODIyM0MxNi43NSAzNC43ODY4IDE2LjgzOTMgMzQuNzUxMyAxNi45MTA3IDM0LjcxNTdDMjMuNTcxNCAzMS43NjY1IDMyLjY5NjQgMjcuNjk4IDMyLjY5NjQgMTYuMDYwOVYwSDBaTTIwLjcwNzEgMjMuNDUzNkwyMC4zNTcxIDIyLjUxMDJMMTUuNjA3MSAxMC4wNzM2QzE1LjMyMTQgMTAuODAyIDE0LjY2MDcgMTIuNTYwOSAxMy45NDY0IDE0LjQ0NDJMMTEuMjE0MyAyMS43ODE3QzExLjA4OTMgMjIuMTM3MSAxMS4xNjA3IDIyLjMxNDcgMTEuMjUgMjIuNDM5MUMxMS40NDY0IDIyLjY3MDEgMTEuODc2OCAyMi42NzAxIDEyLjU1NTQgMjIuNjcwMUgxMi42Nzg2TDEyLjY3NjggMjMuNDUxOEg3LjU2OTY0VjIyLjY3MDFINy45NjI1QzguNjU4OTMgMjIuNjcwMSA5LjIzMDM2IDIyLjM2OCA5LjY1ODkzIDIxLjUxNTJMMTAuMTc2OCAyMC4zNDI2TDE0LjkwODkgOC4yOTY5NkwxNC4wNjk2IDYuMDc2MTRIMTguNDgwNEwyNC41Njk2IDIyLjAxMjdMMjUuMTI1IDIzLjQ1MzZIMjAuNzA3MVoiIGZpbGw9IiNFQzM5NDQiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj4KICAgICAgICAgICAgICAgIDx0aXRsZT5NZW51PC90aXRsZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTQgN2gyMk00IDE1aDIyTTQgMjNoMjIiPjwvcGF0aD4KICAgICAgICAgICAgICA8L3N2Zz4=)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+CiAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjkyLjksMTI2LjZoLTYuN2MtOSwwLTEyLjYtMS45LTEyLjYtOS41VjQ4LjVjMC03LjcsMS42LTguNiwxMS40LTkuN3YtNC41aC00MS4zdjQuNSBjOS44LDEuMSwxMS40LDEuOSwxMS40LDkuN3Y2OS4zYzAsNy43LTEuNiw4LjYtMTEuNCw5Ljd2NC41aDczLjdsNC45LTI5LjRoLTQuNEMzMDguNSwxMTkuNiwzMDMuOSwxMjYuNiwyOTIuOSwxMjYuNnoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01MTQuNCwxMjFWNzkuNWMwLTE0LjgtNi0yMi40LTE4LjctMjIuNGMtMTEuNSwwLTE5LjQsNi42LTI1LjUsMTMuOWMtMS44LTkuNi03LjctMTMuOS0xNy44LTEzLjkgYy0xMS40LDAtMTguNyw2LjItMjQuOCwxMy42VjU3aC0yLjNsLTIzLjgsNy40djIuNGw4LjYsNXY0OS40YzAsNS0yLjEsNi4xLTguOSw2LjR2NC40aDM1LjF2LTQuNGMtNi43LTAuMy04LjctMS4zLTguNy02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43djQwLjhjMCw1LTEuOSw2LjEtOC43LDYuNHY0LjRsMzQuOCwwdi00LjRjLTYuNy0wLjMtOC42LTEuMy04LjYtNi40di00NyBjNC43LTMuNiw5LjUtNi41LDE1LjUtNi41YzcuNiwwLDEwLjUsNC4yLDEwLjUsMTIuN2wtMC4xLDQwLjVjMCw1LTEuOCw2LjQtOC42LDYuN2wwLDQuNGgzNS4xdi00LjQgQzUxNi43LDEyNy40LDUxNC40LDEyNi4xLDUxNC40LDEyMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTU3My4yLDU3LjNjLTExLDAtMTguNSw1LjctMjMuNCwxMi44VjIyLjloLTIuN2wtMjMuNCw2Ljh2Mi41bDguNiw0LjVWMTMyaDIuOWw4LTMuNWM1LjgsMy4zLDEyLjMsNSwyMC4yLDUgYzIwLjgsMCwzNy40LTE1LjgsMzcuNC00Mi42QzYwMC45LDY5LjksNTkwLjQsNTcuMyw1NzMuMiw1Ny4zeiBNNTYzLjQsMTI4LjdjLTUuNCwwLTEwLjMtMi40LTEzLjctNy45VjczLjYgYzMuNC0zLjQsOC41LTUuNywxMy41LTUuN2MxMy45LDAsMjAsMTIuOCwyMCwyOS41QzU4My4zLDExNC43LDU3NS44LDEyOC41LDU2My40LDEyOC43eiI+CiAgICAgICAgICAgICAgICA8L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPgogICAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTc0Ny4xLDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMXYtMC4xaDAuMWwwLDExLjFsMjYsMC4xdi00LjVDNzQ5LjMsMTI3LjEsNzQ3LjEsMTI2LjIsNzQ3LjEsMTIxLjF6IE03MjkuNiwxMTcuOGMtNC40LDMuMy03LjYsNS4zLTEyLjEsNS40Yy03LjcsMC0xMS4yLTUuMi0xMS4yLTEyLjZjMC03LjcsMy42LTExLjIsOS44LTEzLjVsMTMuNC01LjRMNzI5LjYsMTE3LjhMNzI5LjYsMTE3Ljh6Ij4KICAgICAgICAgICAgICAgIDwvcGF0aD4KICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+CiAgICAgICAgICAgICAgPC9wYXRoPgogICAgICAgICAgICA8L3N2Zz4=" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

---

- [Prepare](#prepare)
- [Learn](#learn)
- [Project](#project)
- [Review](#review)

# Recursive Sorting

<span class="lead"> </span>

**At the end of this module, you should be able to:**

- identify when a problem is amenable to a recursive solution and use recursion to solve it
- trace and accurately identify the output of a recursive function call
- write a recursive solution to a problem
- distinguish when to use, classify the performance, and implement code to conduct classic recursive sorting algorithms

#### Pro Tip

Keep in mind that anything you put on social media reflects your brand. Consider what is important for you to say and for other people to hear you say, and use this to shape a social media presence that is both professional and authentic to you.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=n59qpp0SNDo), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=TYsKscmQCWA), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to identify when a problem is amenable to a recursive solution and use recursion to solve it

##### Overview

### What is recursion?

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

Recursion is a method to solve problems. It means breaking down a problem into smaller and smaller sub-problems until the sub-problem is easy to solve. Recursive functions call themselves. Often, recursive solutions are terse and elegant. Recursive solutions are not always the most efficient. However, they can be an excellent starting point that you can improve the efficiency of afterward.

### A simple example

Let us say that I give you a list of numbers.

    my_list = [1,2,3,4,5]

I ask you to write a function that returns the sum of all the numbers in the list.

With an iterative approach, you would need a variable to keep track of the sum, a loop that adds each item in the list to the sum, and to return the sum after the loop ends.

    def sum_list(items):
        sum = 0
        for i in items:
            sum = sum + i
        return sum

This iterative function depends on the ability to loop through each item in the list. Another way to iterate through a collection is with recursion. It’s a little harder to understand at first, but the resulting code is often cleaner, simpler, and easier to understand.

How many numbers can you sum without having to rely on the loop construct? The answer is two. How can we think of our problem as a collection of sums of only two numbers?

I’ll put it another way. If you had the following, and I asked you to use parentheses to split the problem into sums of two numbers, how would you do it?

    1 + 2 + 3 + 4 + 5

Here is one way you could do it:

![](https://tk-assets.lambdaschool.com/ac0a1098-22e7-4539-a291-0e5a0dbb5c3c_S2-M2-Illustrations-011.gif)

You start by separating the problem into two subproblems:

    1 + 2 + 3 + 4 + 5
    (1 + (2 + 3 + 4 + 5))

Now, we continue doing so until we can no longer divide the problem into two subproblems:

    1 + 2 + 3 + 4 + 5
    (1 + (2 + 3 + 4 + 5))
    (1 + (2 + (3 + 4 + 5)))
    (1 + (2 + (3 + (4 + 5))))
    (1 + (2 + (3 + (4 + (5)))))

Now, let’s see if we can use this example to write a recursive function to sum a list of numbers.

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

The first thing we need to consider for our recursive function is how do we know when to stop adding parentheses?

When we add the first set, we are asking, what is the sum of the first item and the sum of the rest of the items?

![](https://tk-assets.lambdaschool.com/e0a128da-753f-4ec7-bd71-c93c1e1e3416_S2-M2-O1FirstandRest.gif)

But, as we continue dividing the problem into subproblems, we “run out” of the “rest of items.” Once we no longer have a list of items longer than one, we cannot break up the list into the first item and the rest of the items. So, if someone asks us to sum one number, we know that the result is equal to that number. This “running out” is the base case for our recursive function.

_Note: we usually place the base case of a recursive function in the first few lines of the function, but it doesn’t have to be._

Let’s start writing out our function in pseudocode:

    sum_list(items)
        if the length of items is one
            return the one item in the list

But what if someone asks us to sum more than one item? We must sum the first number and the sum of the rest of the items in the list.

Let’s add this to our pseudocode:

    sum_list(items)
        if the length of items is one
            return the one item in the list
        otherwise
            return the first item from the list + sum_list(the rest of the items)

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

Now, let’s convert our pseudocode into actual Python code:

    def sum_list(items):
        if len(items) == 1:
            return items[0]
        else:
            return items[0] + sum_list(items[1:])

![upeR](https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg)

Now that we have our function defined let’s see what happens when we call it.

![](https://tk-assets.lambdaschool.com/6f586ee8-343f-4c62-a94e-fbda772ab2e9_S2-M2-O1-Sum-List-Call-Stack-Animation.gif)

Now, you can see how the recursive calls go “out” before they return and start working their way “back” to the original call.

### An even simpler example

Maybe you are still confused? Let’s write a recursive function that can print each integer from `n` down to `0`.

We start by writing our function in pseudocode.

    print_to_zero(n):
        print n
        if n is 0
            return
        return print_to_zero(n - 1)

The first line of our pseudocode function prints the value of `n`. Then, we check the base case, is `n` equal to `0`, and if it is, we return and stop recursing. The final return in our pseudocode is our recursive case, where we decrement the previous call’s `n` value and call the function itself with that decremented value (the recursive case).

Let’s turn it into actual Python code and then look at a visualization of the call stack when we call this function.

    def print_to_zero(n):
        print(n)
        if n == 0: # base case
            return
        return print_to_zero(n - 1) # recursive case

![Print to Zero Visualization](https://tk-assets.lambdaschool.com/f6d24e36-d891-4127-bb06-ea22cb2247ec_S2-M2-O1PrinttoZeroVisualization.gif)

One thing you might’ve realized is that our current function doesn’t handle inputs of less than `0`. Ideally, our function should be able to handle these inputs without getting stuck in an infinite recursion (which would lead to a stack overflow).

Let’s modify our function so that it handles inputs of less than zero.

    def print_to_zero(n):
        if n < 0: # base case
            return
        print(n)
        return print_to_zero(n - 1) # recursive case

### Three rules of recursion

Let’s use our `sum_list` function to see if we could make more generalized observations about recursion.

The three rules for a recursive function are:

1.  Must have a base case.
2.  Must change its state to move towards the base case.
3.  Must call itself.

#### 1. Must have a base case

The first rule for recursion is that a recursive algorithm **_must have a base case_**.

What is a base case? It allows the algorithm to _stop_ recursing. With our `sum_list` function, what allows the algorithm to stop recursing?

It’s the first line, `if len(items) == 1:`. Notice how if this condition is true, it returns a value and doesn’t make a recursive call to itself. We are saying to stop recursing if the list to sum has only one item.

    def sum_list(items):
        if len(items) == 1: # Base Case
            return items[0]
        else:
            return items[0] + sum_list(items[1:])

#### 2. Must change its state to move towards the base case

The second rule is that the algorithm **_must change its state to move towards the base case_**.

How does our function do that? With each subsequent recursion, the list passed into `sum_list` is one item smaller. For example, on the first recursion `items` is `[2,3,4,5]` and on the subsequent recursion `items` is `[3,4,5]`.

    def sum_list(items):
        if len(items) == 1: # Base Case
            return items[0]
        else:
            return items[0] + sum_list(items[1:]) # items[1:] has one less item

It’s obvious then that regardless of the list’s length, we will reach the base case where the list we are summing has only one item.

#### 3. Must call itself

The third rule is that the algorithm **_must call itself_**. We are doing this on the final line of the function.

    def sum_list(items):
        if len(items) == 1: # Base Case
            return items[0]
        else:
            return items[0] + sum_list(items[1:]) # Calls sum_list recursively

![](https://tk-assets.lambdaschool.com/fc57628d-9174-46f8-811c-aeac4e532706_S2-M2-Illustrations-O1-Rules-For-Recursion.gif)

### When should I use recursion?

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

Now that we’ve considered one recursive algorithm and we’ve also discussed the three rules of recursion, we should think about when it is appropriate to use recursion.

When you are out in the world solving real-world problems, the problem itself doesn’t say, “Hey! You should use recursion to solve me!” It’s your job as the problem-solver to decide if using recursion makes sense.

So, what clues or hints might you find within a problem that could lead you to use recursion?

- Compute the nth term
- List the first or last n terms
- Generate all permutations

Another way to think about it is to use the three rules. Is there a clear base case or stopping point that you are working towards (Rule 1)? Is there a clear way that the state of the data changes with each iteration that brings it closer to the base case (Rule 2)?

##### Follow Along

We now look at another typical example to learn recursion–computing factorials.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

A factorial (`n!`) is computed by taking `n * (n-1) * (n-2) * ... 1`.

For example, `4!` is computed by doing the following:

`4 * (4 - 1) * (4 - 2) * (4 - 3)`

`4 * 3 * 2 * 1`

`24`

When does computing factorials come in handy? They are required when figuring combinations; how many ways can we arrange this many items? Or how many orders can there be with this list? Also, they are useful for determining ways of choosing a certain number of items from a collection. For example, if you have 100 different menu items, how many possible 5-item orders could you make?

Okay, let’s get back to our `4!` example. Let’s look again at the computation and see if we can make some connections to our three rules for recursion.

`4! = 4 * (4 - 1) * (4 - 2) * (4 - 3)`

First, how did we know to stop writing? Why didn’t we just keep going?

`4! = 4 * (4 - 1) * (4 - 2) * (4 - 3) * (4 - 4) * (4 - 5) * (4 - 6) * ...`

Well, before when talking about the general case we wrote factorial like

`n! = n * (n - 1) * (n - 2) * ... 1`

What is the last item in the procedure, or how did we know to stop? When the item is `1`. Could this serve as the base case for our recursive factorial function? Let’s try it out!

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

We start by writing pseudocode.

    recursive_factorial(n)
        if n equals 1
            return 1

Okay, so now we have a base case (Rule 1). But what about changing the state to move towards the base case (Rule 2)?

Let’s look again at `4!`

`4! = 4 * (4 - 1) * (4 - 2) * (4 - 3)`

Notice that just like we can write `4!` as `4 * (4 - 1) * ... 1`, we can write `(4 - 1)!` as `(4 - 1) * (4 - 2) * ... 1`. So, the inverse would also be true; we can write `(4 - 1) * (4 - 2) * ... 1` as `(4 - 1)!`. Which means we can write `4!` as `4 * (4 - 1)!`.

Okay, we can’t miss what we just discovered. Our discovery means that we can express factorial in terms of itself. For any `n!` we can solve it by breaking it into smaller sub-problems that also require factorial (Rule 3). And Rule 2 is satisfied because we make each subsequent call to factorial on a smaller `n`.

    recursive_factorial(n)
        if n equals 1
            return 1
        otherwise
            return n * recursive_factorial(n - 1)

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

Now, we just need to convert our pseudocode into actual Python code. Luckily, in Python, this is usually quite trivial to do.

    def recursive_factorial(n):
        if n == 1:
            return 1
        else:
            return n * recursive_factorial(n - 1)

##### Challenge

1.  Write a _recursive_ search function that receives as input an array of integers and a target integer value. This function should return `True` if the target element exists in the array, and `False` otherwise.
    - What would be the base case(s) we’d have to consider for implementing this function?
    - How should our recursive solution converge on our base case(s)?
2.  In your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.

---

#### Learn to trace and accurately identify the output of a recursive function call

##### Overview

### What is a stack?

A stack is a simple data structure. In the future, we cover stacks in more detail, but for now, a cursory understanding is helpful.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

Let’s start with an example. What if you were throwing a dinner party, and you had a bunch of tasks to get done before your friends started arriving? One method for tracking your to-do items would be to get some sticky notes, write our tasks on a sticky note, and place them in a pile. To choose what to work on, you’d take the top sticky note off the pile and discard it after you complete it. If in the course of your work, you think of another task to complete, you’d write a new sticky note and place it on top of the pile.

So, there are two ways of interacting with a stack. You can **pop** the top item off, or you can **push** an item onto the top.

### What is the call stack?

The whole reason we are talking about stacks in the first place is so we can understand the call stack. Call stacks help us understand recursion.

Whenever your program calls a function, the computer sets aside a chunk of memory for that function’s execution context. Any variables in that function scope are stored here.

The computer stores these chunks of memory in the call stack, which has two fundamental operations; pushing onto the top and popping off the top of the stack. The computer pushes a chunk on the stack when a function is called. The computer pops a chunk off when a function finishes executing and returns. Let’s look at a simple example.

We have two functions defined in our scope–one to add 2 to our input and another to add 4.

    def add_two(num):
        return num + 2


    def add_four(num):
        return add_two(add_two(num))

Let’s think about what the call stack looks like when we call these functions. First, what happens when we run the following:

    add_two(2)
    add_four(6)

![](https://tk-assets.lambdaschool.com/5dca1dc0-856b-44cb-a010-0f0304577567_S2-M2-O2-Add-2-Add-4.gif)

1.  `add_two` call gets pushed onto the call stack
2.  `num` gets stored in memory with the value `2`
3.  `num + 2` gets returned as `4` and that call gets popped off
4.  `add_four` call gets pushed on the stack, and `6` gets stored as `num`
5.  the innermost `add_two` call gets pushed onto the stack, and `6` gets stored as `num`
6.  the innermost `add_two` call returns `8` and pops off
7.  the second `add_two` call gets pushed onto the stack with `8` as `num`
8.  the second `add_two` call
9.  returns `10` and gets popped off
10. we are back in the context of `add_four`, which now returns `10` and pops off the stack
11. the stack is now empty

##### Follow Along

### Fibonacci

Next, we look at the Fibonacci Sequence. (Here is an [interesting talk](https://www.youtube.com/watch?v=SjSHVDfXHQ4) about the Fibonacci Sequence.)

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

This is a series of numbers:

    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

We can derive the next number in the sequence by summing the previous two numbers. So, the next number in the series shown above would be 55 (34 + 21).

![](https://tk-assets.lambdaschool.com/9cb8ba72-5a54-4f6c-a356-3783c6467455_S2-M2-Illustrations-O2-Fibonacci.gif)

We can write the Fibonacci Sequence like this:

![](https://tk-assets.lambdaschool.com/917bd4a9-b98f-413f-a292-8dbfe9e67ca0_S2-M2-Illustrations-Fibonacci-Sequence-Table.001.jpeg)

So, we can write the 7th term as x<sub>n</sub>, and you can describe any term in the sequence as:

x<sub>n</sub> = x<sub>n-1</sub> + x<sub>n-2</sub>

Using this rule, if you wanted to find the 10th term, you could write:

x<sub>10</sub> = x<sub>10-1</sub> + x<sub>10-2</sub>

x<sub>10</sub> = x<sub>9</sub> + x<sub>8</sub>

x<sub>10</sub> = 34 + 21

x<sub>10</sub> = 55

With the information above, it’s easy to write a simple, naïve algorithm to find the n<sup>th</sup> term in the Fibonacci Sequence.

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

We can start with pseudocode.

    recursive_fib(n):
        if n is less than or equal to 1
            return n
        otherwise
            return recursive_fib(n - 1) + recursive_fib(n - 2)

Luckily, since this is quite a simple algorithm, it is relatively trivial to convert this into Python code.

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

    def recursive_fib(n):
        if n <= 1:
            return n
        else:
            return recursive_fib(n-1) + recursive_fib(n-2)

The function now represents the rules for the sequence that we’ve gone over. The base cases are the first two terms in the sequence; the 0<sup>th</sup> term is 0 and the 1<sup>st</sup> term is 1. For every other term, we find the value by summing the previous two terms.

Despite having a good understanding of the function and the rule for the sequence, we may not have an excellent conceptual understanding of what happens with the call stack when the function gets called–let’s inspect closer.

To more clearly illustrate the building of the stack, we will split our return statement up like this:

    def recursive_fib(n):
        if n <= 1:
            return n
        else:
            n_minus_1 = recursive_fib(n-1)
            n_minus_2 = recursive_fib(n-2)
            return n_minus_1 + n_minus_2

Now, let’s find the 4th item in the sequence by calling `recursive_fib(4)`.

![](https://tk-assets.lambdaschool.com/6af00728-5ab9-4013-893a-63fd932664c5_S2-M2-O2-Recursive-Fib-Call-Stack.gif)

It might be helpful to watch the call stack animation above many times – until you understand what is happening. It can take some time, but eventually, it clicks, and it makes all future recursion problems easier when it does.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

The stack gets kicked off by the first `recursive_fib(4)` call. Then, on line 5, `recursive_fib(3)` gets pushed onto the stack. Then, `recursive_fib(2)` and `recursive_fib(1)`. We are finally at a base case. That means we should be able to return and pop something off the stack. We do, and `recursive_fib(1)` returns `1` and pops off the stack. We are now on line 6 in the context of the `recursive_fib(2)` call. Now, we push `recursive_fib(0)` onto the stack, which returns `0` and immediately pops off. Again, in the context of `recursive_fib(2)`, we can now return our sum of `n_minus_1` and `n_minus_2`. These values are `1` and `0` respectively, so we return `1` and pop `recursive_fib(2)` off the stack.

Now, we are in the context of `recursive_fib(3)`, and we push `recursive_fib(1)`, which returns `1` and pops off. We can now return from `recursive_fib(3)` with `1 + 1` or `2`.

Next, in the context of `recursive_fib(4)`, we push `recursive_fib(2)` onto the stack. What you should notice here is that we have to repeat what we previously did when we pushed `recursive_fib(2)` to get to `1 + 0` or `1`. _This should get you thinking of what you would do differently in a recursive function to prevent this repeat behavior._

Once we repetitiously build and tear down the stack to get `1`, we are ready to return from our `recursive_fib(4)` context. We return `2 + 1` or `3`, pop `recursive_fib(4)` off the stack, and now our call stack is empty.

Here is another way to visualize what is happening as we build and tear down the stack:

![](https://tk-assets.lambdaschool.com/9b54936d-1d54-4b46-b75c-26d2214ecbaf_S2-M2-Illustrations-Recursive-Fib-Tree-Call-Stack.gif)

##### Challenge

1.  You are still learning the ins and outs of recursion and suppose you end up making a mistake and writing a recursive function that runs forever. Your computer separates a spot in memory on the call stack for each function call. What ends up happening to the stack when your recursive function keeps running forever?
2.  What two operations does a stack have?
3.  Where do all function calls go?
4.  I am tasking you with tiling a 2” x 16” area of the floor. The tiles you are using are 1” x 2”. How many ways are there to cover the area with tiles? _See three possible layouts in the image below._ ![](https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg)

---

#### Learn to write a recursive solution to a problem

##### Overview

The first problem we will solve using recursion is reversing a string. We need to write a recursive function that takes in a string and returns the reverse of that string.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

To start, let’s consider how we can break this problem into subproblems. Once we do that, the recursive solution will make itself apparent. Let’s consider the string `"LAMBDA"`. The reverse of `"LAMBDA"` is `"ADBMAL"`. We must figure out a way to restate the process of reversing a string in terms of itself.

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

We need to figure out how you can reverse a string by reversing smaller and smaller substrings. So, upon reflection, we can realize that the reverse of `"LAMBDA"` is the reverse of `"AMBDA"` + `"L"`. And, continuing, the reverse of `"AMBDA"` is the reverse of `"MBDA"` + `"A"`. So, now that we’ve figured out a way to break our problems into smaller subproblems, we need to figure out how we know when to stop or what would be the base case?

Well, let’s just continue our example above and see if the base case will make itself apparent.

- The reverse of `"MBDA"` is equal to the reverse of `"BDA"` + `"M"`.
- The reverse of `"BDA"` is equal to the reverse of `"DA"` + `"B"`.
- The reverse of `"DA"` is equal to the reverse of `"A"` + `"D"`.
- The reverse of `"A"` is equal to the reverse of `""` + `"A"`.

Now, once we get to the reverse of `""`, we don’t have any further substrings to make. You can’t make a substring out of an empty string, so this seems like the logical base case where we can begin returning and start popping off the call stack.

![](https://tk-assets.lambdaschool.com/5a122628-d0fe-4f6d-a953-7398dddc849e_S2-M2-Illustrations-O3-Reverse-String-Call-Stack.gif)

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

So, we now undertand our recursive case and our base case. We now need to turn that into actual Python code. For our recursive case, where we are stating `reverse("LAMBDA") = reverse("AMBDA") + "L"`, we can state this in general terms as `reverse(str) = reverse(str[1:]) + str[0]`. And we can check for an empty string for our base case with `len(str) == 0`.

    def reverse(str):
        if len(str) == 0:
            return str
        else:
            return reverse(str[1:]) + str[0]

Now that we’ve coded it up. Let’s test it out and visualize how our recursive calls will affect the call stack.

![](https://tk-assets.lambdaschool.com/cb5f36b7-ff23-406d-a295-ecdca6ec3b7c_S2-M2-O3-Reverse-String-Call-Stack-Visualization.gif)

![upeR](https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg)

Notice how our call stack builds until we get to our base case, and then we start returning our strings, popping off the stack, and can slowly assemble our reversed string.

##### Follow Along

Next, we will use recursion to check if a string is a palindrome. So, our recursive function will receive a string as an input and return `True` if the string is a palindrome and return `False` if it is not a palindrome.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

First, what is a palindrome? A palindrome is a sequence of characters that reads the same forwards and backward. For example, `"abcddcba"` is a palindrome, but `"abcd"` is not.

Let’s try to reason what the simplest subproblem would be and see if we can come up with a base case. One thing to notice right away is that a string of one character or an empty string is a palindrome by definition. So, our base case is a string of length 1 or 0.

Now, how do we move closer towards the base case with each subsequent function call? Well, one thing we have to notice is that for all palindromes, the first and last characters are equal. So, for example, we know right away that `"abcd"` is not a palindrome because the first and last characters (`a` and `d`) are not the same. Thinking about this further, this is how we could break our massive problem into subproblems. Notice that for a palindrome like `"abcddcba"`, the property of the first and last characters matching is true for the outer string but also true for each inner substring.

![](https://tk-assets.lambdaschool.com/1a3f8eed-917a-4d17-b743-7d856c6fffa7_S2-M2-Illustrations-Palindrome.001.jpeg)

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

So, now we understand our base case (a string of length 0 or 1) and our recursive case(first and last characters or equal). Let’s represent the full recursive solution in pseudocode:

- If the string is of length 0 or 1, it is a palindrome.
- Otherwise, compare the first and last characters.
  - If the first and last characters are equal, strip those characters and check if the remaining characters are a palindrome.

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

Now that we defined the pseudocode let’s turn it into actual Python code.

    def is_palindrome(str):
        # If the string is of length 0 or 1, it is a palindrome.
        if len(str) <= 1:
            return True
        # Otherwise, compare the first and last characters.
        if str[0] == str[-1]:
            # If the first and last characters are equal, strip those characters and check if the remaining characters are a palindrome.
            return is_palindrome(str[1:-1])
        return False

![upeR](https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg)

Let’s visualize the call stack when we call our defined function.

First, we will look at an example on a string that is a palindrome.

![](https://tk-assets.lambdaschool.com/2ab1dabe-ace3-474f-a716-48b4c6376035_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization.gif)

Next, let’s look at an example on a string that is not a palindrome.

![](https://tk-assets.lambdaschool.com/5adac8b7-ea52-4672-9f5f-121407618850_S2-M2-O3-Is-Palindrome-Call-Stack-Visualization-2.gif)

Notice, how in both cases, the call stack keeps building until it can reach one of the base cases. The first base case is if the string is of length 0 or 1 (returns `True`). The second is if the first and last character **do not** match (returns `False`). Once one of the function calls returns a boolean value, this bubbles up to the first call and is the return value for the original function call.

##### Challenge

1.  I place you in the hexagon that is labeled “Start”. I task you with getting to the hexagon that is labeled “End”. Each move, you can only take one step to a neighboring cell, and you must move to the right (closer to the hexagon labeled “End”). How many unique ways can you reach the hexagon labeled “End”?

    ![](https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg)

_Hint: the Fibonacci Sequence can help solve this problem._

---

#### Learn to distinguish when to use, classify the performance, and implement code to conduct classic recursive sorting algorithms

##### Overview

Previously, we explored some iterative approaches to sorting the elements in a list or an array. However, many of these iterative solutions are not efficient in terms of their runtime or the memory required. In this module, we look at ways we can sometimes achieve performance gains by using a recursive approach.

![Uper](https://tk-assets.lambdaschool.com/e8906256-ad3c-499e-802b-ca09439c1e6c_U_per.svg)

### Divide and Conquer

The “Divide and Conquer” (D&C) strategy means solving a recursive problem by:

1.  Figuring out the base case or the simplest case.
2.  Dividing the massive problem into increasingly smaller problems until you reach the base case.

Let’s use a simple example to illustrate D&C.

Imagine I give you an array of integers.

    [1, 2, 3, 4, 5]

I ask you to sum all the integers. I specifically ask you to solve this problem recursively.

Following the steps above, we need first to find the base case. Well, the simplest thing to sum would be an array that only contained 1 or 0 integers. In that case, the sum would either be `[]` (for an empty array) or the integer itself for an array of 1 integer. So, our base case is an array of length 1 or 0.

Now, for step two, we need to move closer to the base by dividing the larger problem into a smaller problem. We can do this by restating the original problem like this:

    sum([1,2,3,4,5]) = 1 + sum([2,3,4,5])

Let’s visualize how this would play out.

![](https://tk-assets.lambdaschool.com/f9275ff3-345f-46a3-99f3-79225bc00ee2_S2-M2-O4-Sum-Call-Stack-Visualization.gif)

### Quicksort

#### How It Works

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

Quicksort is another “Divide and Conquer” algorithm. The rules for the simple out-of-place version are:

1.  Choose a pivot.
2.  Move everything less than the pivot to one side.
3.  Move everything more than the pivot to the other side.
4.  Repeat steps 1-3 on the left-hand side and right-hand side of the partition.

For an illustration of this simple out-of-place version of quicksort, see below:

![](https://tk-assets.lambdaschool.com/0919779a-f288-4621-9962-2fa41cab5293_S2-M2-O4-Out-Of-Place-Quick-Sort-Animation.gif)

#### Runtime

![upeR](https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg)

##### Worst-case

The worst-case occurs when the pivot you choose at each step is the smallest or greatest element in the list. If that continues happening with each partition, the maximum number of partitions occurs. Here, quicksort takes `O(n^2)` time.

##### Average-case

If the list that you are sorting contains `n` distinct elements, then quicksort takes `O(n log n)` time–assuming that all `n!` permutations of `n` elements are equally probable to occur in your list.

### In-Place Quicksort

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

There is another, more elaborate version of quicksort that sorts the data in-place. The rules for this version are:

- If the pivot is on the left.
  - We compare the pivot with the right element.
  - If the right element is larger than the pivot.
    - We swap the values of the right element and the pivot.
    - The right element becomes the new pivot.
    - We increment the left index.
  - If the right element is smaller than the pivot.
    - We decrement the right index value.
- If the pivot is on the right.
  - We compare the pivot with the left element.
  - If the pivot value is larger than the left element.
    - We increment the left index.
  - If the pivot value is smaller than the left element.
    - We swap the values of the left element and the pivot.
    - The left element becomes the new pivot.
    - We decrement the right index.
- If pivot, left, and right all point to the same element.
  - That element is sorted.
  - Create left and right partitions.
  - Set new pivot, left, and right for both partitions starting with the left.
  - Repeat above procedure.

For an illustration of this in-place quicksort, see below:

![](https://tk-assets.lambdaschool.com/fee5b497-5a12-4ebb-9721-bbf6bb846de8_S2-M2-O4-In-Place-Quicksort-Animation.gif)

### Merge Sort

#### How It Works

Merge Sort is a recursive algorithm that uses the “Divide and Conquer” strategy outlined above.

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

First, the base case is when you have an array with 1 element. Second, to move towards the base case, you must repeatedly divide the original collection in half until we reach the base case.

What is unique about lists or arrays with a single element? In other words, why is that the base case? The answer is because _they are already sorted!_ A single element can’t be unsorted.

Then, we can “merge” these sorted pieces back together.

![](https://tk-assets.lambdaschool.com/3af0fec1-d59f-480f-a79a-c91c2c63e476_S2-M2-O4-Merge-Sort-Animation.gif)

#### Runtime Complexity

![upeR](https://tk-assets.lambdaschool.com/06c68a6f-1332-4f6a-9703-f787c5e9a77f_upe_R.svg)

The “divide” part of this algorithm requires us to cut a collection of elements in half until we have collections of 1. If our collection contains `n` elements, we have to perform more halving operations as `n` increases in size. However, the rate of growth is logarithmic rather than linear. This part of the algorithm has a runtime of `O(log(n))`.

The “conquer” (merge) part of this algorithm requires only a single pass through each sorted sub-collection, giving it a runtime of `O(n)`.

Since we “divide” and then “conquer”, we can think about the total runtime of merge sort as `O(log(n)) * O(n)` or `O(n * log(n))`.

##### Follow Along

### Quicksort

There are many ways of completing the quicksort stub shown below. Specifically, there are many approaches to choosing a pivot. A simple approach is to use the first element in `array`. Other approaches include choosing the middle element or even a random element.

![upEr](https://tk-assets.lambdaschool.com/8da923c7-c453-474c-b0bf-e6dc09ffc59d_up_E_r.svg)

    def quicksort(array):
        if len(array) < 2:
            # Base case: arrays with 0 or 1 element are already "sorted"
            return array
        else:
            # Recursive case
            pivot = array[0]
            # Sub-array of all the elements less than the pivot
            less = [ i for i in array[1:] if i <= pivot]
            # Sub-array of all the elements greater than the pivot
            greater = [i for i in array[1:] if i > pivot]

            return quicksort(less) + [pivot] + quicksort(greater)

### Merge Sort

When implementing merge sort, we often split the “Divide” and “Conquer” pieces of this algorithm into two separate functions to help improve readability. The recursive `merge_sort()` handles dividing up the original list or array into a left-hand side and right-hand side. At the same time, the `merge_helper()` merges two sorted pieces back together into a single sorted collection.

![uPer](https://tk-assets.lambdaschool.com/af718a9e-cdaf-4722-8f01-499f0d056c0b_u_P_er.svg)

    def merge_sort( arr ):
        if len( arr ) > 1:
            # recursively call merge_sort() on LHS
            # recursively call merge_sort() on RHS
            # merge sorted pieces

    def merge_helper( a, b ):
        merged_arr = []

        # starting at the beginning of `a` and `b`
        # compare the next value of each
        # add smallest to `merged_arr`

        return merged_arr

_Note: Remember that `Python` passes collections by reference, not by value._

We are not showing a completed implementation of the merge sort algorithm here. You will create an implementation as a part of the module project.

##### Challenge

1.  What is the Big O notation for the following operation:

    _Creating a multiplication table with all the elements in an array. If your array is \[1, 2, 3\], you first multiply every element by 1, then every element by 2, and then every element by 3._

2.  What will the contents of the array below be after each pass of the quicksort algorithm? _(assume we choose the first element as the pivot)_

    ![](https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png)

3.  What will the contents of the array below be after each pass of the merge sort algorithm?

    ![](https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Recursive Sorting](https://github.com/LambdaSchool/cs-module-project-recursive-sorting)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Recursive Sorting for CS35 w/ Sean Chen](https://youtu.be/jbm-eWQYbDI)**

  Student should be able to identify when a problem is amenable to a recursive solution and use recursion to solve it

- [All previous recordings](/archive/CS/module/reccRh9h6ccXghfA4)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  1.  Write a _recursive_ search function that receives as input an array of integers and a target integer value. This function should return `True` if the target element exists in the array, and `False` otherwise.
      - What would be the base case(s) we’d have to consider for implementing this function?
      - How should our recursive solution converge on our base case(s)?
  2.  In your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.

- Objective challenge:

  1.  You are still learning the ins and outs of recursion and suppose you end up making a mistake and writing a recursive function that runs forever. Your computer separates a spot in memory on the call stack for each function call. What ends up happening to the stack when your recursive function keeps running forever?
  2.  What two operations does a stack have?
  3.  Where do all function calls go?
  4.  I am tasking you with tiling a 2” x 16” area of the floor. The tiles you are using are 1” x 2”. How many ways are there to cover the area with tiles? _See three possible layouts in the image below._ ![](https://tk-assets.lambdaschool.com/48e800ca-d097-4932-ae3a-156e20bb7659_S2-M2-Illustrations-Objective-2-Block-Examples.001.jpeg)

- Objective challenge:

  1.  I place you in the hexagon that is labeled “Start”. I task you with getting to the hexagon that is labeled “End”. Each move, you can only take one step to a neighboring cell, and you must move to the right (closer to the hexagon labeled “End”). How many unique ways can you reach the hexagon labeled “End”?

      ![](https://tk-assets.lambdaschool.com/7fd20061-0bd2-41cc-baa5-bfe6cd74b776_S2-M2-Illustrations-Objective-3-You-Do-Problem.001.jpeg)

  _Hint: the Fibonacci Sequence can help solve this problem._

- Objective challenge:

  1.  What is the Big O notation for the following operation:

      _Creating a multiplication table with all the elements in an array. If your array is \[1, 2, 3\], you first multiply every element by 1, then every element by 2, and then every element by 3._

  2.  What will the contents of the array below be after each pass of the quicksort algorithm? _(assume we choose the first element as the pivot)_

      ![](https://tk-assets.lambdaschool.com/0be5d64f-13df-49b6-8c65-a7b76b0ed1d9_Resources25.png)

  3.  What will the contents of the array below be after each pass of the merge sort algorithm?

      ![](https://tk-assets.lambdaschool.com/6241ce91-f75f-4bad-9828-24606c359509_Resources24.png)

- Project: Recursive Sorting
