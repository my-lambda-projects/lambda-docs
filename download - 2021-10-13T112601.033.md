Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

- [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

- [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
- [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

- [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
- [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
- [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

- [REST](/csannex/module/rec7YHjLuXabdlhof/)
- [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
- [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

- [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
- [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

- [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

- [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
- [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
- [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
- [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
- [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
- [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
- [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

- [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

- [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
- [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

- [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
- [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
- [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

- [REST](/csannex/module/rec7YHjLuXabdlhof/)
- [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
- [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

- [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
- [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

- [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

- [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
- [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
- [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
- [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
- [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
- [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
- [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Introduction To C

<span class="lead"> </span>

As the students’ first introduction to the C programming language, this sprint aims to expose students to topics pertaining to low-level languages, such as strong typing, pointers, and memory allocation. The structure of this sprint mimics the structure of other sprints that introduce students to a new language.

**At the end of this module, you should be able to:**

- describe and use header files, basic types, arrays, strings, flow control, and functions in C
- describe how a computer's memory model works and how pointers relate to this memory model in C
- utilize pointers appropriately in order to work with dynamic memory
- use structs to create more complex composite types in C

#### Pro Tip

A quick temper will make a fool of you soon enough.

Bruce Lee

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=-VzxJwHDFsM), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=MI_C_Qt4RCM), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=uloU0VqOV7k), or enable JavaScript if it is disabled in your browser.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=3tBW2Hhocbk), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe and use header files, basic types, arrays, strings, flow control, and functions in C

While there are many important topics that fall under the umbrella of C programming, there are a few fundamental concepts that you will likely need to use, regardless of the type of application you are developing. Some concepts, like header files, may be new, depending on what languages you have worked with previously. Others, like data types and functions, are very similar to their counterparts in other languages like JavaScript.

##### Overview

### Header Files

Listed at the top of the program:

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>

Each included _header file_ gives access to the functionality declared in that header file.

- Only `#include` the files you need
- Consult the `man` page for the function to see what you want to `#include`
  - If the `man` page doesn’t look right, like it’s for another language, try other manual sections, especially 2 and 3:
    - `man 2 fork`
    - `man 3 printf`

### Types

#### Numeric Types

    // Sample declarations

    int a;      // a is an integer
    long a;   // a is a long integer--holds bigger values

    float f;    // floating point number, like 3.14159
    double f; // double-precision floating point number--holds more precise values

    char c;   // 1-byte integer value, or a character

Initialization:

    int a = 12;
    float f = 32.9;

Implicit and Explicit Type Casting:

    int a = 5.1;
    printf("The value stored in a is %d\n", a); // Output: The value stored in a is 5
    //This is as expected.  Integers cannot store decimals, so the value is implicitly type cast from a float to an integer.  The decimal is discarded.

    float b = a;
    printf("The value stored in b is %f\n", b); // Output: The value stored in b is 5.000000
    //This is as expected.  Floats can store the information present in an integer.  The value is implicitly converted to a float, in this case 5.000000

    int c = 5/7;
    printf("The value stored in c is %d\n", c); // Output: The value stored in c is 0
    //This is as expected.  Integer math discards decimals, so 5/7 == 0 in integer-speak.

    float d = 5/7;
    printf("The value stored in d is %f\n", d); // Output: The value stored in d is 0
    //What gives?  5/7 is a decimal number, and floats can do that, right?
    //The issue arises from the order of operations in the statement.
    //When the compiler sees the '/' operator, it looks at the types of the operands and performs the appropriate operation.
    //Because 5 and 7 are both integers, it uses the integer version of divide.
    //As in example a, (int) 5 divided by (int) 7 results in (int) 0, then, as above in example b, the value 0 is implicitly type cast from an int to a float.
    //The above format is actually how we solve this problem

    float e = (float) 5 / 7;
    printf("the value stored in e is %f\n", e); // Output: The value stored in e is 0.714286
    //This is what we expected.  The compiler sees that one of the operands is a float, and provides a result accordingly.
    //You don't need to typecast both operands to get this result, but be careful with order of operations.
    // (float)( 5/7 ) will first handle the division as integer math, then typecast the result into a float, resulting in 0.000000 again.

#### Arrays

    int a[20];        // array of 20 ints
    float f[2][20]; // 2D array, 2 rows of 20 columns of floats

Initialization:

    int a[5] = {4, 7, 2, 9, 3};
    int b[2][3] = { { 1,2,3}, {4,5,6} };

    // Autosize the array to 3 elements:
    int c[] = {10, 50, 100};

#### Strings

Strings are stored as a pointer to the first element. The string terminates with a `NUL` (`\0`) character. That is, a `NUL` is found at the end of the string.

    char *s; // s is a pointer to a char, or string

Initialization:

    char *s = "Hello, world!";

    // Or into an array:
    char t[] = "This is the secret message";
    char *u = t; // t and u both refer to the same string

#### Functions

    // Function that accepts an int, a float, and retuns a double

    double analyze_data(int d, float f)
    {
        double result;

        //... do something very complicated ...

        return result
    }

    // Function that accepts a string and returns its length:
    int string_length(char *s)
    {
        // ... compute string length ...
        return len;
    }

#### Flow Control

Works just like JavaScript for the most part:

        if (a == b) {
            // ...
        }

        for (i = 0; i < 10; i++) {
            // ...
        }

        while (!done) { // booleans are "int"s, 0 is false
            // ...
        }

        do {
            // ...
        } while (x < 100);

##### Follow Along

Write a function that accepts two arguments and returns the sum.

    #include <stdio.h>

    int add(int a, int b)
    {
        return a + b;
    }

    int main(void)
    {
        int result = add(3, 4);

        printf("3 + 4 = %d", result);

        return 0;
    }

Compiling and running:

    gcc -Wall -Wextra -o add add.c

    ./add

Note that the `-Wall` flag turns on all warnings. The `-Wextra` flag turns on extra warnings.

##### Challenge

Write a function called `intsqrt` that accepts an `int` as an argument, computes the square root of the argument, and returns the result as a `double`.

Use Google-fu to help find the answer.

---

#### Learn to describe how a computer's memory model works and how pointers relate to this memory model in C

One of the main differences between C and other languages students have utilized over the course of Lambda School is that C explicitly manipulates memory addresses and the values those memory addresses point to. This is done for a number of reasons:

- Pointers allow us to separate the actual reference from the value, which can be useful when we want to pass values around. Instead of always having to copy the value around in order to pass it, we can just pass the pointer to the value.

- Functions in C only permit one return value. If we need to return multiple values from a function, this issue can be circumvented by having the function return a pointer to all of the desired return values.

- Pointers allow us to circumvent always needing to know up-front how much memory we want allocated in a string or array, since pointers themselves have fixed sizes, and yet they can refer to some value of arbitrary size and that we may not know the size of up-front.

##### Overview

The C programming language is very much concerned with working with and manipulating memory. Memory, or RAM, can be thought of as nothing more than a giant array. When we work with arrays, there’s always two parts: the value we’re storing in the array, along with the index at which the value is stored at in the array.

Since memory is just a giant array, we’ll need to be cognizant of these same two concepts, the value and its associated index, when working in C.

### When Do You Not Need to Use Pointers?

Pointers are only explicitly necessary when working with values of dynamic sizes. The most common use-cases are when working with arrays, strings, and structs, because these often hold other pieces of data, and we might not know the sizes of those other pieces of data up-front.

However, when working with values where we already know their size up-front, we don’t need to use pointers. When working with integers, floats, and chars, we don’t need to take a pointer to these because the C compiler always knows how large an integer is. In other words, the size of the integer doesn’t inform its size. An `int` type (or `float`, or `double`, etc.) has a ceiling up to which it can store any integer value. So long as the integer we’re storing doesn’t exceed that ceiling, the size of the integer is known to the C compiler.

To put it another way, pointers allow us to reference a value of an arbitrary type using a reference of a known size. The compiler always knows the size of a pointer, even if it doesn’t know the size of whatever that pointer is pointing to.

##### Follow Along

Here’s an example of how to declare a pointer:

        char *str = "I'm a string!";

We can print out the actual _address_, which is the value of the pointer itself, like so:

        printf("%p\n", str);

And we can print out the value that the address is pointing to like so:

        printf("%c\n", *str);

Here we’re using the asterisk again. When the asterisk isn’t used in a variable declaration, it takes on an entirely new meaning. In this case, it’s _dereferencing_ the pointer, which means it’s getting the value (in this case a single character) that the pointer is pointing to.

We can print out the _entire string_, by using the string placeholder (%s) and passing a pointer to our printf() function., like so:

        printf("%s\n", str);

Printf() will begin at the address you pass via pointer and iterate through all of the characters it finds, printing them out until it reaches the terminating character \\0

##### Challenge

Take a look at the following code. At each line, write down what each variable is referring to (i.e. is it referring to a value, or an address?).

        int x = 1, y = 2, z[10];
        int *ip;

        ip = &x;         // What is ip here?
        y = *ip;          // What is y here?
        *ip = 0;          // What is ip here now? What is x now?
        ip = &z[0];    // What is ip now?

---

#### Learn to utilize pointers appropriately in order to work with dynamic memory

Now that students have a fundamental understanding of what pointers are and how to initialize them, they need to practice using pointers in appropriate contexts.

Some examples of these appropriate contexts include:

- Using the `malloc` system call in order to allocate dynamic memory on the heap.
- Passing pointers as function parameters.

##### Overview

Now that we’ve talked about what pointers are, how they’re created / initialized, and how to dereference them, it’s time to talk about the situations in which we would apply pointers. But first off, let’s talk about pointer arithmetic.

### Pointer Arithmetic

One of the neat features of pointers is that they can be incremented, just like array indices can be incremented in order to access subsequent slots in an array. Take a look at the following code:

        char *str = "supercalifragilisticexpialidocious";
        printf("%c\n", *str);
        printf("%c\n", *(str + 1));

The `str` pointer initially points to the first character of the string, “s” in this case. We can advance the pointer by one spot so that it refers to the next character in the string “u”. The parentheses are needed here because typically the dereference operator takes precedence over arithmetic operations, but in this case we specifically want the addition operation to happen before the dereference.

### The Stack and the Heap

Up till this point, all of the variables and data that we’ve been initializing in our C programs has been living in a portion of memory called the Stack. It’s called the Stack because it exhibits Last In First Out ordering, just like a stack data structure does.

The Stack is the portion of memory where function stack frames are stored. Function stack frames are essentially how your machine represents function calls. All of a function’s parameters, variables, and local data are stored in a stack frame on the Stack. If you’ve heard of the term “stack trace”, that is referring to when an error occurs in a function. The Stack is “unwound”, as in all of the stack frames on the Stack are popped off in LIFO order, starting with the most-recent stack frame (the one in which the error occurred). This is how error messages are propagated.

You can think of the Stack as a very temporary form of storage. Data that is local to functions goes on the Stack, and when the stack frame for the function is popped off the Stack, that local data is automatically reclaimed. Sometimes though we want the lifetime of some data to not be tied to a function’s scope, notably things like data structures, which are oftentimes accessed by many functions.

To accommodate for this use case, there’s a separate portion of memory specifically for data that needs to live past the lifetime of any function. This portion of memory is called the Heap, not to be confused with the heap data structure. Unlike the Stack and the stack data structure, which do share similarities, the Heap and the heap data structure share name only; the Heap does not exhibit the same properties as a heap data structure.

Data that lives in the Heap either lives as long as the program that initialized the memory, or until it is explicitly freed by the developer in the same program. Unlike data that lives on the Stack, Heap memory must be explicitly requested and explicitly freed. This makes the Heap ideal for storing data that needs to live longer than just the scope of a single function, or simply for data that the developer wants finer-grained control in terms of when that memory is freed.

### Memory Allocation

One of the most prevalent use-cases of pointers is memory allocation. Memory allocation is facilitated via the `malloc` system call, which requests and returns a chunk of memory on the Heap. Given a parameter that indicates how many bytes of memory the user wants, `malloc` fetches a contiguous chunk of memory that satisfies the request size criteria and then returns a pointer to the first spot of the allocated block. From there, the user is able to fill this contiguous block with data.

`malloc` returns a pointer instead of the actual block of memory because the block of memory can be of _any_ arbitrary size, since the user gets to request how large of a block they want. For large chunks of memory, it would be a lot of work to pass a possibly huge chunk of memory around. Instead, `malloc` just passes an address to the beginning of the block because pointers are comparatively much more compact and portable.

### Passing Pointers to Functions

If you’re familiar with the notion of passing by reference (and you should be), C makes this much more explicit than languages like Python and JavaScript, where there isn’t an explicit concept of pointers. Since pointers _are_ references, any time we pass a pointer to a function we’re passing by reference. This is useful if whenever we’re passing large arrays, strings, and / or objects to functions, since it’s a lot cheaper to just pass a reference than actually passing the whole thing, which would necessitate copying.

So when we pass a reference to something into a function and then mutate that thing inside the function, the mutated thing retains those updates outside the scope of the function. Also, we don’t actually need to explicitly return the pointer to the mutated thing.

##### Follow Along

### Pointer Arithmetic

Going off of the earlier supercalifragilisticexpialidocious string example, we can write a loop to print out every single character separately:

        char *str = "supercalifragilisticexpialidocious";
        int len = strlen(str);    // find the length of the string

        for (int i = 0; i < len; i++) {
            printf("%c\n", *(str+i));
        }

One thing to note about the pointer arithmetic syntax is that it’s equivalent to the familiar array indexing syntax that uses brackets. We can rewrite the for loop like this:

        for (int i = 0; i < len; i++) {
            printf("%c\n", str[i]);
        }

This implies then that the expressions `*(str+i)` and `str[i]` are equivalent. Indeed, the bracket notation is simply syntactic sugar on top of the pointer arithmetic syntax.

### Using `malloc`

The following are examples of using `malloc`:

        int *100_ints = malloc(100 * sizeof(int));
        char *50_chars = malloc(50 * sizeof(char));

In both of the these cases, the variables `100_ints` and `50_chars` are pointers that are pointing to blocks of memory of their respective requested sizes, but these blocks haven’t been filled in with anything yet.

We could then go and fill in the `malloc`‘d block of memory with data like so:

        for (int i = 0; i < 100; i++) {
            *(100_ints+i) = rand();    // fill the ith slot with a random int
        }

Another important thing to note is that whenever you allocate memory with `malloc`, you need to garbage collect that memory when you’re done with it. This is as simple as calling the `free` function, which takes as its only parameter a pointer to `malloc`‘d memory. That memory is then freed so that it can be used by other processes.

### Passing Pointers to Functions

Let’s take a look at the following function that performs element-wise addition on two input integer arrays:

        void element_wise_add(int *result, int *a, int *b, int len)
        {
            for (int i = 0; i < len; i++) {
                *(result+i) = *(a+i) + *(b+i);
            }
        }

In this example, since every parameter to the function except for the length is a pointer, there’s no need to copy any of the integer arrays into the body of the function. Only the addresses where each array is located is copied in the function’s scope, and we can access the underlying array values by dereferencing the pointers. Note that our function can just have a return type of `void` since nothing needs to be returned from the function in order for us to see the changes performed by the function.

##### Challenge

1.  Write a C function `matrix_alloc` that receives two integer parameters `cols` and `rows` and have your function allocate a two-dimensional array of integers. Here, the parameter `cols` specifies the number of columns of the allocated matrix, and `rows` represents the number of rows. What will be the return type of this function?

2.  Write a function `matrix_free` that receives a matrix created by `matrix_alloc` and frees it.

---

#### Learn to use structs to create more complex composite types in C

C provides us a way to create composite types from other pre-existing types. This is facilitated via structs. Students will learn how to use structs to create new composite types and data structures.

##### Overview

So far, we’ve only been exposed to types that C provides to us by default. How do we create any new types? How do we create data structures?

Luckily, C provides us with structs. Structs allow us to create new types that are composites of other existing types. Using this, we can create new types as well as data structures.

##### Follow Along

### An Example Struct Definition

Let’s say we wanted to create a Person type that stored a person’s name, age, and weight. We could do that with a struct:

        struct Person {
            char *name;
            int age;
            float weight;
        }

Our Person struct is a conglomeration of multiple other types that each hold a piece of the final composite type. We can not use this struct as a type in its own right, i.e., we can use it as a return type to a function, as a type for declaring a variable, we can take pointers to it, etc.

One other thing we should add to this struct definition is the `typedef` keyword. This keyword simply allows us to define an alias for an existing type. Without the `typedef` keyword, the official name of our Person type is `struct Person`, meaning we’ll have to type `struct Person` anywhere we’re using it as a type. We can make a small tweak to the definition like so:

        typedef struct Person {
            char *name;
            int age;
            float weight;
        } Person;

Now, the official name for our Person type is just `Person`; we no longer have to prepend the type with `struct`!

### Creating a Stack using Structs

We’ll use structs to create a new type that represents a stack data structure.

        typedef struct Stack {
            int *storage;
            int length;
            int capacity;
        } Stack;

Once we’ve defined our Stack type, we’ll need to write a function that actually creates an instance of a stack, just like how we would do it in JS or Python. In the case of C, that function might look like this:

        Stack *createStack(int capacity)
        {
            Stack *newStack = malloc(sizeof(Stack));
            newStack->storage = malloc(capacity * sizeof(int));
            newStack->length = 0;
            newStack->capacity = capacity;
            return newStack;
        }

Similarly, we’ll want to write a method to free the memory that we allocated to create our stack. Remember, every time we call `malloc`, we need to call the `free` function in order to free the allocated memory when we’re done with it.

        void destroyStack(Stack *stack)
        {
            free(stack->storage);
            free(stack);
        }

##### Challenge

Finish up the implementation of the Stack data structure we started implementing. It will need a `push` and `pop` method. How might we need to implement these methods if C is not an object oriented language that has support for methods?

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Intro to C

Students’ first C repository that introduces them to important C concepts in a modular fashion by having students complete modules that each focus on a single concept.

[GitHub Repo](https://github.com/LambdaSchool/Intro-to-C-Guided-Demo)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Intro to C](https://github.com/LambdaSchool/Intro-to-C)

  Students’ first C repository that introduces them to important C concepts in a modular fashion by having students complete modules that each focus on a single concept.

  The prescribed order with which you should work on each module is:

  1.  fizzbuzz
  2.  strings
  3.  pointers
  4.  malloc
  5.  structs
  6.  queues
  7.  quicksort

  `cd` into each directory and work on each exercise. Run the included unit tests to ensure that your code works as expected. Once you’ve gotten all of the unit tests passing for the given directory, move on to the next one.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[Intro to C Day Two for WEB15 w/Jonathan Brunt](https://youtu.be/dboY-mb6GYc)**

  Second day of intro to C. Pointer review, memory management, and data structures

- [All previous recordings](/archive/CSAnnex/module/recLymrrD7f46rdBa)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Write a function called `intsqrt` that accepts an `int` as an argument, computes the square root of the argument, and returns the result as a `double`.

  Use Google-fu to help find the answer.

- Objective challenge:

  Take a look at the following code. At each line, write down what each variable is referring to (i.e. is it referring to a value, or an address?).

          int x = 1, y = 2, z[10];
          int *ip;

          ip = &x;         // What is ip here?
          y = *ip;          // What is y here?
          *ip = 0;          // What is ip here now? What is x now?
          ip = &z[0];    // What is ip now?

- Objective challenge:

  1.  Write a C function `matrix_alloc` that receives two integer parameters `cols` and `rows` and have your function allocate a two-dimensional array of integers. Here, the parameter `cols` specifies the number of columns of the allocated matrix, and `rows` represents the number of rows. What will be the return type of this function?

  2.  Write a function `matrix_free` that receives a matrix created by `matrix_alloc` and frees it.

- Objective challenge:

  Finish up the implementation of the Stack data structure we started implementing. It will need a `push` and `pop` method. How might we need to implement these methods if C is not an object oriented language that has support for methods?

- Guided Project: Intro to C

- Project: Intro to C
