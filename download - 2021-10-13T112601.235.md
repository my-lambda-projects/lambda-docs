Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

-   [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

-   [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
-   [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

-   [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
-   [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
-   [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

-   [REST](/csannex/module/rec7YHjLuXabdlhof/)
-   [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
-   [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

-   [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
-   [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

-   [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

-   [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
-   [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
-   [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
-   [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
-   [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
-   [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
-   [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science Annex

<a href="/csannex/sprint/recMPt6jmsCgaqrfj" class="bd-toc-link">1.  Data Structures: Heaps</a>

-   [Heaps](/csannex/module/recNbOiLfM7bfQ0aE/)

<a href="/csannex/sprint/recKzV5STy8vYnbQ1" class="bd-toc-link">2.  Intro to Django</a>

-   [Django basics and setup](/csannex/module/recvCvXoZKm5cYOc4/)
-   [Building APIs](/csannex/module/recuEEEsf9eXphxy0/)

<a href="/csannex/sprint/recUHGX7arXkBIutr" class="bd-toc-link">3.  Python/Django I</a>

-   [Getting started with Python and Django](/csannex/module/rec4yg0hRHaeOmBGN/)
-   [Object-Oriented Programming](/csannex/module/recHhVqI4Y3j6UgLa/)
-   [Software Design Patterns](/csannex/module/recgVHqW0RShuQn1Z/)

<a href="/csannex/sprint/rec64nbdwB28JM7Qu" class="bd-toc-link">4.  Python/Django II/Career Development</a>

-   [REST](/csannex/module/rec7YHjLuXabdlhof/)
-   [GraphQL](/csannex/module/recjIPIwz5Pn5WbPh/)
-   [Model-View-Controller](/csannex/module/recVsikSMFoQ25WZd/)

<a href="/csannex/sprint/reczMSFEG5pffpADx" class="bd-toc-link">5.  Python/Django III/Career Development</a>

-   [Object-relational mapping](/csannex/module/reccrn1If8mhlIymc/)
-   [Relational Databases](/csannex/module/recU6Q1DLISGvt0dk/)

<a href="/csannex/sprint/recTTpwFpgZXtPG2o" class="bd-toc-link">6.  Project Week: Cellular Automata</a>

-   [Game of Life](/csannex/module/rec42j1bkTmC0Hsro/)

<a href="/csannex/sprint/recqkHjNcXzK5DTqd" class="bd-toc-link">7.  C Programming Topics</a>

-   [Introduction To C](/csannex/module/recLymrrD7f46rdBa/)
-   [Processes and System Calls](/csannex/module/rec7YmMV7ukDLK770/)
-   [Scheduling](/csannex/module/recfiYtQDLFXGOBFA/)
-   [Operating Systems](/csannex/module/recHPT5QiPS6NOCgz/)
-   [Web Server I](/csannex/module/recz76g3pcHs88Dax/)
-   [Web Server II](/csannex/module/recFGnBVmKCyR0427/)
-   [Theory of Computation](/csannex/module/recH0OAnSr6ZcnZ7F/)

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Processes and System Calls

<span class="lead"> </span>

By now, you’ve heard us throwing around the term ‘process’ a number of times, but we haven’t gone and dug into what a process really is. Processes are one of the most fundamental abstractions when it comes to understanding how computers operate.

The question we’ll be trying to answer this sprint is, what happens under the hood of your machine when you execute an arbitrary program.

**At the end of this module, you should be able to:**

-   describe how computers execute programs using the process abstraction
-   describe what system calls are and why they are useful

#### Pro Tip

Before you put something on social media, ask yourself - “Would I be okay if this appeared on the front page of the New York Times?”

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=dGFAmv1SXis), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=PqOzLRdPx1c), or enable JavaScript if it is disabled in your browser.

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe how computers execute programs using the process abstraction

Processes are a fundamental abstraction when it comes to how computers function. Learning about this abstraction and how each program is an instance of an isolated process with its own memory address is important when building up a mental model of how a computer works under the hood.

##### Overview

Let’s think about what is needed from the machine’s perspective in order for a program to be executed. The first thing that is needed is a CPU, or a processor. A processor is the actual piece of hardware that physically executes the instructions of a program that are laid out in code. The second thing the machine needs is some memory in order to persist the state of the program as it is running, as well as keeping track of things like variables, data structures, etc.

To that end, before a processor can begin executing a program, the operating system allocates some memory in the machine’s RAM in order to keep track of that program’s state. This chunk of memory is referred to as an *address space*. All these different pieces that go into executing a program make up the abstraction that we refer to as a *process*. Put another way, a process represents a program that is currently running on your machine, like a browser, Slack, your terminal, etc.

You can actually get a list of all the processes currently running on your machine. If you’re on OSX or Linux, try executing the `top` command to get a glimpse of all the running processes on your machine. If you’re on Windows (though you really shouldn’t be), try executing the `tasklist` command.

The operating system keeps track of all the running processes on a machine in a list, along with crucial pieces of metadata that the operating system needs to know about regarding each executing process. This metadata is stored in a data structure called a *Process Control Block* (often abbreviated as PCB). The actual contents and data that are stored in the process control block aren’t too important for our purposes, but if you’re curious and would like a rundown, you can check out this link: https://www.geeksforgeeks.org/operating-system-process-table-process-control-block-pcb/

In addition the the memory and CPU components we talked about, there is a bunch of metadata that the OS must keep track of with respect to each process, such as a program counter, which represents which instruction of the program the CPU is currently executing, and a stack pointer, which points to the memory region of the process’s stack.

So when the OS chooses a process to execute, it must load all the contextual data associated with that process, along with the program’s code, so that the CPU can start executing the process. However, once a process is chosen to be run by the CPU, it isn’t run all the way through to completion. There are a limited number of CPUs in your computer (however many cores your processor has) and a great many processes that require execution time. Each CPU can only execute a single instruction at any given point of time. So in order to achieve the illusion that your computer is running all of these processes simultaneously, the OS constantly switches processes in and out of being executed by the pool of CPUs, so that the end user sees that every process is making progress and/or responding to user input in a timely fashion.

Thus, an operating system is constantly shuttling through a bunch of processes, picking the one that will next be given execution time on the CPU, loading that process’s code and execution context, handing it off to the CPU for some amount of time, then stopping that process by saving its execution state (a process known as preemption), then picking another process to run on the CPU. Not to mention that the operating system is itself simply another process that requires execution time on the CPU in order to get anything done! Indeed, scheduling processes such that all processes are efficiently shuttled through is one of the operating system’s biggest responsibilities.

##### Follow Along

Walk through the memory layout of an executing C program using the diagram located at this link: https://notes.shichao.io/apue/figure\_7.6.png

##### Challenge

Every process is initialized with three file descriptors by default. Look up what these three file descriptors point to.

------------------------------------------------------------------------

#### Learn to describe what system calls are and why they are useful

System calls are a fundamental part of how programs get executed. Because security is a concern, processes are all isolated by default, each with minimal permissions. To that end, how does a run-of-the-mill process perform privileged operations such as creating a new process, or executing an arbitrary program? The answer is, of course, system calls.

##### Overview

It turns out the OS is a privileged process that needs to be allocated execution time on a CPU itself in order to run. The OS has direct access to hardware resources, and it is tasked with the job of ensuring that other non-privileged processes do not access those resources without the OS’s permission. How does the OS perform this job without compromising performance?

Let’s start off with the simplest premise. We could just give each process complete control of the CPU it is running on when it is allocated execution time. With this model, each process would not be interrupted at all until it either completes its execution, or it voluntarily yields the CPU it is running on. This would maximize overall performance, but at what cost?

Indeed, if we gave each process full reign of the CPU it is executing on, there would be no way to stop said process from accessing some memory that doesn’t belong to it, or ensuring that it yielded the CPU in a timely fashion.

Instead, let’s make a firm distinction between privileged and non-privileged processes. Non-privileged processes, which is most processes, run in what is called *user mode*. User mode processes are restricted in what they can do; they can’t directly issue I/O requests or allocate new blocks of memory. If a non-privileged process attempts to perform an operation it isn’t allowed to, the OS intervenes and termininates the offending process.

Conversely, the OS and other privileged processes run in *kernel mode*, so named because privileged processes have access to the kernel in order to allow them to directly access memory and hardware resources. Processes that run in kernel mode can essentially do whatever they want, including preempt another process that is running on a CPU. This solves the question of how the OS can reclaim control of a processor from a process that isn’t cooperating and yielding the CPU in a timely fashion.

So now the question becomes, how do user mode processes access hardware resources they need? The solution to this is to have the kernel expose certain key pieces of functionality to user mode processes. These pieces of functionality include accessing the file system, creating and destroying processes, allowing a process to communicate with another process, and allocating more dynamic memory.

##### Follow Along

Executing system calls is no different from executing any other procedure call. You’ve been doing it already when using the `malloc` function in order to allocate a program more memory. Additionally, `fork`, `wait`, `exec`, and `pipe` are all system calls. Can you see why?

Of course, doing it this way isn’t as performant compared to if we simply gave each process full reign over its CPU. Making a system call takes more time than a regular procedure call, since when a system call is made, the OS actually intervenes on behalf of the calling process, allocates the requested resources on behalf of the calling process, and then returns the newly-allocated resources to the calling process. Another way to think about it is that two border crossings need to be made from user mode into kernel mode, and then from kernel mode back into user mode. One of the exercises you’ll be working on will have you time how long it takes on average for a system call to complete.

##### Challenge

Look up the following system calls to figure out what they do:

1.  `msgctl`
2.  `nice`
3.  `semctl`
4.  `brk`
5.  `fstat`

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Intro to C (Processes and Syscalls)

The operating system is the interface between the user programs and the hardware that runs it. The OS abstracts away all the hardware details so that we don’t have to worry about them. Additionally, it manages users, processes, file storage, memory management, and many other tasks that user-space processes rely on.

In this project, we’ll learn to talk directly to the OS from our C programs and ask it to perform tasks on our behalf.

[GitHub Repo](https://github.com/LambdaSchool/Processes-Guided-Demo)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Processes and System Calls](https://github.com/LambdaSchool/Processes/)

    A bunch of simple exercises to get students working with the process API.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Processes Day Two for WEB15 w/Jonathan Brunt](https://youtu.be/rPTYj3GIzdg)**

    Processes Day Two: Pipes and OS Process States

-   [All previous recordings](/archive/CSAnnex/module/rec7YmMV7ukDLK770)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    Every process is initialized with three file descriptors by default. Look up what these three file descriptors point to.

-   Objective challenge:

    Look up the following system calls to figure out what they do:

    1.  `msgctl`
    2.  `nice`
    3.  `semctl`
    4.  `brk`
    5.  `fstat`

-   Guided Project: Intro to C (Processes and Syscalls)

-   Project: Processes and System Calls
