

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Web API: Node

<a href="/web4node/sprint/reckzQd7ZgiFY5ok5" class="bd-toc-link">1.  Build a Web API</a>

-   [Introduction to Node.js and Express](/web4node/module/recZiPP8Oyg1WlHxT/)
-   [Server-Side Routing with Express](/web4node/module/recBjiSulq0PYLCIj/)
-   [Express Middleware](/web4node/module/recCJjYFEz0i5O5p5/)
-   [Web Deployment and Best Practices](/web4node/module/recs9QOkOAtZhsjc4/)

<a href="/web4node/sprint/receFLR7MpwQXesIN" class="bd-toc-link">2.  Adding Data Persistence</a>

-   [Introduction to Relational Databases](/web4node/module/recFG7SqlSCAB8iU7/)
-   [Database Schema Design](/web4node/module/recIbfNn9xRhLTOv4/)
-   [Multi-Table Queries](/web4node/module/recw2ezN22yjehidj/)
-   [Data Modeling](/web4node/module/rec5J23yAIdjmFbgP/)

<a href="/web4node/sprint/recGqGeZ7n75vZivn" class="bd-toc-link">3.  Authentication and Testing</a>

-   [Introduction to Authentication](/web4node/module/recQD9lnhqWEFh6g4/)
-   [Using JSON Web Tokens (JWT)](/web4node/module/reciCHdNjavSKaaLt/)
-   [WEB Unit Testing](/web4node/module/recd26oZ3GBNHh3Na/)
-   [Testing the Back End](/web4node/module/reciXdxRA8zXJXDID/)

<a href="/web4node/sprint/recWkcWui91eG1s8q" class="bd-toc-link">4.  WEB Unit 4 Node Build</a>

-   [Prepare](#prepare)
-   [Learn](#learn)
-   [Guided Project](#guided-project)
-   [Project](#project)
-   [Review](#review)

# Data Modeling

<span class="lead"> </span>

A data model is an abstraction of the information a system needs to fulfill it’s purpose.

When designing a data model we go from high level Entities to low level database schemas. The lower we get the more detailed the model needs to be. We’ll work at the physical database design level in order to learn how to create database objects, but always working towards the high level entities.

On this lecture we we’ll cover:

-   Normalizing the model.
-   One to many relationships.
-   Many to many relationships.
-   One to one relationships.
-   Creating multi table schemas in knex

**At the end of this module, you should be able to:**

-   explain data normalization
-   explain different table relationships
-   create table relationships using Knex

#### Pro Tip

Life is a marathon, not a sprint.

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=TUsoTNch95w), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=-Bau_Ed18Og), or enable JavaScript if it is disabled in your browser.

-   

    # An error occurred.

    [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=9kP0CVOwP_Y), or enable JavaScript if it is disabled in your browser.

-   [Database Normalization Explained in Simple English](https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/)

-   [one to one relationships](https://gerardnico.com/data/modeling/one-to-one)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to explain data normalization

The relational database model is different from the object model we use in our JavaScript code. In JavaScript we can add arrays or nested objects to our entities. A client can have multiple address embedded as an array. But that same relationship in a relational model could result in data repetition and other *anomalies*.

In this section we’ll learn the basic principles of `data normalization` and how to recognize a denormalized table.

##### Overview

`Normalization` is the process of designing or refactoring database tables for maximum consistency and minimum redundancy.

With objects, we’re used to *denormalized* data, stored with ease of use and speed in mind. Non-normalized tables are considered ineffective in relational databases.

##### Follow Along

**Data normalization** is a deep topic in database design. To begin thinking about it, we’ll explore a few basic guidelines and some data examples that violate these rules.

### Normalization Guidelines

-   Each record has a primary key.
-   No fields are repeated.
-   All fields relate directly to the key data.
-   Each field entry contains a single data point.
-   There are no redundant entries.

### Denormalized Data

<table><thead><tr class="header"><th>farm_name</th><th>animal1</th><th>animal2</th><th>animal3</th></tr></thead><tbody><tr class="odd"><td>Beech Ranch</td><td>pigs</td><td>chickens</td><td>goats</td></tr><tr class="even"><td>Morton Farms</td><td>horses</td><td>chickens</td><td>cows</td></tr></tbody></table>

This table has two issues. There is no proper id field (as multiple farms may have the same name), and multiple fields are representing the same type of data: animals.

<table><thead><tr class="header"><th>farm_id</th><th>farm_name</th><th>animals</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Beech Ranch</td><td>pigs, chickens, goats</td></tr><tr class="even"><td>2</td><td>Morton Farms</td><td>horses, chickens, cows</td></tr></tbody></table>

While we have now eliminated the first two issues, we now have multiple entries in one field, separated by commas. This isn’t good either, as its another example of denormalization. There is no “array” data type in a relational database, so each field must contain only one data point.

<table><thead><tr class="header"><th>animal_id</th><th>animal</th><th>farm_name</th><th>ann_revenue</th></tr></thead><tbody><tr class="odd"><td>1</td><td>pig</td><td>Beech Ranch</td><td>65000</td></tr><tr class="even"><td>2</td><td>chicken</td><td>Beech Ranch</td><td>65000</td></tr><tr class="odd"><td>3</td><td>goat</td><td>Beech Ranch</td><td>65000</td></tr></tbody></table>

Now we’ve solved the multiple fields issue, but we created repeating data (the farm field), which is also an example of denormalization. As well, we can see that if we were tracking additional ranch information (such as annual revenue), that field is only vaguely related to the animal information.

**When these issues begin arising in your schema design, it means that you should separate information into two or more tables.**

### Anomalies

Obeying the above guidelines prevent **anomalies** in your database when inserting, updating, or deleting. For example, imagine if the revenue of Beech Ranch changed. With our denormalized schema, it may get updated in some records but not others:

<table><thead><tr class="header"><th>animal_id</th><th>animal</th><th>farm_name</th><th>ann_revenue</th></tr></thead><tbody><tr class="odd"><td>1</td><td>pig</td><td>Beech Ranch</td><td>45000</td></tr><tr class="even"><td>2</td><td>chicken</td><td>Beech Ranch</td><td>65000</td></tr><tr class="odd"><td>3</td><td>goat</td><td>Beech Ranch</td><td>65000</td></tr></tbody></table>

Similarly, if Beech Ranch shut down, there would be three (if not more) records that needed to be deleted to remove a single farm.

Thus a denormalized table opens the door for contradictory, confusing, and unusable data.

##### Challenge

What issues does the following table have?

<table><thead><tr class="header"><th>name</th><th>city</th><th style="text-align: center;">state</th><th>powers</th></tr></thead><tbody><tr class="odd"><td>John Doe</td><td>Miami</td><td style="text-align: center;">FL</td><td>none</td></tr><tr class="even"><td>Jane Doe</td><td>Miami</td><td style="text-align: center;">FL</td><td>none</td></tr><tr class="odd"><td>Frank Castle</td><td>New York</td><td style="text-align: center;">NY</td><td>kidnapping, extortion</td></tr><tr class="even"><td>Tony Stark</td><td>New York</td><td style="text-align: center;">NY</td><td>wealth</td></tr><tr class="odd"><td>Peter Parker</td><td>New York</td><td style="text-align: center;">NY</td><td>spider-sense, webbing</td></tr></tbody></table>

##### Dig Deeper

-   [Database Normalization (Wikipedia)](https://en.wikipedia.org/wiki/Database_normalization)  
    Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity.
-   [Description of the database normalization basics](https://support.microsoft.com/en-us/help/283878/description-of-the-database-normalization-basics)  

------------------------------------------------------------------------

#### Learn to explain different table relationships

When modeling the data for our systems we’ll start noticing the relationships that exist between our entities. Those relationships need to be added to our resulting model.

The way we model the relationship between our entities will influence how easy (or difficult) querying data will be.

##### Overview

There are three types of relationships:

-   One to one.
-   One to many.
-   Many to many.

Determining how data is related can provide a set of guidelines for table representation and guides the use of foreign keys to connect said tables.

##### Follow Along

### One to One Relationships

Imagine we are storing the financial projections for a series of farms.

We may wish to attach fields like farm name, address, description, projected revenue, and projected expenses. We could divide these fields into two categories: information related to the farm directly (name, address, description) and information related to the financial projections (revenue, expenses).

We would say that `farms` and `projections` have a **one-to-one** relationship. This is to say that every farm has exactly one projection, and every project corresponds to exactly one farm.

This data can be represented in two tables: `farms` and `projections`

<table><thead><tr class="header"><th>id</th><th>farm_name</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Beech Ranch</td></tr><tr class="even"><td>2</td><td>Morton Farms</td></tr></tbody></table>

<table><thead><tr class="header"><th>id</th><th>farm_id</th><th>revenue</th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>65000</td></tr><tr class="even"><td>2</td><td>2</td><td>105000</td></tr></tbody></table>

The `farm_id` is the foreign key that links `farms` and `projections` together.

Notes about one-to-one relationships:

-   The foreign key should always have a `unique` constraint to prevent duplicate entries. In the example above, we wouldn’t want to allow multiple projections records for one farm.
-   The foreign key can be in either table. For example, we may have had a `projection_id` in the `farms` table instead. A good rule of thumb is to put the foreign key in whichever table is more auxiliary to the other.
-   You can represent one-to-one data in a single table *without* creating anomalies. However, it is sometimes prudent to use two tables as shown above to keep separate concerns in separate tables.

### One to Many Relationships

Now imagine, we are storing the full-time ranchers employed at each farm. In this case, each rancher would only work at one farm however, each farm may have multiple ranchers.

This is called a **one-to-many** relationship.

This is the most common type of relationship between entities. Some other examples:

-   One `customer` can have many `orders`.
-   One `user` can have many `posts`.
-   One `post` can have many `comments`.

Manage this type of relationship by adding a foreign key on the “many” table of the relationship that points to the primary key on the “one” table. Consider the `farms` and `ranchers` tables.

<table><thead><tr class="header"><th>id</th><th>farm_name</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Beech Ranch</td></tr><tr class="even"><td>2</td><td>Morton Farms</td></tr></tbody></table>

<table><thead><tr class="header"><th>id</th><th>rancher_name</th><th>farm_id</th></tr></thead><tbody><tr class="odd"><td>1</td><td>John Doe</td><td>1</td></tr><tr class="even"><td>2</td><td>Jane Doe</td><td>1</td></tr><tr class="odd"><td>3</td><td>Jim Done</td><td>2</td></tr><tr class="even"><td>4</td><td>Jay Dow</td><td>2</td></tr><tr class="odd"><td>5</td><td>Jen Dunn</td><td>1</td></tr></tbody></table>

In a many-to-many relationship, the foreign key (in this case `farm_id`) should *not* be unique.

### Many to Many Relationships

If we want to track animals on a farm as well, we must explore the **many-to-many** relationship. A farm has multiple animals, and multiple of each type of animal is present at multiple different farms.

Some other examples:

-   an `order` can have many `products` and the same `product` will appear in many `orders`.
-   a `book` can have more than one `author`, and an `author` can write more than one `book`.

To model this relationship, we need to introduce an **intermediary table** that holds foreign keys that reference the primary key on the related tables. We now have a `farms`, `animals`, and `farm_animals` table.

<table><thead><tr class="header"><th>id</th><th>farm_name</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Beech Ranch</td></tr><tr class="even"><td>2</td><td>Morton Farms</td></tr></tbody></table>

<table><thead><tr class="header"><th>id</th><th>animal</th></tr></thead><tbody><tr class="odd"><td>1</td><td>pig</td></tr><tr class="even"><td>2</td><td>chicken</td></tr><tr class="odd"><td>3</td><td>goat</td></tr></tbody></table>

<table><thead><tr class="header"><th>farm_id</th><th>animal_id</th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td></tr><tr class="even"><td>1</td><td>2</td></tr><tr class="odd"><td>1</td><td>3</td></tr><tr class="even"><td>2</td><td>2</td></tr></tbody></table>

While each foreign key on the intermediary table is not unique, the combinations of keys should be unique.

##### Challenge

Model the relationship for addresses where:

-   an address has the street address, the city, state and zip code.
-   a state can have several cities.
-   a city belongs to only one state.

##### Dig Deeper

-   [many to many relationships](https://gerardnico.com/data/modeling/many-to-many)  
-   [one to many relationships](https://gerardnico.com/data/modeling/one-to-many)  

------------------------------------------------------------------------

#### Learn to create table relationships using Knex

To put our data modeling skills to practical use, we need to be able to build a multi table schema using knex.

##### Overview

The Knex query builder library also allows us to create multi-table schemas include foreign keys. However, there are a few extra things to keep in mind when designing a multi-table schema, such as using the correct order when creating tables, dropping tables, seeding data, and removing data.

We have to consider the way that `delete` and `updates` through our API will impact related data.

##### Follow Along

### Foreign Key Setup

In Knex, foreign key restrictions don’t automatically work. Whenever using foreign keys in your schema, add the following code to your `knexfile`. This will prevent users from entering bad data into a foreign key column.

    development: {
      client: 'sqlite3',
      useNullAsDefault: true, 
      connection: {
        filename: './data/database.db3',
      },
      // needed when using foreign keys
      pool: {
        afterCreate: (conn, done) => {
          // runs after a connection is made to the sqlite engine
          conn.run('PRAGMA foreign_keys = ON', done); // turn on FK enforcement
        },
      },
    },

### Migrations

Let’s look at how we might track our `farms` and `ranchers` using Knex. In our migration file’s `up` function, we would want to create two tables:

    exports.up = function(knex, Promise) {
      return knex.schema
        .createTable('farms', tbl => {
          tbl.increments();
          tbl.string('farm_name', 128)
            .notNullable();
        })
        // we can chain together createTable
        .createTable('ranchers', tbl => {
          tbl.increments();
          tbl.string('rancher_name', 128);
          tbl.integer('farm_id')
            // forces integer to be positive
            .unsigned()
            .notNullable()
            .references('id')
            // this table must exist already
            .inTable('farms')
        })
    };

Note that the foreign key can only be created *after* the reference table.

In the down function, the opposite is true. We always want to drop a table with a foreign key *before* dropping the table it references.

    exports.down = function(knex, Promise) {
      // drop in the opposite order
      return knex.schema
        .dropTableIfExists('ranchers')
        .dropTableIfExists('farms')
    };

In the case of a many-to-many relationship, the syntax for creating an intermediary table is identical, except for one additional piece. We need a way to make sure our combination of foreign keys is unique.

    .createTable('farm_animals', tbl => {
      tbl.integer('farm_id')
        .unsigned()
        .notNullable()
        .references('id')
        // this table must exist already
        .inTable('farms')
      tbl.integer('animal_id')
        .unsigned()
        .notNullable()
        .references('id')
        // this table must exist already
        .inTable('animals')

      // the combination of the two keys becomes our primary key
      // will enforce unique combinations of ids
      tbl.primary(['farm_id', 'animal_id']);
    });

### Seeds

Order is also a concern when seeding. We want to create seeds in the **same** order we created our tables. In other words, don’t create a seed with a foreign key, until that reference record exists.

In our example, make sure to write the `01-farms` seed file and then the `02-ranchers` seed file.

However, we run into a problem with truncating our seeds, because we want to truncate `02-ranchers` *before* `01-farms`. A library called `knex-cleaner` provides an easy solution for us.

Run `knex seed:make 00-cleanup` and `npm install knex-cleaner`. Inside the cleanup seed, use the following code.

    const cleaner = require('knex-cleaner');

    exports.seed = function(knex) {
      return cleaner.clean(knex, {
        mode: 'truncate', // resets ids
        ignoreTables: ['knex_migrations', 'knex_migrations_lock'], // don't empty migration tables
      });
    };

This removes all tables (excluding the two tables that track migrations) in the correct order before any seed files run.

### Cascading

If a user attempt to delete a record that is referenced by another record (such as attempting to delete `Morton Ranch` when entries in our `ranchers` table reference that record), by default, the database will block the action. The same thing can happen when updating a record when a foreign key reference.

If we want that to override this default, we can delete or update with **cascade**. With cascade, deleting a record also deletes all referencing records, we can set that up in our schema.

    .createTable('ranchers', tbl => {
        tbl.increments();
        tbl.string('rancher_name', 128);
        tbl.integer('farm_id')
        .unsigned()
        .notNullable()
        .references('id')
        .inTable('farms')
        .onUpdate('CASCADE');
        .onDelete('CASCADE')
    })

##### Challenge

Write the migration file to create a table to track users and posts.

------------------------------------------------------------------------

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Node DB 4 Guided Project

[GitHub Repo](https://github.com/LambdaSchool/node-db4-guided)

------------------------------------------------------------------------

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

-   ##### [Node DB4 Challenge](https://github.com/LambdaSchool/node-db4-challenge)

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

-   **[Data Modeling for Web PT 18 w/Jason Maurer](https://youtu.be/DNCEdN3P2Rg)**

    A data model is an abstraction of the information a system needs to fulfill it’s purpose. When designing a data model we go from high level Entities to low level database schemas. The lower we get the more detailed the model needs to be. We’ll work at the physical database design level in order to learn how to create database objects, but always working towards the high level entities. On this lecture we we’ll cover: Normalizing the model. One to many relationships. Many to many relationships. One to one relationships. Creating multi table schemas in knex At the end of this module, you should be able to: explain data normalization explain different table relationships create table relationships using Knex

-   [All previous recordings](/archive/FSW/module/rec5J23yAIdjmFbgP)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

-   Objective challenge:

    What issues does the following table have?

    <table><thead><tr class="header"><th>name</th><th>city</th><th style="text-align: center;">state</th><th>powers</th></tr></thead><tbody><tr class="odd"><td>John Doe</td><td>Miami</td><td style="text-align: center;">FL</td><td>none</td></tr><tr class="even"><td>Jane Doe</td><td>Miami</td><td style="text-align: center;">FL</td><td>none</td></tr><tr class="odd"><td>Frank Castle</td><td>New York</td><td style="text-align: center;">NY</td><td>kidnapping, extortion</td></tr><tr class="even"><td>Tony Stark</td><td>New York</td><td style="text-align: center;">NY</td><td>wealth</td></tr><tr class="odd"><td>Peter Parker</td><td>New York</td><td style="text-align: center;">NY</td><td>spider-sense, webbing</td></tr></tbody></table>

-   Objective challenge:

    Model the relationship for addresses where:

    -   an address has the street address, the city, state and zip code.
    -   a state can have several cities.
    -   a city belongs to only one state.

-   Objective challenge:

    Write the migration file to create a table to track users and posts.

-   Guided Project: Node DB 4 Guided Project

-   Project: Node DB4 Challenge
