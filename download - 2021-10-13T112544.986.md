Please enable JavaScript to view this page.

You must be logged in to view this page.

You must be a Lambda School student to view this page.

<a href="#content" id="skippy" class="sr-only sr-only-focusable"></a>

<span class="skiplink-text">Skip to main content</span>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMyIgaGVpZ2h0PSIzNSIgdmlld2JveD0iMCAwIDMzIDM1IiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wIDBWMTYuMDYwOUMwIDI3LjczMzUgOS4wODkyOSAzMS43ODQzIDE1LjczMjEgMzQuNzUxM0gxNS43NUwxNi4yODU3IDM1QzE2LjQxMDcgMzQuOTI4OSAxNi41MzU3IDM0Ljg3NTYgMTYuNjc4NiAzNC44MjIzQzE2Ljc1IDM0Ljc4NjggMTYuODM5MyAzNC43NTEzIDE2LjkxMDcgMzQuNzE1N0MyMy41NzE0IDMxLjc2NjUgMzIuNjk2NCAyNy42OTggMzIuNjk2NCAxNi4wNjA5VjBIMFpNMjAuNzA3MSAyMy40NTM2TDIwLjM1NzEgMjIuNTEwMkwxNS42MDcxIDEwLjA3MzZDMTUuMzIxNCAxMC44MDIgMTQuNjYwNyAxMi41NjA5IDEzLjk0NjQgMTQuNDQ0MkwxMS4yMTQzIDIxLjc4MTdDMTEuMDg5MyAyMi4xMzcxIDExLjE2MDcgMjIuMzE0NyAxMS4yNSAyMi40MzkxQzExLjQ0NjQgMjIuNjcwMSAxMS44NzY4IDIyLjY3MDEgMTIuNTU1NCAyMi42NzAxSDEyLjY3ODZMMTIuNjc2OCAyMy40NTE4SDcuNTY5NjRWMjIuNjcwMUg3Ljk2MjVDOC42NTg5MyAyMi42NzAxIDkuMjMwMzYgMjIuMzY4IDkuNjU4OTMgMjEuNTE1MkwxMC4xNzY4IDIwLjM0MjZMMTQuOTA4OSA4LjI5Njk2TDE0LjA2OTYgNi4wNzYxNEgxOC40ODA0TDI0LjU2OTYgMjIuMDEyN0wyNS4xMjUgMjMuNDUzNkgyMC43MDcxWiIgZmlsbD0iI0VDMzk0NCI+PC9wYXRoPgo8L3N2Zz4=" /></a>

![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAzMCAzMCIgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmb2N1c2FibGU9ImZhbHNlIj48dGl0bGU+TWVudTwvdGl0bGU+PHBhdGggc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNCA3aDIyTTQgMTVoMjJNNCAyM2gyMiI+PC9wYXRoPjwvc3ZnPg==)

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

<a href="/" class="navbar-brand"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM1IiBoZWlnaHQ9IjM1IiB2aWV3Ym94PSIwIDAgNzU2IDE5NyIgZmlsbD0iI2VjMzk0NCI+PGc+PHBhdGggZD0iTTI5Mi45LDEyNi42aC02LjdjLTksMC0xMi42LTEuOS0xMi42LTkuNVY0OC41YzAtNy43LDEuNi04LjYsMTEuNC05Ljd2LTQuNWgtNDEuM3Y0LjUgYzkuOCwxLjEsMTEuNCwxLjksMTEuNCw5Ljd2NjkuM2MwLDcuNy0xLjYsOC42LTExLjQsOS43djQuNWg3My43bDQuOS0yOS40aC00LjRDMzA4LjUsMTE5LjYsMzAzLjksMTI2LjYsMjkyLjksMTI2LjZ6Ij48L3BhdGg+PHBhdGggZD0iTTM4NS41LDEyMS4xVjc5LjNjMC0xNS44LTkuNC0yMi40LTI2LjYtMjIuNGMtMTUsMC0yNi44LDYuNi0yNi44LDE5LjNjMCwyLjQsMC4yLDMuMywwLjgsNWgxNi42IGMtMC41LTItMC43LTUtMC43LTcuNWMwLTkuNiwzLjYtMTIuNCw5LjQtMTIuNGM2LjQsMCw5LjcsMiw5LjcsMTQuNHYxMS4ybC0yMC44LDcuN2MtMTAuNiw0LjEtMTkuMyw4LjgtMTkuMywyMC43IGMwLDEwLjksNy41LDE3LjgsMTguNiwxNy44YzkuOSwwLDE3LjQtNi4yLDIxLjktMTIuMWwwLjEtMC4xbDAsMFYxMzJoMjZ2LTQuNEMzODcuNywxMjcuMSwzODUuNSwxMjYuMiwzODUuNSwxMjEuMXogTTM2OCwxMTcuOCBjLTQuNCwzLjMtNy42LDUuMy0xMiw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNFYxMTcuOEwzNjgsMTE3Ljh6Ij48L3BhdGg+PHBhdGggZD0iTTUxNC40LDEyMVY3OS41YzAtMTQuOC02LTIyLjQtMTguNy0yMi40Yy0xMS41LDAtMTkuNCw2LjYtMjUuNSwxMy45Yy0xLjgtOS42LTcuNy0xMy45LTE3LjgtMTMuOSBjLTExLjQsMC0xOC43LDYuMi0yNC44LDEzLjZWNTdoLTIuM2wtMjMuOCw3LjR2Mi40bDguNiw1djQ5LjRjMCw1LTIuMSw2LjEtOC45LDYuNHY0LjRoMzUuMXYtNC40Yy02LjctMC4zLTguNy0xLjMtOC43LTYuNHYtNDcgYzQuNy0zLjYsOS41LTYuNSwxNS41LTYuNWM3LjYsMCwxMC41LDQuMiwxMC41LDEyLjd2NDAuOGMwLDUtMS45LDYuMS04LjcsNi40djQuNGwzNC44LDB2LTQuNGMtNi43LTAuMy04LjYtMS4zLTguNi02LjR2LTQ3IGM0LjctMy42LDkuNS02LjUsMTUuNS02LjVjNy42LDAsMTAuNSw0LjIsMTAuNSwxMi43bC0wLjEsNDAuNWMwLDUtMS44LDYuNC04LjYsNi43bDAsNC40aDM1LjF2LTQuNCBDNTE2LjcsMTI3LjQsNTE0LjQsMTI2LjEsNTE0LjQsMTIxeiI+PC9wYXRoPjxwYXRoIGQ9Ik01NzMuMiw1Ny4zYy0xMSwwLTE4LjUsNS43LTIzLjQsMTIuOFYyMi45aC0yLjdsLTIzLjQsNi44djIuNWw4LjYsNC41VjEzMmgyLjlsOC0zLjVjNS44LDMuMywxMi4zLDUsMjAuMiw1IGMyMC44LDAsMzcuNC0xNS44LDM3LjQtNDIuNkM2MDAuOSw2OS45LDU5MC40LDU3LjMsNTczLjIsNTcuM3ogTTU2My40LDEyOC43Yy01LjQsMC0xMC4zLTIuNC0xMy43LTcuOVY3My42IGMzLjQtMy40LDguNS01LjcsMTMuNS01LjdjMTMuOSwwLDIwLDEyLjgsMjAsMjkuNUM1ODMuMywxMTQuNyw1NzUuOCwxMjguNSw1NjMuNCwxMjguN3oiPjwvcGF0aD48cGF0aCBkPSJNNjc3LDEyMS4yVjIyLjhoLTIuNkw2NTEsMjkuNlYzMmw4LjYsNC41djI1LjdjLTMuNC0zLjItOC44LTUuMS0xNS41LTUuMWMtMTkuOSwwLTM1LjIsMTUuMy0zNS4yLDQxLjMgYzAsMjAuNywxMS4yLDM0LjYsMjguMSwzNC42YzkuOCwwLDE3LTUuMywyMi42LTEzLjF2MC45VjEzMmgyNi4zbDAtNC40QzY3OS4xLDEyNy4zLDY3NywxMjYuMyw2NzcsMTIxLjJ6IE02NTkuNiwxMTcuMSBMNjU5LjYsMTE3LjFjLTMuNCwzLjQtOCw1LjEtMTMuMiw1LjFjLTEzLjIsMC0yMC40LTEyLjgtMjAuNC0yOS44YzAtMTcuOCw3LjMtMjkuMiwxOS41LTI5LjJjOC43LDAsMTQuMSw2LjksMTQuMSwxOC4zIEw2NTkuNiwxMTcuMXoiPjwvcGF0aD48cGF0aCBkPSJNNzQ3LjEsMTIxLjFWNzkuM2MwLTE1LjgtOS40LTIyLjQtMjYuNi0yMi40Yy0xNSwwLTI2LjgsNi42LTI2LjgsMTkuM2MwLDIuNCwwLjIsMy4zLDAuOCw1aDE2LjYgYy0wLjUtMi0wLjctNS0wLjctNy41YzAtOS42LDMuNi0xMi40LDkuNC0xMi40YzYuNCwwLDkuNywyLDkuNywxNC40djExLjJsLTIwLjgsNy43Yy0xMC42LDQuMS0xOS4zLDguOC0xOS4zLDIwLjcgYzAsMTAuOSw3LjUsMTcuOCwxOC42LDE3LjhjOS45LDAsMTcuNC02LjIsMjEuOS0xMi4xdi0wLjFoMC4xbDAsMTEuMWwyNiwwLjF2LTQuNUM3NDkuMywxMjcuMSw3NDcuMSwxMjYuMiw3NDcuMSwxMjEuMXogTTcyOS42LDExNy44Yy00LjQsMy4zLTcuNiw1LjMtMTIuMSw1LjRjLTcuNywwLTExLjItNS4yLTExLjItMTIuNmMwLTcuNywzLjYtMTEuMiw5LjgtMTMuNWwxMy40LTUuNEw3MjkuNiwxMTcuOEw3MjkuNiwxMTcuOHoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMHY5MC40YzAsNjUuNyw1MC45LDg4LjUsODguMSwxMDUuMmgwLjFsMywxLjRjMC43LTAuNCwxLjQtMC43LDIuMi0xYzAuNC0wLjIsMC45LTAuNCwxLjMtMC42IGMzNy4zLTE2LjYsODguNC0zOS41LDg4LjQtMTA1VjBIMHogTTExNiwxMzJsLTItNS4zbC0yNi42LTcwYy0xLjYsNC4xLTUuMywxNC05LjMsMjQuNmwtMTUuMyw0MS4zYy0wLjcsMi0wLjMsMywwLjIsMy43IGMxLjEsMS4zLDMuNSwxLjMsNy4zLDEuM0g3MWwwLDQuNEg0Mi40bDAtNC40aDIuMmMzLjksMCw3LjEtMS43LDkuNS02LjVsMi45LTYuNmwyNi41LTY3LjhsLTQuNy0xMi41aDI0LjdsMzQuMSw4OS43bDMuMSw4LjFIMTE2eiI+PC9wYXRoPjwvc3ZnPg==" /></a>

#### Computer Science Legacy

<a href="/cs/sprint/recd4D4w3QrigPqUF" class="bd-toc-link">1.  Intro to Python and OOP</a>

- [Introduction to Python I](/cs/module/recay2erzDlYUPSeO/)
- [Introduction to Python II](/cs/module/recwpe3Y9TVWrGT8L/)
- [Introduction to Python III](/cs/module/reca7NYptklr7F403/)
- [Introduction to Python IV](/cs/module/recc3eWphKVYd0oHT/)

<a href="/cs/sprint/recR4gHcvD21ziR9a" class="bd-toc-link">2.  Data Structures</a>

- [Data Structures I](/cs/module/rec3MaMAY78iDm7ax/)
- [Data Structures II](/cs/module/recMcvOrFw5BWUku3/)
- [Data Structures III](/cs/module/recx53S3pYfDfvFDm/)
- [Data Structures IV](/cs/module/recHdwPne4Xt3A7lk/)

<a href="/cs/sprint/recd9grrKlURJ453N" class="bd-toc-link">3.  Algorithms</a>

- [Iterative Sorting](/cs/module/reck76SPX26beGSqE/)
- [Recursive Sorting](/cs/module/reccRh9h6ccXghfA4/)
- [A First-Pass Solution](/cs/module/recrCuZQMVI6LvxhD/)
- [Writing Better Solutions](/cs/module/recsvJCzPlM2X63ZX/)

<a href="/cs/sprint/recvDjRQEq49uoWsU" class="bd-toc-link">4.  CS Unit 1 Build</a>

<a href="/cs/sprint/recAr3gdL8U57eho1" class="bd-toc-link">5.  Hash Tables</a>

- [Hash Tables I](/cs/module/recSwIvbSV630gdVk/)
- [Hash Tables II](/cs/module/recHzCwboKBLBB0Re/)
- [Hash Tables III & IV](/cs/module/recsEDFseukQWg92c/)

<a href="/cs/sprint/rec7U9K7OCL5ihj0t" class="bd-toc-link">6.  Graphs</a>

- [Graphs I](/cs/module/recBMbHtb8AOXq3UL/)
- [Graphs II](/cs/module/recZL2m6Gx7B4dU3G/)
- [Graphs III](/cs/module/reck4RVWsg82eiYPZ/)
- [Graphs IV](/cs/module/recoGWlBHjuJxkL1y/)

<a href="/cs/sprint/recndTnO1V8oDbBPb" class="bd-toc-link">7.  Computer Architecture</a>

- [Computer Architecture: Basics, Number Bases](/cs/module/recsuJbrrFgbFUCRX/)
- [Computer Architecture: Bitwise Operations](/cs/module/rec2NHr4Eyib7XdED/)
- [Computer Architecture: The System Stack](/cs/module/recvQUkzz23NTj20G/)
- [Computer Architecture: Subroutines, CALL/RET](/cs/module/recGPVAdvQcmopSIO/)

<a href="/cs/sprint/reco0t22NdXmr8VyL" class="bd-toc-link">8.  CS Unit 2 Build</a>

- [Prepare](#prepare)
- [Learn](#learn)
- [Guided Project](#guided-project)
- [Project](#project)
- [Review](#review)

# Graphs I

<span class="lead"> </span>

Day 1: Overview and introduction to graphs, graph representations, BFS, DFS

- Project - Implement BFS and DFS, returning a path from the starting node to the end node

**At the end of this module, you should be able to:**

- describe what a graph is, explain its components, provide examples of its useful applications, and draw each of the different graph types
- represent a graph as an adjacency list and an adjacency matrix and compare and contrast the respective representations
- represent a breadth-first-search of a graph in pseudo-code and recall common applications for its use
- represent a depth-first-search of a graph in pseudo-code and recall common applications for its use

#### Pro Tip

Read error messages carefully - computers are always right (from the state they have).

## <a href="#prepare" id="prepare" class="anchor"><span class="octicon octicon-link"></span></a>Prepare

Review each preclass resource before class.

- # An error occurred.

  [Try watching this video on www.youtube.com](https://www.youtube.com/watch?v=Etva3hOjGMU), or enable JavaScript if it is disabled in your browser.

- [Article: A Gentle Introduction to Graph Theory](https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8)

## <a href="#learn" id="learn" class="anchor"><span class="octicon octicon-link"></span></a>Learn

#### Learn to describe what a graph is, explain its components, provide examples of its useful applications, and draw each of the different graph types

We see countless networks in our day-to-day lives. When trying to describe networks or sets of connected objects, computer scientists often use graphs.  A graph is a set of linked data, represented by vertices and edges. The requirements for linking vertices are very lenient. This allows us to use graphs to describe and examine many unique scenarios.

##### Overview

### What Are Graphs

Graphs are collections of related data. They’re like trees, except connections can be made from any node to any other node, even forming loops. By this definition, _all trees are graphs, but not all graphs are trees._

### Components of Graphs

![graph-data-structure.002](https://i.imgur.com/Eb2SkhH.jpg)

We call the nodes in a graph **vertexes** (or **vertices** or **verts**), and we call the connections between the verts **edges**.

An edge denotes a relationship or linkage between the two verts.

### What Graphs Represent

Graphs can represent any kind of multi-way relational data.

A graph could show a collection of cities and their linking roads.

It could show a collection of computers on a network.

It could show a population of people who know each other and [Kevin Bacon](https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon).

It could represent trade relationships between nations.

It could represent the money owed in an ongoing poker night amongst friends.

And so on.

### Types of Graphs

#### Directed and Undirected Graphs

The nature of the relationship that is being represented is what determines if a directed or undirected graph should be used. If the relationship could be described as “one way”, then a directed graph makes the most sense. For example, representing the owing of money to others (debt) with a directed graph would make sense.

![directed-graph.001](https://i.imgur.com/vfwRrDR.jpg)

Directed graphs can also be bidirectional. For example, road maps are directed since all roads are one-way, however most streets consist of roads in both directions.

![bidirectional-directed-graph.001](https://i.imgur.com/m8mA3go.jpg)

If the nature of the relationship is a mutual exchange, then an undirected graph makes the most sense. For example, we could use an undirected graph to represent users who have exchanged money at some point in the past. Since an “exchange” relationship is always mutual, an **undirected** graph makes the most sense here.

![undirected-graph.001](https://i.imgur.com/SJN06wj.jpg)

#### Cyclic and Acyclic Graphs

If you can form a cycle (for example, follow the edges and arrive again at an already-visited vert), the graph is **cyclic**. For example, in the image below, you can start at B and then follow the edges to C, E, D, and then back to B (which you’ve already visited).

![cyclic-graph.001](https://i.imgur.com/XvMDal0.jpg)

_Note: any undirected graph is automatically cyclic since you can always travel back across the same edge._

If you cannot form a cycle (for example, you cannot arrive at an already-visited vert by following the edges), we call the graph **acyclic**. In the example below, no matter which vert you start at, you cannot follow edges in such a way that you can arrive at an already-visited vert.

![acyclic-graph.001](https://i.imgur.com/LXAm7mv.jpg)

#### Weighted Graphs

**Weighted graphs** have values associated with the edges. We call the specific values assigned to each edge **weights**.

![weighted-graph.001](https://i.imgur.com/rjMjqk3.jpg)

The weights represent different data in different graphs. In a graph representing road segments, the weights might represent the length of the road. The higher the total weight of a route on the graph, the longer the trip is. The weights can help decide which particular route we should choose when comparing all routes.

We can further modify weights. For example, if you were building a graph to represent a map for bicycle routes, we could give roads with bad car traffic or very steep inclines unnaturally large weights. That way a routing algorithm would be unlikely to take them. (This is how Google Maps avoids freeways when you ask it for walking directions.)

_Note: [Djikstra’s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) is a graph search variant that accounts for edge weights._

#### Directed Acyclic Graphs (DAGs)

A **directed acyclic graph (DAG)** is a directed graph with no cycles. In other words, we can order a DAG’s vertices linearly in such a way that every edge is directed from earlier to later in the sequence.

![directed-acyclic.001](https://i.imgur.com/nqhM7uz.jpg)

A DAG has several applications. DAGs can modely many different kinds of information. Below is a short list of possible applications:

- A spreadsheet where a vertex represents each cell and an edge for where one cell’s formula uses another cell’s value.
- The milestones and activities of largescale projects where a topological ordering can help optimize the schedule of the projects to use as little time as possible.
- Collections of events and their influence on each other like family trees or version histories.

It is also notable that git uses a DAG to represent commits. A commit can have a child commit, or more than one child commit (in the case of a branch). A child could come from one parent commit, or from two (in the case of a merge). But there’s no way to go back and form a repeating loop in the git commit hierarchy.

##### Follow Along

Before, you draw graphs on your own, let’s draw some graphs together. For each graph, we will have a description.

### Exercise 1

_Draw an undirected graph of 8 verts._

Remember from our definitions above that an undirected graph has edges that are bidirectional. So, we can draw 8 verts and then connect them with solid lines (not arrows) any way we see fit.

![we-do-exercise-1.001](https://i.imgur.com/midD3Xd.jpg)

### Exercise 2

_Draw a directed graph of 7 verts._

A directed graph has at least one edge that is _not_ bidirectional. So, again, we can draw our 7 verts and then connect them with edges. This time, we just need to make sure that one of the edges is an arrow pointing in only one direction.

![we-do-exercise-2.001](https://i.imgur.com/8pCoehA.jpg)

### Exercise 3

_Draw a cyclic directed graph of 5 verts._

This drawing will be similar to one for Exercise 2 because it is a directed graph. However, in this graph we also need to ensure that it has at least one cycle. Remember that a cycle is when you can follow the graph’s edges and arrive at a vertices that you’ve already visited.

To draw this graph, we will draw our five verts, and then draw our edges making sure that we create at least one cycle.

![we-do-exercise-3.001](https://i.imgur.com/JBOurPn.jpg)

### Exercise 4

_Draw a directed acyclic graph (DAG) of 8 verts._

Again, this graph will be directed. The difference is that it will be acyclic—we can order a DAG’s vertices linearly in such a way that every edge is directed from earlier to later in the sequence.

For this graph, we will draw our 8 verts in a line from left to right. Then, we will draw our edges making sure that the edges always point from left to right (earlier to later in the sequence).

![we-do-exercise-4.001](https://i.imgur.com/MNLZooH.jpg)

##### Challenge

Do the following on your own.

Draw one graph for each of the descriptions below:

1.  Undirected graph of 4 verts.
2.  Directed graph of 5 verts.
3.  Cyclic directed graph of 6 verts.
4.  DAG of 7 verts.

---

#### Learn to represent a graph as an adjacency list and an adjacency matrix and compare and contrast the respective representations

##### Overview

### Graph Representations

Two common ways to represent graphs in code are **adjacency lists** and **adjacency matrices**. Both of these options have strengths and weaknesses. When deciding on a graph implementation, it’s important to understand what type of data you will store and what operations you will need to run on the graph.

Below is an example of how we would represent a graph with an adjacency matrix and an adjacency list. Notice how we represent the relationship between verts C and D when using each type.

![graph-representations.001](https://i.imgur.com/siGmq8X.jpg)

#### Adjacency List

In an adjacency list, the graph stores a list of vertices. For each vertex, it stores a list of each connected vertex.

![graph-example.001](https://i.imgur.com/GiStmNh.jpg)

Below is a representation of the graph above in Python:

    class Graph:
        def __init__(self):
            self.vertices = {
                                "A": {"B"},
                                "B": {"C", "D"},
                                "C": {"E"},
                                "D": {"F", "G"},
                                "E": {"C"},
                                "F": {"C"},
                                "G": {"A", "F"}
                            }

Notice that this adjacency _list_ doesn’t use any lists. The `vertices` collection is a `dictionary` which lets us access each collection of edges in O(1) constant time. Because the edges are contained in a `set` we can check for the existence of edges in O(1) constant time.

#### Adjacency Matrix

![graph-example.001](https://i.imgur.com/GiStmNh.jpg)

Here is the representation of the graph above in an adjacency matrix:

    class Graph:
        def __init__(self):
            self.edges = [[0,1,0,0,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,0,0,1,0,0],
                          [0,0,0,0,0,1,1],
                          [0,0,1,0,0,0,0],
                          [0,0,1,0,0,0,0],
                          [1,0,0,0,0,1,0]]

We represent this matrix as a two-dimensional array–a list of lists. With this implementation, we get the benefit of built-in edge weights. `0` denotes no relationship, but any other value that is present represents an edge label or edge weight. The drawback is that we do not have a built-in association between the vertex values and their index.

In practice, implementing both the adjacency list and adjacency matrix would contain more information by including `Vertex` and `Edge` classes.

### Tradeoffs

Adjacency matrices and adjacency lists have strengths and weaknesses. Let’s explore their tradeoffs by comparing their attributes and the efficiency of operations.

In all the following examples, we are using the following shorthand to denote the properties of the graph:

<table><thead><tr class="header"><th style="text-align: center;">Shorthand</th><th style="text-align: left;">Property</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V</td><td style="text-align: left;">Total number of vertices in the graph</td></tr><tr class="even"><td style="text-align: center;">E</td><td style="text-align: left;">Total number of edges in the graph</td></tr><tr class="odd"><td style="text-align: center;">e</td><td style="text-align: left;">Average number of edges per vertex</td></tr></tbody></table>

---

#### Space Complexity

##### Adjacency Matrix

_Complexity_: `O(V^2)` space

Consider a dense graph where each vertex points to each other vertex. Here, the total number of edges will approach V^2. This means that regardless of whether you choose an adjacency list or an adjacency matrix, both will have a comparable space complexity. However, dictionaries and sets are less space efficient than lists. So, for dense graphs (graphs with a high average number of edges per vertex), the adjacency matrix is more efficient because it uses lists instead of dictionaries and sets.

##### Adjacency List

_Complexity_: `O(V+E)` space

Consider a sparse graph with 100 vertices and only one edge. An adjacency list would have to store all 100 vertices but only needs to keep track of that single edge. The adjacency matrix would need to store 100x100=10,000 connections, even though all but one would be 0.

_Takeaway: The worst case storage of an adjacency lists occurs when the graph is dense. In this case, the matrix and list representation have the same complexity (`O(V^2)`). However, for the general case, the list representation is usually more desirable. Also, since finding a vertex’s neighbors is a common task, and adjacency lists make this operation easier, adjacency lists are most often used to represent graphs._

---

#### Add Vertex

##### Adjacency Matrix

_Complexity_: `O(V)` time

For an adjacency matrix, we would need to add a new value to the end of each existing row, then add a new row at the end.

    for v in self.edges:
      self.edges[v].append(0)
    v.append([0] * len(self.edges + 1))

Remember that with Python lists, appending to the end of a list is `O(1)` because of over-allocation of memory but can be `O(n)` when the over-allocated memory fills up. When this occurs, adding the vertex can be `O(V^2)`.

##### Adjacency List

_Complexity_: `O(1)` time

Adding a vertex is simple in an adjacency list:

    self.vertices["H"] = set()

Adding a new key to a dictionary is a constant-time operation.

_Takeaway: Adding vertices is very inefficient for adjacency matrices but very efficient for adjacency lists._

---

#### Remove Vertex

##### Adjacency Matrix

_Complexity_: `O(V^2)`

Removing vertices is inefficient in both representations. In an adjacency matrix, we need to remove the removed vertex’s row, then remove that column from each other row. Removing an element from a list requires moving everything after that element over by one slot which takes an average of V/2 operations. Since we need to do that for every single row in our matrix, that results in a V^2 time complexity. We need to reduce the index of each vertex after our removed index by 1 as well which doesn’t add to our quadratic time complexity, but adds extra operations.

##### Adjacency List

_Complexity_: `O(V)`

For an adjacency list, we need to visit each vertex and remove all edges pointing to our removed vertex. Removing elements from sets and dictionaries is a O(1) operation, so this results in an overall O(V) time complexity.

_Takeaway: Removing vertices is inefficient in both adjacency matrices and lists but more efficient in lists._

---

#### Add Edge

##### Adjacency Matrix

_Complexity_: `O(1)`

Adding an edge in an adjacency matrix is simple:

    self.edges[v1][v2] = 1

##### Adjacency List

_Complexity_: `O(1)`

Adding an edge in an adjacency list is simple:

    self.vertices[v1].add(v2)

Both are constant-time operations.

_Takeaway: Adding edges to both adjacency matrices and lists is very efficient._

---

#### Remove Edge

##### Adjacency Matrix

_Complexity_: `O(1)`

Removing an edge from an adjacency matrix is simple:

    self.edges[v1][v2] = 0

##### Adjacency List

_Complexity_: `O(1)`

Removing an edge from an adjacency list is simple:

    self.vertices[v1].remove(v2)

Both are constant-time operations.

_Takeaway: Removing edges from both adjacency matrices and lists is very efficient._

---

#### Find Edge

##### Adjacency Matrix

_Complexity_: `O(1)`

Finding an edge in an adjacency matrix is simple:

    return self.edges[v1][v2] > 0

##### Adjacency List

_Complexity_: `O(1)`

Finding an edge in an adjacency list is simple:

    return v2 in self.vertices[v1]

Both are constant-time operations.

_Takeaway: Finding edges in both adjacency matrices and lists is very efficient._

---

#### Get All Edges from Vertex

There are several commands you can use if you want to know all the edges originating from a particular vertex.

##### Adjacency Matrix

_Complexity_: `O(V)`

In an adjacency matrix, this is complicated. You would need to iterate through the entire row and populate a list based on the results:

    v_edges = []
    for v2 in self.edges[v]:
        if self.edges[v][v2] > 0:
            v_edges.append(v2)
    return v_edges

##### Adjacency List

_Complexity_: `O(1)`

With an adjacency list, this is as simple as returning the value from the vertex dictionary:

    return self.vertex[v]

_Takeaway: Fetching all edges is less efficient in an adjacency matrix than an adjacency listd._

---

#### Summary

Let’s summarize all this complexity information in a table:

<table><thead><tr class="header"><th> </th><th><strong>Space</strong></th><th><strong>Add Vert</strong></th><th><strong>Remove Vert</strong></th><th><strong>Add Edge</strong></th><th><strong>Remove Edge</strong></th><th><strong>Find Edge</strong></th><th><strong>Get All Edges</strong></th></tr></thead><tbody><tr class="odd"><td><strong>Matrix</strong></td><td><code class="highlighter-rouge">O(V^2)</code></td><td><code class="highlighter-rouge">O(V)</code></td><td><code class="highlighter-rouge">O(V^2)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(V)</code></td></tr><tr class="even"><td><strong>List</strong></td><td><code class="highlighter-rouge">O(V+E)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(V)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(1)</code></td><td><code class="highlighter-rouge">O(1)</code></td></tr></tbody></table>

In most practical use-cases, an adjacency list will be a better choice for representing a graph. However, it is also important that you be familiar with the matrix representation. Why? Because there are some dense graphs or weighted graphs that could have better space efficiency when represented by a matrix.

##### Follow Along

![we-do-graph-example.001](https://i.imgur.com/yi1P4AF.jpg)

Together, we will now use the graph shown in the picture above and represent it in both an adjacency list and an adjacency matrix.

### Adjacency List

First, the adjacency list:

    class Graph:
        def __init__(self):
            self.vertices = {
                                "A": {"B": 1},
                                "B": {"C": 3, "D": 2},
                                "C": {},
                                "D": {},
                                "E": {"D": 1}
                            }
    }

The difference between this implementation and the previous adjacency list that we used is that this represenation allows our edges to have weights.

### Adjacency Matrix

Now, we need to implement an adjacency matrix. Remember, that one benefit of the matrix is how easy it is to represent edge weights:

    class Graph:
        def __init__(self):
            self.edges = [[0,1,0,0,0],
                          [0,0,3,2,0],
                          [0,0,0,0,0],
                          [0,0,0,0,0],
                          [0,0,0,1,0]]

##### Challenge

![graph-you-do-example.001](https://i.imgur.com/cJ6lekM.jpg)

1.  Using the graph shown in the picture above, write python code to represent the graph in an adjacency list.
2.  Using the same graph you used for the first exercise, write python code to represent the graph in an adjacency matrix.
3.  Write a paragraph that compares and contrasts the efficiency of your different representations.

---

#### Learn to represent a breadth-first-search of a graph in pseudo-code and recall common applications for its use

##### Overview

One method we can use when searching a graph is a **breadth first search** (BFS). This sorting algorithm explores the graph outward in rings of increasing distance from the starting vertex.

The algorithm never attempts to explore a vert it has already explored or is currently exploring.

For example, when starting from the upper left, the numbers on this graph show a vertex visitation order in a BFS:

![breadth-first-search-visit-order.001](https://i.imgur.com/1LPnOAX.jpg)

We followed the edges represented with thicker black arrows. We did not follow the edges represented with thinner grey arrows because we already visited their destination nodes.

The exact order will vary depending on which branches get taken first and which vertex is the starting vertex.

_Note: it’s important to know the distincition between a breadth-first search and a breadth-first traversal. A breadth-first traversal is when you visit each vertex in breadth-first order and do something during the traversal. A breadth-first search is when you search through vertexes in breadth-first order until you find the target vertex. A breadth-first search usually returns the shortest path from the starting vertex to the target vertex once the target is found._

### Applications of BFS

- Pathfinding, Routing
- Find neighbor nodes in a P2P network like BitTorrent
- Web crawlers
- Finding people `n` connections away on a social network
- Find neighboring locations on graph
- Broadcasting in a network
- Cycle detection in a graph
- Finding [Connected Components](<https://en.wikipedia.org/wiki/Connected_component_(graph_theory)>)
- Solving several theoretical graph problems

### Coloring Vertexes

As we explore the graph, it is useful to color verts as we arrive at them and as we leave them behind as “already searched”.

Unvisited verts are white, verts whose neighbors are being explored are gray, and verts with no unexplored neighbors are black.

### Keeping Track of What We Need to Explore

In a BFS, it’s useful to track which nodes we need to follow up on. For example, in the diagram above, when we get to node 2, we know that we also need to explore nodes 3 and 4.

We can track that by adding neighbors to a _queue_ (which remember is first in, first out), and then explore the verts in the queue one by one.

##### Follow Along

### Pseudo-code for BFS

Let’s explore some pseudo-code that shows a basic implementation of a breadth-first-search of a graph. Make sure you can read the pseudo-code and understand what each line is doing before moving on.

    BFS(graph, startVert):
        for v of graph.vertexes:
            v.color = white

        startVert.color = gray
            queue.enqueue(startVert)

        while !queue.isEmpty():
            u = queue[0]  // Peek at head of the queue, but do not dequeue!

            for v of u.neighbors:
                if v.color == white:
                    v.color = gray
                    queue.enqueue(v)

            queue.dequeue()
            u.color = black

You can see that we start with a graph and the vertex we will start on. The very first thing we do is go through each of the vertexes in the graph and mark them with the color white. This means that at the outset, we mark all the verts as unvisited.

Next, we mark the starting vert as gray. This means we are exploring the starting verts’ neighbors. We also enqueue the starting vert which means it will be the first vert we look at once we enter the while loop.

The condition we check at the outset of each while loop is if the queue is **not** empty. If it is not empty, we peek at the first item in the queue by storing it in a variable.

Then, we loop through each of that vert’s neighbors and: - We check if it is unvisited (the color white). - If it is unvisited, we mark it as gray (meaning we will explore its neighbors). - We enqueue the vert.

Next, we dequeue the current vert we’ve been exploring and mark that vert as black (marking it as visited).

We continue on with this process until we have explored all the verts in the graph.

##### Challenge

On your own, complete the following tasks:

1.  Spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a breadth-first-search starting with vertex `"I"`.

         class Graph:
             def __init__(self):
                 self.vertices = {
                                     "A": {"B", "C", "D"},
                                     "B": {},
                                     "C": {"E", "F"},
                                     "D": {"G"},
                                     "E": {"G"},
                                     "F": {"J"},
                                     "G": {},
                                     "H": {"C", "J", "K"},
                                     "I": {"D", "E", "H"},
                                     "J": {"L"},
                                     "K": {"C"},
                                     "L": {"M"},
                                     "M": {},
                                     "N": {"H", "K", "M"}
                                 }

3.  Besides marking verts with colors as in the pseudo-code example above, how else could you track the verts we have already visited?

---

#### Learn to represent a depth-first-search of a graph in pseudo-code and recall common applications for its use

##### Overview

Another method we can use when searching a graph is a **depth first search** (DFS). This searching algorithm _“dives”_ _“down”_ the graph as far as it can before backtracking and exploring another branch.

The algorithm never attempts to explore a vert it has already explored or is in the process of exploring.

For example, when starting from the upper left, the numbers on this graph show a vertex visitation order in a DFS:

![depth-first-search-visit-order.001](https://i.imgur.com/VVTC9Yx.jpg)

We followed the edges represented with thicker black arrows. We did not follow the edges represented with thinner grey arrows because we already visited their destination nodes.

The exact order will vary depending on which branches get taken first and which vertex is the starting vertex.

### Applications of DFS

DFS is often the preferred method or exploring a graph _if we want to ensure we visit every node in the graph_. As an example, let’s say that we have a graph that represents all the friendships in the entire world. We want to find a path between two known people `Andy` and `Sarah`. If we used a depth-first search in this scenario we could end up extremely far away from `Andy` while still not finding a path to `Sarah`. Using a DFS, we will eventually find the path, but it won’t find the shortest path and it will also likely take a long time.

So, this is an example of where a DFS _would not work well_. What about a good use case for DFS. Here are a few examples:

- Finding [Minimum Spanning Trees](https://en.wikipedia.org/wiki/Minimum_spanning_tree) of weighted graphs
- Path finding
- Detecting cycles in graphs
- [Topological sorting](https://en.wikipedia.org/wiki/Topological_sorting), useful for scheduling sequences of dependent jobs
- Solving and generating mazes

### Coloring Vertexes

Again, as we explore the graph, it is useful to color verts as we arrive at them and as we leave them behind as “already searched”.

Unvisited verts are white, verts whose neighbors are being explored are gray, and verts with no unexplored neighbors are black.

### Recursion

Since DFS will pursue leads in the graph as far as it can, and then “back up” to an earlier branch point to explore that way, recursion is a good approach to help “remember” where we left off.

Looking at it with pseudo-code to make the recursion more clear:

    explore(graph) {
        visit(this_vert);
        explore(remaining_graph);
    }

##### Follow Along

### Pseudo-code for DFS

Let’s explore some pseudo-code that shows a basic implementation of a depth-first-search of a graph. Make sure you can read the pseudo-code and understand what each line is doing before moving on.

    DFS(graph):
        for v of graph.verts:
            v.color = white
            v.parent = null

        for v of graph.verts:
            if v.color == white:
                DFS_visit(v)

    DFS_visit(v):
        v.color = gray

        for neighbor of v.adjacent_nodes:
            if neighbor.color == white:
                neighbor.parent = v
                DFS_visit(neighbor)

        v.color = black

You can see that we have two functions in our pseudo-code above. The first function, `DFS()` takes the graph as a parameter and marks all the verts as unvisited (white). It also sets the parent of each vert to `null`. The next loop in this function visits each vert in the graph and if it is unvisited, then it passes that vert into our second function `DFS_visit()`.

`DFS_visit()` starts out by marking the vert as gray (in the process of being explored). Then, it loops through all of its unvisited neighbors. In that loop, it sets the parent and then makes a recursive call to the `DFS_visit()`. Once it’s done exploring all the neighbors, it marks the vert as black (visited).

##### Challenge

On your own, complete the following tasks:

1.  Spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a depth-first-search starting with vertex `"I"`.

         class Graph:
             def __init__(self):
                 self.vertices = {
                                     "A": {"B", "C", "D"},
                                     "B": {},
                                     "C": {"E", "F"},
                                     "D": {"G"},
                                     "E": {"G"},
                                     "F": {"J"},
                                     "G": {},
                                     "H": {"C", "J", "K"},
                                     "I": {"D", "E", "H"},
                                     "J": {"L"},
                                     "K": {"C"},
                                     "L": {"M"},
                                     "M": {},
                                     "N": {"H", "K", "M"}
                                 }

---

## <a href="#guided-project" id="guided-project" class="anchor"><span class="octicon octicon-link"></span></a>Guided Project

### Graphs 1

Implement a Graph using a adjacency list and adjacency matrix

[GitHub Repo](https://github.com/LambdaSchool/Graphs)

---

## <a href="#project" id="project" class="anchor"><span class="octicon octicon-link"></span></a>Project

- ##### [Graphs](https://github.com/LambdaSchool/Graphs)

  ### Part 1: Graph, Vertex, Edge Classes

  In the file `graph.py`, implement a `Graph` class that supports the API expected by `draw.py`. In particular, this means there should be a field `vertices` that contains a dictionary mapping vertex labels to edges. For example:

      {
          '0': {'1', '3'},
          '1': {'0'},
          '2': set(),
          '3': {'0'}
      }

  This represents a graph with four vertices and two total (bidirectional) edges. The vertex `'2'` has no edges, while `'0'` is connected to both `'1'` and `'3'`.

  You should also create `add_vertex` and `add_edge` methods that add the specified entities to the graph. To test your implementation, instantiate an empty graph and then try to run the following:

      graph = Graph()  # Instantiate your graph
      graph.add_vertex('0')
      graph.add_vertex('1')
      graph.add_vertex('2')
      graph.add_vertex('3')
      graph.add_edge('0', '1')
      graph.add_edge('0', '3')
      print(graph.vertices)

  You should see something like the first example. As a stretch goal, add checks to your graph to ensure that edges to nonexistent vertices are rejected.

      # Continuing from previous example
      graph.add_edge('0', '4')  # No '4' vertex, should raise an Exception!

  ### Part 2: Implement Breadth-First Traversal

  Write a function within your Graph class that takes takes a starting node as an argument, then performs BFT. Your function should print the resulting nodes in the order they were visited.

  ### Part 3: Implement Depth-First Traversal with a Stack

  Write a function within your Graph class that takes takes a starting node as an argument, then performs DFT. Your function should print the resulting nodes in the order they were visited.

  ### Part 3.5: Implement Depth-First Traversal using Recursion

  Write a function within your Graph class that takes takes a starting node as an argument, then performs DFT using recursion. Your function should print the resulting nodes in the order they were visited.

  ### Part 4: Implement Breadth-First Search

  Write a function within your Graph class that takes takes a starting node and a destination node as an argument, then performs BFS. Your function should return the shortest path from the start node to the destination node.

  ### Part 5: Implement Depth-First Search

  Write a function within your Graph class that takes takes a starting node and a destination node as an argument, then performs DFS. Your function should return a valid path (not necessarily the shortest) from the start node to the destination node.

## <a href="#review" id="review" class="anchor"><span class="octicon octicon-link"></span></a>Review

### Class Recordings

You can use class recordings to help you master the material.

- **[CSPT15 Graphs I with Tom Tarpey](https://youtu.be/-NXqrVZmbRk)**

  Lecture recording

- [All previous recordings](/archive/CS/module/recBMbHtb8AOXq3UL)

### Demonstrate Mastery

To demonstrate mastery of this module, you need to complete and pass a code review on each of the following:

- Objective challenge:

  Do the following on your own.

  Draw one graph for each of the descriptions below:

  1.  Undirected graph of 4 verts.
  2.  Directed graph of 5 verts.
  3.  Cyclic directed graph of 6 verts.
  4.  DAG of 7 verts.

- Objective challenge:

  ![graph-you-do-example.001](https://i.imgur.com/cJ6lekM.jpg)

  1.  Using the graph shown in the picture above, write python code to represent the graph in an adjacency list.
  2.  Using the same graph you used for the first exercise, write python code to represent the graph in an adjacency matrix.
  3.  Write a paragraph that compares and contrasts the efficiency of your different representations.

- Objective challenge:

  On your own, complete the following tasks:

  1.  Spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

  2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a breadth-first-search starting with vertex `"I"`.

           class Graph:
               def __init__(self):
                   self.vertices = {
                                       "A": {"B", "C", "D"},
                                       "B": {},
                                       "C": {"E", "F"},
                                       "D": {"G"},
                                       "E": {"G"},
                                       "F": {"J"},
                                       "G": {},
                                       "H": {"C", "J", "K"},
                                       "I": {"D", "E", "H"},
                                       "J": {"L"},
                                       "K": {"C"},
                                       "L": {"M"},
                                       "M": {},
                                       "N": {"H", "K", "M"}
                                   }

  3.  Besides marking verts with colors as in the pseudo-code example above, how else could you track the verts we have already visited?

- Objective challenge:

  On your own, complete the following tasks:

  1.  Spend a few minutes researching to find a unique use-case of a breadth-first-search that we did not mention in the list above.

  2.  Using the graph represented below, draw a picture of the graph and label each of the verts to show the correct vertex visitation order for a depth-first-search starting with vertex `"I"`.

           class Graph:
               def __init__(self):
                   self.vertices = {
                                       "A": {"B", "C", "D"},
                                       "B": {},
                                       "C": {"E", "F"},
                                       "D": {"G"},
                                       "E": {"G"},
                                       "F": {"J"},
                                       "G": {},
                                       "H": {"C", "J", "K"},
                                       "I": {"D", "E", "H"},
                                       "J": {"L"},
                                       "K": {"C"},
                                       "L": {"M"},
                                       "M": {},
                                       "N": {"H", "K", "M"}
                                   }

- Guided Project: Graphs 1

- Project: Graphs
